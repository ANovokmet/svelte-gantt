{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\src\\Grid.html",
    "..\\src\\Row.html",
    "..\\src\\RowHeader.html",
    "..\\src\\Column.html",
    "..\\src\\ColumnHeader.html",
    "..\\src\\Task.html",
    "..\\src\\Dependency.html",
    "..\\src\\ContextMenu.html",
    "..\\src\\Arrow.html",
    "..\\src\\GanttDependencies.html"
  ],
  "sourcesContent": [
    "<div class=\"grid\" use:disableContextMenu>\r\n\r\n    <div class=\"side-header-container\" style=\"width:100px\" ref:sideHeaderContainer>\r\n    \r\n    </div>\r\n\r\n    <div class=\"main-header-container\" use:horizontalScrollListener  ref:sideContainer>\r\n        <div class=\"header-container\" style=\"width:{$width}px\">\r\n            {#each $headers as header}\r\n                <ColumnHeader header={header}/>\r\n            {/each}\r\n        </div>\r\n    </div>\r\n\r\n    <div class=\"side-container\" style=\"height:{$height}px\" use:scrollListener>\r\n        <div class=\"row-header-container\" style=\"padding-top:{paddingTop}px;padding-bottom:{paddingBottom}px;height:{rowContainerHeight}px;\"> \r\n            {#each visibleRows as row (row.id)}\r\n                <RowHeader \r\n                    label={row.label}/>\r\n            {/each}\r\n        </div>\r\n    </div>\r\n\r\n    <div class=\"main-container\" style=\"height:{$height}px\" use:scrollable ref:mainContainer>\r\n        <div class=\"content\" style=\"width:{$width}px\">\r\n            \r\n\r\n            <div class=\"column-container\">\r\n                {#each columns as column}\r\n                    <Column width={column.width}/>\r\n                {/each}\r\n            </div>    \r\n            <div class=\"row-container\" style=\"padding-top:{paddingTop}px;padding-bottom:{paddingBottom}px;height:{rowContainerHeight}px;\"\r\n                ref:rowContainer>\r\n                {#each visibleRows as row (row.id)}\r\n                    <Row row={row}\r\n                        width={width}\r\n                        on:updateVisibleRows=\"updateViewport()\"/>\r\n                {/each}\r\n            </div>\r\n            {#each _modulesContainer as module (module.key)}\r\n                <svelte:component this={module} on:init=\"initModule(event.module)\" />\r\n            {/each}\r\n        </div>\r\n    </div>\r\n\r\n</div>\r\n<ExternalDiv gantt={$gantt}>\r\nreal content\r\n</ExternalDiv>\r\n\r\n<style>\r\n    .grid {\r\n        width: 100%;\r\n        position: relative;\r\n        font-family: tahoma, arial, verdana, Sans-serif;\r\n        font-size: 10px;\r\n        color: #656565;\r\n    }\r\n\r\n    .column-container {\r\n        position: absolute;\r\n        height: 100%;\r\n\r\n        float: left;\r\n        overflow: hidden;\r\n    }\r\n\r\n\r\n\r\n    .row-container {\r\n        width: 100%;\r\n        /* display: inline-block; */\r\n        box-sizing: border-box;\r\n    }\r\n\r\n    .row-header-container {\r\n        \r\n        box-sizing: border-box;\r\n    }\r\n\r\n\r\n    .side-container {\r\n        width: 100px;\r\n        float: left;\r\n        overflow-y: hidden;\r\n    }\r\n\r\n    .main-container {\r\n        /* position: relative; */\r\n        overflow: auto;\r\n    }\r\n\r\n    .side-header-container {\r\n        float: left;\r\n    }\r\n\r\n    .main-header-container {\r\n        position: relative;\r\n        overflow: hidden;\r\n    }\r\n\r\n    .content {\r\n        position: relative;\r\n    }\r\n\r\n</style>\r\n\r\n<script>\r\n    import ExternalDiv from './ExternalDiv.html';\r\n\r\n    import Row from './Row.html';\r\n    import RowHeader from './RowHeader.html';\r\n    import Column from './Column.html';\r\n    import ColumnHeader from './ColumnHeader.html';\r\n    import { Store } from 'svelte/store.js';\r\n    import ContextMenuManager from './contextMenuManager.js'\r\n    import SelectionManager from './selectionManager.js'\r\n    import GanttUtils from \"./utils.js\";\r\n\r\n    import Task from \"./Task.html\";\r\n    import SvelteTask from \"./task.js\";\r\n\r\n    import GanttDependencies from './GanttDependencies.html';\r\n\r\n    let SvelteGantt;\r\n\r\n    export default {\r\n        setup(component){\r\n            SvelteGantt = component;\r\n            SvelteGantt.defaults = {\r\n\t\t\t\twidth: 800,\r\n\t\t\t\theight: 400,\r\n\t\t\t\tmagnetOffset: 15,\r\n\t\t\t\tmagnetUnit: 'minute',\r\n\t\t\t\theaderHeight: 100,\r\n\t\t\t\theaders: [{unit: 'day', format: 'DD.MM.YYYY'}, {unit: 'hour', format: 'HH'}],\r\n\t\t\t\trowHeight: 24\r\n            };\r\n\r\n            SvelteGantt.create = function(target, data, options) {\r\n\r\n                const store = new Store();\r\n\r\n                const ganttOptions = Object.assign({}, SvelteGantt.defaults, options);\r\n                const ganttUtils = new GanttUtils(ganttOptions);\r\n\r\n                store.set(ganttOptions);\r\n                store.set({ \r\n                    rows: data.rows,\r\n                    contextMenuManager: new ContextMenuManager(),\r\n                    selectionManager: new SelectionManager((t) => { t.component && t.component.set({task: t}) }),\r\n                    ganttUtils: ganttUtils\r\n                });\r\n\r\n                data._allTasks = [];\r\n                for(let i=0; i < data.rows.length; i++){\r\n                    const row = data.rows[i];\r\n                    for(let j=0; j < row.tasks.length; j++){\r\n                        const task = row.tasks[j];\r\n                        task.amountDone = task.amountDone || 0;\r\n                        task.row = row;\r\n\r\n                        row.tasks[j] = new SvelteTask(task, ganttUtils);\r\n                        data._allTasks.push(row.tasks[j]);\r\n                    }\r\n                }\r\n\r\n                return new SvelteGantt({\r\n                    target,\r\n                    data,\r\n                    store\r\n                })\r\n            }\r\n        },\r\n        components: { Row, Column, RowHeader, ColumnHeader, ExternalDiv },\r\n        oncreate(){\r\n            this.initColumns();\r\n            this.store.set({\r\n                bodyElement: this.refs.mainContainer, \r\n                rowContainerElement: this.refs.rowContainer,\r\n                gantt: this\r\n            });\r\n            \r\n            this.updateVisibleRows(this.refs.mainContainer.scrollTop, this.refs.mainContainer.clientHeight);\r\n            this.broadcastModules('updateVisible', {\r\n                scrollAmount: this.refs.mainContainer.scrollTop, \r\n                viewportHeight: this.refs.mainContainer.clientHeight\r\n            });\r\n            this.updateHeaderHeight();\r\n        },\r\n        actions: {\r\n            disableContextMenu(node) {\r\n                node.addEventListener('contextmenu', function(e) {\r\n                    e.preventDefault();\r\n                }, false);\r\n                //ovo dolje radi kad stvoriÅ¡ svelte contextmenu, klikne na sam contextmenu TO DO remove\r\n                document.addEventListener('contextmenu', function(e) {\r\n                    e.preventDefault();\r\n                }, false);\r\n            },\r\n            scrollable(node){\r\n                const { scrollables } = this.get();\r\n                const self = this;\r\n\r\n                function onscroll(event) {\r\n                    const scrollAmount = node.scrollTop; \r\n\r\n                    console.log(scrollAmount);\r\n                    for(let i=0; i< scrollables.length; i++){\r\n                        const scrollable = scrollables[i];\r\n                        if(scrollable.orientation === 'horizontal') {\r\n                            scrollable.node.scrollLeft = node.scrollLeft;\r\n                        }\r\n                        else {\r\n                            scrollable.node.scrollTop = scrollAmount;\r\n                        }\r\n                    }\r\n                    //TODO: only for vertical scroll\r\n                    self.updateVisibleRows(scrollAmount, node.clientHeight);\r\n\r\n                    self.broadcastModules('updateVisible', {scrollAmount, viewportHeight: node.clientHeight});\r\n                }\r\n\r\n                node.addEventListener('scroll', onscroll);\r\n                return {\r\n\t\t\t\t\tdestroy() {\r\n\t\t\t\t\t\tnode.removeEventListener('scroll', onscroll, false);\r\n\t\t\t\t\t}\r\n                }\r\n            },\r\n            scrollListener(node){\r\n                const { scrollables } = this.get();\r\n                scrollables.push({node});\r\n            },\r\n            horizontalScrollListener(node){\r\n                const { scrollables } = this.get();\r\n                scrollables.push({node, orientation: 'horizontal'});\r\n            }\r\n\t\t},\r\n        methods: {\r\n            initModule(module){\r\n                const moduleOptions = Object.assign({\r\n                    _gantt: this,\r\n                    _options: this.get()\r\n                }, {});//merge with module specific data, modules[module.constructor.key]);\r\n                module.initModule(moduleOptions);\r\n                \r\n                const {_modules} = this.get();\r\n                _modules.push(module);\r\n            },\r\n            broadcastModules(event, data) {\r\n                const {_modules} = this.get();\r\n                _modules.forEach((module) => {\r\n                    if (typeof module[event] === 'function') {\r\n                        module[event](data);\r\n                    }\r\n                });\r\n            },\r\n            updateVisibleRows(scrollTop, viewportHeight){\r\n                console.log('update v rows');\r\n                const { rows, rowHeight } = this.store.get();\r\n\r\n                let startIndex = Math.floor(scrollTop / rowHeight);\r\n                let endIndex = Math.min(startIndex + Math.ceil(viewportHeight / rowHeight ), rows.length - 1);\r\n\r\n                console.log('['+startIndex+','+endIndex+']');\r\n\r\n                const paddingTop = startIndex * rowHeight;\r\n                const paddingBottom = rows.length * rowHeight - viewportHeight - paddingTop;\r\n\r\n\r\n                const visibleRows = rows.slice(startIndex, endIndex + 1);\r\n\r\n                //only horizontal scroll\r\n                visibleRows.forEach(row => {\r\n                    row.visibleTasks = this.visibleTasks(row);\r\n                })\r\n\r\n                this.set({ visibleRows: visibleRows, paddingTop: paddingTop, paddingBottom: paddingBottom });\r\n                this.store.set({ visibleRows });\r\n            },\r\n            visibleTasks(row){\r\n                const scrollLeft = this.refs.mainContainer.scrollLeft;\r\n                const clientWidth = this.refs.mainContainer.clientWidth;\r\n                //finish this\r\n                this.store.set({scrollLeft, clientWidth});\r\n\r\n                //da su sortirani -> index prvog, zadnjeg, i onda slice\r\n                //da su sortirani -> nakon zadnjeg break\r\n                const visibleTasks = [];\r\n                row.tasks.forEach(task => {\r\n                    if(!(task.left + task.width < scrollLeft || task.left > scrollLeft + clientWidth)){\r\n                        visibleTasks.push(task);\r\n                    }\r\n                });\r\n                console.log(visibleTasks.length);\r\n                return visibleTasks;\r\n            },\r\n            updateViewport(){\r\n                console.log('update v port');\r\n                const {scrollTop, clientHeight} = this.refs.mainContainer;\r\n\r\n                this.updateVisibleRows(scrollTop, clientHeight);\r\n                this.broadcastModules('updateVisible', {scrollAmount: scrollTop, viewportHeight: clientHeight});\r\n            },\r\n            initColumns() {\r\n                const {ganttUtils, magnetOffset, magnetUnit} = this.store.get();\r\n                const columnWidth = ganttUtils.getPositionByDate(ganttUtils.from.clone().add(magnetOffset, magnetUnit));\r\n                const columnCount = Math.ceil(ganttUtils.width / columnWidth) \r\n\r\n                const columns = [];\r\n                for(let i = 0; i < columnCount; i++){\r\n                    columns.push({width: columnWidth});\r\n                }\r\n\r\n                this.set({ columns });\r\n            },\r\n            updateHeaderHeight() {\r\n                const height = this.refs.sideContainer.clientHeight;\r\n                this.refs.sideHeaderContainer.style.height = height + 'px';\r\n            }\r\n        },\r\n        data() {\r\n            return {\r\n                columns: [],\r\n                scrollables: [],\r\n                visibleRows: [],\r\n                _modulesContainer: [GanttDependencies],\r\n                _modules: []\r\n            }\r\n        },\r\n        computed: {\r\n            rowContainerHeight: ({rows, $rowHeight}) => rows.length * $rowHeight\r\n        }\r\n    };\r\n</script>",
    "<div class=\"row\" ref:row style=\"height:{$rowHeight}px\" use:contextMenu>\r\n    {#each row.tasks as task (task.id)}\r\n        <Task   row={row}\r\n                task={task}  \r\n                on:updateVisibleRows \r\n                on:taskMoved=\"taskMoved()\"\r\n                on:taskMovedRow=\"taskAdded()\"\r\n                on:taskRemovedRow=\"taskRemoved()\"\r\n                on:taskResized=\"taskMoved()\"\r\n                on:taskDropped=\"taskDropped(task)\"/>\r\n    {/each}\r\n</div>\r\n<style>\r\n    .row {\r\n        position: relative;\r\n        width: 100%;\r\n        border-bottom: #efefef 1px solid;\r\n        box-sizing: border-box;\r\n    }\r\n</style>\r\n<script>\r\n    import Task from './Task.html';\r\n    import ContextMenu from \"./ContextMenu.html\";\r\n    import { DOMUtils } from \"./domUtils.js\";\r\n\r\n    export default {\r\n        components: { Task },\r\n        oncreate() {\r\n            const { row } = this.get();\r\n            row.rowElement = this.refs.row;\r\n            row.component = this;\r\n        },\r\n        onupdate({ changed, current, previous }) {\r\n            \r\n        },\r\n        ondestroy(){\r\n            const { row } = this.get();\r\n            row.rowElement = null;\r\n            row.component = null;\r\n        },\r\n        methods: {\r\n            taskMoved() {\r\n                console.log('Task moved')\r\n                const { row } = this.get();\r\n                this.set({ row });\r\n            },\r\n            taskAdded() {\r\n                //when task moving to row, need to update row to show new task\r\n                const { row } = this.get();\r\n                console.log('Task moved to row', row);\r\n                this.set({ row });\r\n            },\r\n            taskRemoved() {\r\n                const { row } = this.get();\r\n                console.log('Task removed from row', row);\r\n                this.set({ row });\r\n            },\r\n            taskDropped(task) {\r\n                this.sortTasks();\r\n                const { row } = this.get();\r\n                const overlaps = [];\r\n                let previous = row.tasks[0];\r\n                for(let i = 1; i < row.tasks.length; i++){\r\n                    const current = row.tasks[i];\r\n\r\n                    if(current.overlaps(previous))\r\n                    {\r\n                        if(current.overlapping !== true){\r\n                            current.overlapping = true;\r\n                            current.component.set({ task: current });\r\n                        }\r\n                        if(previous.overlapping !== true){\r\n                            previous.overlapping = true;\r\n                            previous.component.set({ task: previous });\r\n                        }\r\n\r\n                        if(overlaps.indexOf(current.id) === -1){\r\n                            overlaps.push(current.id);\r\n                        }\r\n\r\n                        if(overlaps.indexOf(previous.id) === -1){\r\n                            overlaps.push(previous.id);\r\n                        }\r\n                    }\r\n\r\n                    if (previous.left + previous.width < current.left + current.width) {\r\n                        previous = current;\r\n                    }\r\n                }\r\n\r\n                for(let i = 0; i < row.tasks.length; i++){\r\n                    const current = row.tasks[i];\r\n                    if(overlaps.indexOf(current.id) === -1){\r\n                        if(!!current.overlapping) {\r\n                            current.overlapping = false;\r\n                            current.component.set({ task: current });\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            sortTasks() {\r\n                const { row } =  this.get();\r\n                row.tasks.sort(function (a, b) {\r\n                    if (a.left < b.left) {\r\n                        return -1\r\n                    } else if (a.left > b.left) {\r\n                        return 1\r\n                    }\r\n                    return 0\r\n                });\r\n            }\r\n        },\r\n        actions: {\r\n            contextMenu(node){\r\n                const { row } = this.get();\r\n                const { contextMenuManager } = this.store.get();\r\n\r\n                const options = [\r\n                    {\r\n                        label: 'Copy row',\r\n                        action: () => console.log('clicked action 1 for task ', row.id)\r\n                    },\r\n                    {\r\n                        label: 'Clear dependencies',\r\n                        action: () => console.log('clicked action 2 for task ', row.id)\r\n                    }\r\n                ];\r\n\r\n\r\n                function onClose(event) {\r\n                    //if(!contextMenu.isTarget(e))\r\n                    contextMenuManager.close();\r\n                }\r\n\r\n                node.addEventListener('mouseup', (e) => {\r\n                    //e.stopPropagation();\r\n                    if(e.which === 3){\r\n                        contextMenuManager.open(options, {x: e.x, y: e.y});\r\n\r\n                        DOMUtils.addEventListenerOnce(node, 'mousedown', onClose); //document.body\r\n                    }\r\n                });\r\n\r\n                return {\r\n                    destroy() {\r\n                        contextMenuManager.close();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n</script>",
    "<div class=\"row-header\">\r\n    {label}\r\n</div>\r\n<style>\r\n    .row-header {\r\n        position: relative;\r\n        height: 24px;\r\n\r\n        border-bottom: #efefef 1px solid;    \r\n        background-color: #fbfbfb;\r\n        font-weight: bold;\r\n        box-sizing: border-box;\r\n    }\r\n</style>\r\n<script>\r\n    export default {\r\n        oncreate(){\r\n            \r\n        },\r\n        data() {\r\n            return {\r\n                label: ''\r\n            }\r\n        }\r\n    }\r\n</script>",
    "<div class=\"column\" style=\"width:{width}px\"></div>\r\n<style>\r\n    .column {\r\n        position: relative;\r\n        display: inline-block;\r\n        height: 100%;    \r\n        border-left: #efefef 1px solid;\r\n        box-sizing: border-box;\r\n    }\r\n</style>",
    "<div class=\"column-header-row\" style=\"width:{width}px\">\r\n\r\n    {#each headers as header}\r\n        <div class=\"column-header\" style=\"width:{header.width}px\">\r\n            {header.label || 'N/A'}\r\n        </div>\r\n    {/each}\r\n</div>\r\n<style>\r\n    .column-header-row {\r\n        box-sizing: border-box;\r\n        border-top: 1px solid #ddd;\r\n        white-space: nowrap;\r\n        overflow: hidden;\r\n    }\r\n\r\n    .column-header {\r\n        position: relative;\r\n        display: inline-block;\r\n        height: 100%;    \r\n        border-left: #efefef 1px solid;\r\n        box-sizing: border-box;\r\n        text-overflow: clip;\r\n        vertical-align: top;\r\n        text-align: center;\r\n    }\r\n</style>\r\n<script>\r\n    import moment from \"../node_modules/moment/src/moment.js\";\r\n\r\n    export default {\r\n        oncreate() {\r\n            \r\n            const { header } = this.get();\r\n\r\n            const { from, width, ganttUtils } = this.store.get();\r\n            const columnWidth = ganttUtils.getPositionByDate(from.clone().add(1, header.unit));\r\n            \r\n            const columnCount = Math.ceil(width / columnWidth) \r\n\r\n            var headers = [];\r\n            \r\n            \r\n\r\n            var headerTime = from.clone();\r\n\r\n            for(let i=0; i< columnCount; i++){\r\n                headers.push({width: columnWidth, label: headerTime.format(header.format)});\r\n                headerTime.add(1, header.unit);\r\n            }\r\n\r\n            this.set({headers: headers});\r\n        },\r\n        data(){\r\n            return {\r\n                headers: []\r\n            }\r\n        }\r\n    };\r\n</script>",
    "<div ref:taskElement\r\n    class=\"task\" \r\n    style=\"left:{task.left}px;width:{task.width}px;\"\r\n    use:drag \r\n    use:contextMenu\r\n    use:selectable\r\n    class:overlapping=\"task.overlapping\"\r\n    class:selected=\"task.selected\"\r\n    class:moving=\"task.dragging||task.resizing\">\r\n    <div class=\"task-background\" style=\"width:{task.amountDone}%\"></div>\r\n    {task.label}\r\n</div>\r\n\r\n<style>\r\n    .task {\r\n\t\tposition: absolute;     \r\n        top: 0;\r\n        bottom: 0;   \r\n        height: 80%;\r\n        margin: auto;\r\n        background: rgb(116, 191, 255);\r\n\t}\r\n\r\n    .task-background {\r\n        position: absolute;\r\n        height: 100%;\r\n        background: rgba(0, 0, 0, 0.2);\r\n    }\r\n\r\n    .selected {\r\n        background: rgb(255, 255, 82);\r\n    }\r\n\r\n    .overlapping {\r\n        background: rgb(255, 122, 122);\r\n    }\r\n\r\n    .moving {\r\n        opacity: 0.5;\r\n    }\r\n</style>\r\n\r\n<script>\r\n    import { DOMUtils } from \"./domUtils.js\";\r\n    import ContextMenu from \"./ContextMenu.html\";\r\n\r\n    const resizeHandleWidth = 15;\r\n\r\n    let SvelteTask;\r\n\r\n\r\n\r\n    export default {\r\n        setup(component) {\r\n        },\r\n        oncreate() {\r\n            const { task, row } = this.get();\r\n            task.row = row;\r\n            task.component = this;\r\n        },\r\n        ondestroy() {\r\n            const { task } = this.get();\r\n            if(task.component === this) {\r\n                task.component = null;\r\n            }\r\n        },\r\n        actions: {\r\n\t\t\tdrag(node) {\r\n                const { rowContainerElement, ganttUtils } = this.store.get();\r\n                const windowElement = window;\r\n\r\n                const { task } = this.get();\r\n\r\n                let mouseStartPosX;\r\n                let mouseStartRight;\r\n                \r\n                let originalRow;\r\n\r\n                function onmousedown(event) {\r\n                    if(event.which !== 1){\r\n                        //debugger;\r\n                        return;\r\n                    }\r\n\r\n                    event.stopPropagation();\r\n                    event.preventDefault();\r\n                    console.log('drag down');\r\n                    originalRow = task.row;\r\n\r\n                    mouseStartPosX = DOMUtils.getRelativePos(rowContainerElement, event).x - task.left;\r\n                    mouseStartRight = task.left + task.width;\r\n\r\n                    if(mouseStartPosX < resizeHandleWidth) {\r\n                        task.resizing = true;\r\n                        task.direction = 'left';\r\n                    }\r\n                    else if(mouseStartPosX > task.width - resizeHandleWidth) {\r\n                        task.resizing = true;\r\n                        task.direction = 'right';\r\n                    }\r\n                    else {\r\n                        task.dragging = true;\r\n                    }\r\n\r\n                    windowElement.addEventListener('mousemove', onmousemove, false);\r\n                    DOMUtils.addEventListenerOnce(windowElement, 'mouseup', onmouseup);\r\n                }\r\n                \r\n                function onmousemove(event) {\r\n                    \r\n                    const self = task.component;\r\n\r\n                    event.preventDefault();\r\n                    if(task.resizing) {\r\n                        const mousePos = DOMUtils.getRelativePos(rowContainerElement, event);\r\n                        \r\n                        if(task.direction === 'left') { //resize ulijevo\r\n                            if(mousePos.x > task.left + task.width) {\r\n                                task.left = mouseStartRight; //mousePos.x //\r\n                                task.width = task.left - mousePos.x;\r\n                                task.direction = 'right'\r\n                                mouseStartRight = task.left + task.width;\r\n                            }\r\n                            else{\r\n                                task.left = mousePos.x;\r\n                                task.width = mouseStartRight - mousePos.x;\r\n                            }\r\n                        }\r\n                        else if(task.direction === 'right') {//resize desno\r\n                            if(mousePos.x <= task.left) {\r\n                                task.width = task.left - mousePos.x;\r\n                                task.left = mousePos.x;\r\n                                task.direction = 'left';\r\n                                mouseStartRight = task.left + task.width;\r\n                            }\r\n                            else {\r\n                                task.width = mousePos.x - task.left;\r\n                            }\r\n                        }\r\n\r\n                        console.log(mousePos.x, mouseStartPosX)\r\n\r\n                        self.updateTaskDate();\r\n                        self.updateTaskPosition();\r\n                        self.set({ task });\r\n                        self.fire('taskResized', { task: task });\r\n                    }\r\n\r\n                    if(task.dragging) {\r\n                        const mousePos = DOMUtils.getRelativePos(rowContainerElement, event);\r\n                        task.left = mousePos.x - mouseStartPosX;\r\n\r\n                        self.updateTaskDate();//pomaknuti na kraj funkcije\r\n                        self.updateTaskPosition();\r\n                        \r\n                        //row switching\r\n                        const rowCenterX = rowContainerElement.getBoundingClientRect().left + rowContainerElement.getBoundingClientRect().width / 2;\r\n                        const sourceRow = task.row;\r\n\r\n                        let elements = document.elementsFromPoint(rowCenterX, event.clientY);\r\n                        let rowElement = elements.find((element) => element.classList.contains('row'));\r\n                        if(rowElement !== undefined && rowElement !== sourceRow.rowElement) {\r\n\r\n                            const { visibleRows } = self.store.get();\r\n\r\n                            const targetRow = visibleRows.find((r) => r.rowElement === rowElement);\r\n                            console.log('move task to '+targetRow.label, targetRow);\r\n\r\n                            task.row = targetRow;\r\n                            targetRow.tasks.push(task);\r\n                            \r\n                            let i, sourceTask;\r\n                            for (i = 0; i < sourceRow.tasks.length; i++) {\r\n                                sourceTask = sourceRow.tasks[i]\r\n                                if (sourceTask === task) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            sourceRow.tasks.splice(i, 1);\r\n                            self.store.set({visibleRows: visibleRows});\r\n                            \r\n                            //targetRow.component.movedRow();\r\n                            //sourceRow.component.movedRow();\r\n                            self.fire('taskRemovedRow', { task: task, row: targetRow });\r\n                            targetRow.component.taskAdded();\r\n                        }\r\n                        self.fire('taskMoved', { task: task });\r\n                        //task.component.fire('updateVisibleRows');\r\n                    }\r\n                    self.set({task:task});\r\n                    task.notify();\r\n                }\r\n\r\n                function onmouseup(event) {\r\n                    console.log('drag up'); \r\n                    task.dragging = false;\r\n                    task.resizing = false;\r\n                    task.direction = null;\r\n                    windowElement.removeEventListener('mousemove', onmousemove, false);\r\n                    task.component.fire('taskDropped', { task });\r\n\r\n                    //code this better\r\n                    if(originalRow && originalRow !== task.row) {\r\n                        console.log('moved from original row', originalRow)\r\n                        originalRow.component.taskMoved();\r\n                    }\r\n                }\r\n\r\n                node.addEventListener('mousedown', onmousedown, false);\r\n\r\n                const cursorOnMove = (e) => {\r\n                    const mouseStartPosX = DOMUtils.getRelativePos(rowContainerElement, e).x - task.left;\r\n\r\n                    //TODO globally set cursor ON mousedown\r\n                    if(mouseStartPosX < resizeHandleWidth || mouseStartPosX > task.width - resizeHandleWidth) {\r\n                        this.updateCursor('e-resize');\r\n                    }\r\n                    else{\r\n                        this.updateCursor();\r\n                    }\r\n\r\n                };\r\n                node.addEventListener('mousemove', cursorOnMove, false)\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\tupdate() {\r\n                        \r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tdestroy() {\r\n\t\t\t\t\t\tnode.removeEventListener('mousedown', onmousedown, false);\r\n\t\t\t\t\t\t//windowElement.removeEventListener('mousemove', onmousemove, false);\r\n\t\t\t\t\t\tnode.removeEventListener('mousemove', onmousemove, false);\r\n\t\t\t\t\t\tnode.removeEventListener('mouseup', onmouseup, false);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n            },\r\n            contextMenu(node){\r\n                const { task } = this.get();\r\n                const { contextMenuManager } = this.store.get();\r\n\r\n                const options = [\r\n                    {\r\n                        label: 'Copy',\r\n                        action: () => console.log('clicked action 1 for task ', task.id)\r\n                    },\r\n                    {\r\n                        label: 'Clear dependencies',\r\n                        action: () => console.log('clicked action 2 for task ', task.id)\r\n                    }\r\n                ];\r\n\r\n                function onClose(event) {\r\n                    //if(!contextMenu.isTarget(e))\r\n                    contextMenuManager.close();\r\n                }\r\n\r\n\t\t\t\tnode.addEventListener('mouseup', (e) => {\r\n                    if(e.which === 3){\r\n                        e.stopPropagation();\r\n                        contextMenuManager.open(options, {x: e.x, y: e.y})\r\n\r\n                        DOMUtils.addEventListenerOnce(node, 'mousedown', onClose); //document.body\r\n                    }\r\n                });\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\tdestroy() {\r\n                        contextMenuManager.close();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n            },\r\n            selectable(node) {\r\n                const { task } = this.get();\r\n                const { selectionManager } = this.store.get();\r\n                const self = this;\r\n                node.addEventListener('click', (e) => {\r\n                    if(e.ctrlKey){\r\n                        selectionManager.toggleSelection(task);\r\n                    }\r\n                    else{\r\n                        selectionManager.selectSingle(task);\r\n                    }\r\n                });\r\n            }\r\n\t\t},\r\n        methods: {\r\n\t\t\tupdateTaskPosition() {\r\n                const { task } = this.get();\r\n                task.updatePosition();\r\n            },\r\n            updateTaskDate() {\r\n                const { task } = this.get();\r\n                task.updateDate();\r\n            },\r\n            updateCursor(cursor){\r\n                const element = this.refs.taskElement;\r\n                element.style.cursor = cursor || 'default';\r\n            }\r\n        },\r\n\r\n        data() {\r\n            return {\r\n                task: { dragging: false }\r\n            }\r\n        }\r\n    };\r\n</script>",
    "<div class=\"dependency\" style=\"left:{0}px;top:{0}px;\">\r\n    <Arrow \r\n        {startX}\r\n        {startY}\r\n        {endX}\r\n        {endY}/>\r\n</div>\r\n\r\n<style>\r\n    .dependency {\r\n\t\tposition: absolute;     \r\n        width:100%;\r\n        height: 100%;\r\n\t}\r\n</style>\r\n<script>\r\n    import Arrow from './Arrow.html';\r\n\r\n    export default {\r\n        components: { Arrow },\r\n        oncreate() { \r\n            const { dependency } = this.get();\r\n            this.set({ \r\n                startX: dependency.startX,\r\n                startY: dependency.startY,\r\n                endX: dependency.endX,\r\n                endY: dependency.endY\r\n            });\r\n\r\n            const { fromTask, toTask } = this.get();\r\n            fromTask.subscribe(this);\r\n            toTask.subscribe(this);\r\n        },\r\n        ondestroy() {\r\n            const { fromTask, toTask } = this.get();\r\n            fromTask.unsubscribe(this);\r\n            toTask.unsubscribe(this);\r\n        },\r\n        data() {\r\n            return {\r\n                startX: 0,\r\n                startY: 0,\r\n                endX: 100,\r\n                endY: 100\r\n            }\r\n        },\r\n        methods: {\r\n            update() {\r\n                const { dependency } = this.get();\r\n                const result = dependency.update();\r\n                this.set(result);\r\n            }\r\n        }\r\n    };\r\n</script>",
    "<div class=\"context-menu\" style=\"top:{top}px;left:{left}px\" ref:contextMenu>\r\n    {#each actions as action}\r\n        <div class=\"context-option\" on:click=\"execute(event, action)\">{action.label}</div>\r\n    {/each}\r\n</div>\r\n\r\n<style>\r\n    .context-menu {\r\n        position: absolute;\r\n        background: white;\r\n        border: 1px solid #ccc;\r\n        padding: 0.25em 0;\r\n        font-size: 12px;\r\n        transition: opacity 0.4s ease 0s;\r\n        opacity: 1;\r\n        box-shadow: rgba(0, 0, 0, 0.32) 1px 1px 3px 0px;\r\n    }\r\n\r\n    .context-option:hover {\r\n        background: #eee;\r\n    }\r\n\r\n    .context-option {\r\n        cursor: default;\r\n        padding: 0.2em 1em;\r\n    }\r\n</style>\r\n<script>\r\n        export default {\r\n            oncreate(dsds) {\r\n                this.position(this.options.position);\r\n                //this.set({ actions: this.options.actions });\r\n            },\r\n            methods: {\r\n                position(point) {\r\n                    this.set({top: point.y, left: point.x});\r\n                },\r\n                execute(event, action) {\r\n                    event.stopPropagation();\r\n                    action.action();\r\n\r\n                    this.options.onactionend();\r\n                    //close();\r\n                },\r\n                close() {\r\n                    //this.refs.yolo.remove();\r\n                    this.destroy();\r\n                },\r\n                isTarget(event) {\r\n                    return this.refs.contextMenu === event.target;\r\n                }\r\n            },\r\n            data() {\r\n                return {\r\n                    actions: [],\r\n                    top: 0,\r\n                    left: 0\r\n                }\r\n            }\r\n        };\r\n</script>",
    "<svg xmlns=\"http://www.w3.org/2000/svg\" shape-rendering=\"crispEdges\" class=\"arrow\" height=\"100%\" width=\"100%\">\r\n  <path d=\"{path}\" stroke=\"red\" fill=\"transparent\" class=\"select-area\" on:click=\"test()\"/>\r\n  \r\n  <path d=\"{arrowPath}\" \r\n  fill=\"red\"\r\n  />\r\n</svg>\r\n\r\n<style>\r\n    .arrow {\r\n        position: absolute;\r\n        left: 0px;    \r\n        pointer-events: none;\r\n    }\r\n\r\n    .select-area {\r\n        pointer-events: visible;\r\n        position: absolute;\r\n    }\r\n</style>\r\n<script>\r\n\t\t//dependency -> props: from-task, to-task\r\n        //arrow -> start x,y -> end x,y\r\n        /*M{startX} {startY} \r\n  L {startX+width/2} {startY} \r\n  L {startX+width/2} {startY+height/2}\r\n  L {startX-width/2} {startY+height/2}\r\n  L {startX-width/2} {startY+height}\r\n  L {endX} {endY}\r\n  \r\n  transform=\"translate(5,5)\"*/ \r\n\r\n\r\n  /*startX >= endX\r\n  \r\n  M{startX} {startY} \r\n  L {startX+minLen} {startY} \r\n  L {startX+minLen} {startY+height/2}\r\n  L {endX-minLen} {startY+height/2}\r\n  L {endX-minLen} {endY}\r\n  L {endX} {endY}\r\n  \r\n  */\r\n\r\n /*normal\r\n M{startX} {startY} \r\n  L {startX+width/2} {startY} \r\n  L {startX+width/2} {endY}\r\n  L {endX-5} {endY}\r\n \r\n */\r\n        export default {\r\n            oncreate() {\r\n\r\n            },\r\n            data() {\r\n                return {\r\n                    startX: 0,\r\n                    startY: 0,\r\n                    endX: 100,\r\n                    endY: 100,\r\n                    minLen: 12\r\n                }\r\n            },\r\n            methods: {\r\n                test() {\r\n                    console.log('CLICKED ARROW');\r\n                }\r\n            },\r\n            computed: {\r\n                height:   ({ endY, startY }) => (endY-startY), //Math.abs\r\n                width: ({ endX, startX }) => (endX-startX),\r\n                path: function ({startX, startY, endX, endY, minLen, width, height}) {\r\n                    let result;\r\n\r\n                    if(startX == NaN || startX == undefined) \r\n                        return 'M0 0';\r\n\r\n\r\n                    if(startX + minLen >= endX && startY != endY) {\r\n                        result = `L ${startX+minLen} ${startY} \r\n                                L ${startX+minLen} ${startY+height/2}\r\n                                L ${endX-minLen} ${startY+height/2}\r\n                                L ${endX-minLen} ${endY} `\r\n                    }\r\n                    else{\r\n                        result = `L ${startX+width/2} ${startY} \r\n                                L ${startX+width/2} ${endY}`\r\n                    }\r\n\r\n\r\n                    return `M${startX} ${startY}` + result + `L ${endX-2} ${endY}` //so it doesnt stick out of arrow head\r\n\r\n                },\r\n                arrowPath: function({endX, endY}){\r\n                    \r\n                    if(endX == NaN || endX == undefined) \r\n                        return 'M0 0';\r\n\r\n                    return `M${endX-5} ${endY-5} L${endX} ${endY} L${endX-5} ${endY+5} Z`\r\n                }\r\n            }\r\n        };\r\n</script>",
    "<div class=\"dependency-container\">\r\n    {#each visibleDependencies as dependency (dependency.id)}\r\n        <Dependency fromTask={dependency.fromTask} \r\n            toTask={dependency.toTask}\r\n            {dependency}/>\r\n    {/each}\r\n</div>\r\n\r\n<style>\r\n    .dependency-container {\r\n        position: absolute;\r\n        width: 100%;\r\n        height: 100%;\r\n        \r\n        pointer-events: none;\r\n        top: 0;\r\n        float: left;\r\n        overflow: hidden;\r\n    }\r\n</style>\r\n\r\n<script>\r\n    import Dependency from './Dependency.html';\r\n    import SvelteDependency from './dependency.js';\r\n    import { DOMUtils } from \"./domUtils.js\";\r\n\r\n    export default {\r\n        setup(component) {\r\n\r\n        },\r\n        components: { Dependency },\r\n        oncreate() {\r\n            this.fire('init', {module: this});\r\n        },\r\n        methods: {\r\n            initModule (options) {\r\n                this.set(options);\r\n                const {_gantt} = this.get();\r\n                const {dependencies, _allTasks} = _gantt.get();\r\n\r\n                for(let i=0; i < dependencies.length; i++){\r\n                    let dependency = dependencies[i];\r\n                    const fromTask = _allTasks.find(t => t.id == dependency.fromTask);\r\n                    const toTask = _allTasks.find(t => t.id == dependency.toTask);\r\n                    dependency.fromTask = fromTask;\r\n                    dependency.toTask = toTask;\r\n\r\n                    dependencies[i] = new SvelteDependency(dependency, _gantt.store.get());\r\n                }\r\n            },\r\n            updateVisible({scrollTop, viewportHeight}){\r\n                const { dependencies } = this.get()._options;\r\n\r\n                //interval tree or just debounce a bit\r\n                const visibleDependencies = [];\r\n                \r\n                const viewportTop = scrollTop;\r\n                const viewportBottom = scrollTop + viewportHeight;\r\n\r\n                for(let i = 0; i < dependencies.length; i++){\r\n                    const dependency = dependencies[i];\r\n                    let { startY, endY } = dependency;\r\n                    \r\n                    //let yMax = Math.max(startY, endY);//can be done \r\n                    //let yMin = Math.min(startY, endY);//with an if //todo research performance\r\n                    let yMax, yMin;\r\n                    if(startY > endY){\r\n                        yMax = startY;\r\n                        yMin = endY;\r\n                    }\r\n                    else{\r\n                        yMax = endY;\r\n                        yMin = startY;\r\n                    }\r\n\r\n                    if(!(yMax < viewportTop && yMin < viewportTop || yMax > viewportBottom && yMin > viewportBottom)) {\r\n                        //cant see dependency\r\n                        visibleDependencies.push(dependency);\r\n                    }\r\n                }\r\n\r\n                this.set({ visibleDependencies });\r\n            }\r\n        },\r\n        data() {\r\n            return {\r\n                _gantt: null, //gantt this\r\n                _options: {}, //gantt this.get()\r\n                visibleDependencies: []\r\n            }\r\n        }\r\n    };\r\n</script>"
  ],
  "names": [],
  "mappings": "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"
}