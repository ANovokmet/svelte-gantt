{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "..\\src\\Grid.html",
    "..\\src\\Row.html",
    "..\\src\\RowHeader.html",
    "..\\src\\Column.html",
    "..\\src\\ColumnHeader.html",
    "..\\src\\Dependency.html",
    "..\\src\\Task.html",
    "..\\src\\Arrow.html"
  ],
  "sourcesContent": [
    "<div class=\"grid\">\r\n\r\n    <div class=\"side-header-container\" style=\"height:{$headerHeight}px;width:100px\">\r\n    \r\n    </div>\r\n\r\n    <div class=\"main-header-container\" style=\"height:{$headerHeight}px\" use:horizontalScrollListener>\r\n        <div class=\"header-container\" style=\"width:{$width}px\">\r\n            {#each $headers as header}\r\n                <ColumnHeader header={header}/>\r\n            {/each}\r\n        </div>\r\n    </div>\r\n\r\n    <div class=\"side-container\" style=\"height:{$height}px\" use:scrollListener>\r\n        <div class=\"row-header-container\" style=\"padding-top:{paddingTop}px;padding-bottom:{paddingBottom}px;height:{rowContainerHeight}px;\"> \r\n            {#each visibleRows as row (row.id)}\r\n                <RowHeader \r\n                    bind:label=row.label/>\r\n            {/each}\r\n        </div>\r\n    </div>\r\n\r\n    <div class=\"main-container\" style=\"height:{$height}px\" use:scrollable ref:rowContainer>\r\n        <div class=\"content\" style=\"width:{$width}px\">\r\n            \r\n\r\n            <div class=\"column-container\">\r\n                {#each columns as column}\r\n                    <Column width={column.width}/>\r\n                {/each}\r\n            </div>    \r\n            <div class=\"row-container\" style=\"padding-top:{paddingTop}px;padding-bottom:{paddingBottom}px;height:{rowContainerHeight}px;\">\r\n                {#each visibleRows as row (row.id)}\r\n                    <Row row={row}\r\n                        width={width}\r\n                        on:updateVisibleRows=\"updateViewport()\"/>\r\n                {/each}\r\n            </div>\r\n\r\n            <div class=\"dependency-container\">\r\n                {#each visibleDependencies as dependency (dependency.id)}\r\n                    <Dependency fromTask={dependency.fromTask} \r\n                        toTask={dependency.toTask}\r\n                        {dependency}/>\r\n                {/each}\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n</div>\r\n\r\n<style>\r\n    .grid {\r\n        width: 100%;\r\n        position: relative;\r\n        font-family: tahoma, arial, verdana, Sans-serif;\r\n        font-size: 10px;\r\n        color: #656565;\r\n    }\r\n\r\n    .column-container {\r\n        position: absolute;\r\n        height: 100%;\r\n\r\n        float: left;\r\n        overflow: hidden;\r\n    }\r\n\r\n    .dependency-container {\r\n        position: absolute;\r\n        width: 100%;\r\n        height: 100%;\r\n        \r\n        pointer-events: none;\r\n        top: 0;\r\n        float: left;\r\n        overflow: hidden;\r\n    }\r\n\r\n    .row-container {\r\n        width: 100%;\r\n        /* display: inline-block; */\r\n        box-sizing: border-box;\r\n    }\r\n\r\n    .row-header-container {\r\n        \r\n        box-sizing: border-box;\r\n    }\r\n\r\n\r\n    .side-container {\r\n        width: 100px;\r\n        float: left;\r\n        overflow-y: hidden;\r\n    }\r\n\r\n    .main-container {\r\n        /* position: relative; */\r\n        overflow: auto;\r\n    }\r\n\r\n    .side-header-container {\r\n        float: left;\r\n    }\r\n\r\n    .main-header-container {\r\n        position: relative;\r\n        overflow: hidden;\r\n    }\r\n\r\n    .content {\r\n        position: relative;\r\n    }\r\n</style>\r\n\r\n<script>\r\n    import Row from './Row.html';\r\n    import RowHeader from './RowHeader.html';\r\n    import Column from './Column.html';\r\n    import ColumnHeader from './ColumnHeader.html';\r\n    import Dependency from './Dependency.html';\r\n    import { Utils } from \"./task.js\";\r\n    import { Store } from 'svelte/store.js';\r\n\r\n    import Task from \"./Task.html\";\r\n\r\n    let SvelteGantt;\r\n\r\n    export default {\r\n        setup(component){\r\n            SvelteGantt = component;\r\n            SvelteGantt.defaults = {\r\n\t\t\t\twidth: 800,\r\n\t\t\t\theight: 400,\r\n\t\t\t\tmagnetOffset: 15,\r\n\t\t\t\tmagnetUnit: 'minute',\r\n\t\t\t\theaderHeight: 100,\r\n\t\t\t\theaders: [{unit: 'day', format: 'DD.MM.YYYY'}, {unit: 'hour', format: 'HH'}],\r\n\t\t\t\trowHeight: 24\r\n            };\r\n\r\n            SvelteGantt.create = function(target, data, options) {\r\n\r\n                const store = new Store();\r\n\r\n                store.set(Object.assign(SvelteGantt.defaults, options));\r\n                store.set({ rows: data.rows });\r\n\r\n                for(let i=0; i < data.rows.length; i++){\r\n                    const row = data.rows[i];\r\n                    for(let j=0; j < row.tasks.length; j++){\r\n                        const task = row.tasks[j];\r\n                        Task.updatePosition(task, store.get());\r\n                        task.row = row;\r\n                    }\r\n                }\r\n\r\n                return new SvelteGantt({\r\n                    target,\r\n                    data,\r\n                    store\r\n                })\r\n            }\r\n        },\r\n\r\n\r\n\r\n        components: { Row, Column, RowHeader, ColumnHeader, Dependency },\r\n        oncreate(){\r\n            \r\n            const {from, to, width, magnetOffset, magnetUnit} = this.store.get();\r\n            let diva;\r\n            const columnWidth = Utils.getPositionByDate(from.clone().add(magnetOffset, magnetUnit), from, to, width);\r\n            diva = width / columnWidth\r\n            const columnCount = Math.ceil(width / columnWidth) \r\n\r\n            var columns = [];\r\n            \r\n            for(let i=0; i< columnCount; i++){\r\n                columns.push({width: columnWidth});\r\n            }\r\n\r\n            this.store.set({bodyElement: this.refs.rowContainer})\r\n\r\n            this.set({columns: columns});\r\n\r\n            for(let i=0; i< columnCount; i++){\r\n                columns.push({width: columnWidth});\r\n            }\r\n\r\n            const { rows, rowHeight } = this.store.get();\r\n            for(let i=0; i < rows.length; i++){\r\n                Task.updatePosition(rows[i].tasks[0], this.store.get());\r\n            }\r\n\r\n            const { dependencies } = this.get();\r\n            for(let i=0; i < dependencies.length; i++){\r\n                let dependency = dependencies[i];\r\n                const res = Dependency.update(dependency.fromTask, dependency.toTask, rows, rowHeight);\r\n                Object.assign(dependency, res);\r\n            }\r\n\r\n            this.updateVisibleRows(0, this.refs.rowContainer.clientHeight);\r\n            this.updateVisibleDependencies(0, this.refs.rowContainer.clientHeight);\r\n        },\r\n        actions: {\r\n            scrollable(node){\r\n                const { scrollables } = this.get();\r\n                const self = this;\r\n\r\n                function onscroll(event) {\r\n                    const scrollAmount = node.scrollTop; \r\n\r\n                    console.log(scrollAmount);\r\n                    for(let i=0; i< scrollables.length; i++){\r\n                        const scrollable = scrollables[i];\r\n                        if(scrollable.orientation === 'horizontal') {\r\n                            scrollable.node.scrollLeft = node.scrollLeft;\r\n                        }\r\n                        else {\r\n                            scrollable.node.scrollTop = scrollAmount;\r\n                        }\r\n                    }\r\n                    self.updateVisibleRows(scrollAmount, node.clientHeight);\r\n                    self.updateVisibleDependencies(scrollAmount, node.clientHeight);\r\n                }\r\n\r\n                node.addEventListener('scroll', onscroll);\r\n                return {\r\n\t\t\t\t\tdestroy() {\r\n\t\t\t\t\t\tnode.removeEventListener('scroll', onscroll, false);\r\n\t\t\t\t\t}\r\n                }\r\n            },\r\n            scrollListener(node){\r\n                const { scrollables } = this.get();\r\n                scrollables.push({node});\r\n            },\r\n            horizontalScrollListener(node){\r\n                const { scrollables } = this.get();\r\n                scrollables.push({node, orientation: 'horizontal'});\r\n            }\r\n\t\t},\r\n        methods: {\r\n            updateVisibleRows(scrollTop, viewportHeight){\r\n                console.log('update v rows');\r\n                const { rows, height, rowHeight } = this.store.get();\r\n\r\n                let startIndex = Math.floor(scrollTop / rowHeight);\r\n                let endIndex = Math.min(startIndex + Math.ceil(viewportHeight / rowHeight ), rows.length - 1);\r\n\r\n                console.log('['+startIndex+','+endIndex+']');\r\n\r\n                const paddingTop = startIndex * rowHeight;\r\n                const paddingBottom = rows.length * rowHeight - viewportHeight - paddingTop;\r\n\r\n\r\n                const visibleRows = rows.slice(startIndex, endIndex + 1);\r\n\r\n                this.set({ visibleRows: visibleRows, paddingTop: paddingTop, paddingBottom: paddingBottom });\r\n                this.store.set({ visibleRows });\r\n                //this.set({dependencies: this.get().dependencies});\r\n            },\r\n            updateViewport(){\r\n                console.log('update v port');\r\n                const {scrollTop, clientHeight} = this.refs.rowContainer;\r\n                this.updateVisibleRows(scrollTop, clientHeight);\r\n                this.updateVisibleDependencies(scrollTop, clientHeight);\r\n            },\r\n            updateVisibleDependencies(scrollTop, viewportHeight){\r\n                const { dependencies } = this.get();\r\n\r\n                //binary search\r\n                const visibleDependencies = [];\r\n                \r\n                const viewportTop = scrollTop;\r\n                const viewportBottom = scrollTop + viewportHeight;\r\n\r\n                for(let i = 0; i < dependencies.length; i++){\r\n                    const dependency = dependencies[i];\r\n                    let { startY, endY } = dependency; //init dependencies before components oncreate\r\n                    \r\n                    //let yMax = Math.max(startY, endY);//can be done \r\n                    //let yMin = Math.min(startY, endY);//with an if //todo research performance\r\n                    let yMax, yMin;\r\n                    if(startY > endY){\r\n                        yMax = startY;\r\n                        yMin = endY;\r\n                    }\r\n                    else{\r\n                        yMax = endY;\r\n                        yMin = startY;\r\n                    }\r\n\r\n                    if(yMax < viewportTop && yMin < viewportTop || yMax > viewportBottom && yMin > viewportBottom) {\r\n                        //cant see dependency\r\n                    }\r\n                    else {\r\n                        visibleDependencies.push(dependency);\r\n                    }\r\n                }\r\n\r\n                this.set({ visibleDependencies });\r\n            }\r\n        },\r\n        data() {\r\n            return {\r\n                columns: [],\r\n                scrollables: [],\r\n                visibleRows: [],\r\n                visibleDependencies: []\r\n            }\r\n        },\r\n        computed: {\r\n            rowContainerHeight: ({rows, $rowHeight}) => rows.length * $rowHeight\r\n        }\r\n    };\r\n</script>",
    "<div class=\"row\" ref:row style=\"height:{$rowHeight}px\">\r\n    {#each row.tasks as task (task.id)}\r\n        <Task   row={row}\r\n                task={task}  \r\n                on:updateVisibleRows \r\n                on:taskMoved=\"moved()\"\r\n                on:taskMovedRow=\"moved()\"\r\n                on:taskResized=\"moved()\"/>\r\n    {/each}\r\n</div>\r\n<style>\r\n    .row {\r\n        position: relative;\r\n        width: 100%;\r\n        border-bottom: #efefef 1px solid;\r\n        box-sizing: border-box;\r\n    }\r\n</style>\r\n<script>\r\n        import Task from './Task.html';\r\n    \r\n        export default {\r\n            components: { Task },\r\n            oncreate() {\r\n                const { row } = this.get();\r\n                row.rowElement = this.refs.row;\r\n\r\n\r\n                this.on('update', ({ changed, current, previous }) => {\r\n                    \r\n                    const { row } = this.get();\r\n                    row.rowElement = this.refs.row;\r\n                    row.component = this;\r\n                    console.log('update row', row.id);\r\n                });\r\n            },\r\n            methods: {\r\n                moved() {\r\n                    console.log('WAT WAT')\r\n                    const { row } = this.get();\r\n                    this.set({ row });\r\n                }\r\n            },\r\n            \r\n        };\r\n</script>",
    "<div class=\"row-header\">\r\n    {label}\r\n</div>\r\n<style>\r\n    .row-header {\r\n        position: relative;\r\n        height: 24px;\r\n\r\n        border-bottom: #efefef 1px solid;    \r\n        background-color: #fbfbfb;\r\n        font-weight: bold;\r\n        box-sizing: border-box;\r\n    }\r\n</style>\r\n<script>\r\n\r\n</script>",
    "<div class=\"column\" style=\"width:{width}px\"></div>\r\n<style>\r\n    .column {\r\n        position: relative;\r\n        display: inline-block;\r\n        height: 100%;    \r\n        border-left: #efefef 1px solid;\r\n        box-sizing: border-box;\r\n    }\r\n</style>",
    "<div class=\"column-header-row\" style=\"width:{width}px\">\r\n\r\n    {#each headers as header}\r\n        <div class=\"column-header\" style=\"width:{header.width}px\">\r\n            {header.label || 'N/A'}\r\n        </div>\r\n    {/each}\r\n</div>\r\n<style>\r\n    .column-header-row {\r\n        box-sizing: border-box;\r\n        border-top: 1px solid #ddd;\r\n        white-space: nowrap;\r\n        overflow: hidden;\r\n    }\r\n\r\n    .column-header {\r\n        position: relative;\r\n        display: inline-block;\r\n        height: 100%;    \r\n        border-left: #efefef 1px solid;\r\n        box-sizing: border-box;\r\n        text-overflow: clip;\r\n        vertical-align: top;\r\n    }\r\n</style>\r\n<script>\r\n    import moment from \"../node_modules/moment/src/moment.js\";\r\n    import { Utils } from \"./task.js\";\r\n    console.log(moment());\r\n\r\n\r\n\r\n    export default {\r\n        oncreate() {\r\n            \r\n            const { header } = this.get();\r\n\r\n            const {from, to, width } = this.store.get();\r\n            const columnWidth = Utils.getPositionByDate(from.clone().add(1, header.unit), from, to, width);\r\n            \r\n            const columnCount = Math.ceil(width / columnWidth) \r\n\r\n            var headers = [];\r\n            \r\n            \r\n\r\n            var headerTime = from.clone();\r\n\r\n            for(let i=0; i< columnCount; i++){\r\n                headers.push({width: columnWidth, label: headerTime.format(header.format)});\r\n                headerTime.add(1, header.unit);\r\n            }\r\n\r\n            this.set({headers: headers});\r\n        },\r\n        data(){\r\n            return {\r\n                headers: []\r\n            }\r\n        }\r\n    };\r\n</script>",
    "<div class=\"dependency\" style=\"left:{0}px;top:{0}px;\">\r\n    <Arrow \r\n        {startX}\r\n        {startY}\r\n        {endX}\r\n        {endY}/>\r\n</div>\r\n\r\n<style>\r\n    .dependency {\r\n\t\tposition: absolute;     \r\n        width:100%;\r\n        height: 100%;\r\n\t}\r\n</style>\r\n<script>\r\n    import Arrow from './Arrow.html';\r\n    import { Utils } from \"./task.js\";\r\n\r\n    function subscribe(dependency, task) {\r\n        if(!task.dependencies) {\r\n            task.dependencies = []\r\n        }\r\n        task.dependencies.push(dependency);\r\n    }\r\n\r\n    function unsubscribe(dependency, task) {\r\n        let res = [];\r\n        for(let i = 0; i < task.dependencies.length; i++) {\r\n            if(task.dependencies[i] === dependency) {\r\n                res.push(dependency);\r\n            }\r\n        }\r\n\r\n        for(let i = 0; i < res.length; i++) {\r\n            let index = task.dependencies.indexOf(res[i]);\r\n            task.dependencies.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    function update(fromTask, toTask, rows, rowHeight) {\r\n        let startX = fromTask.left + fromTask.width;\r\n        let endX = toTask.left;\r\n\r\n        let startIndex = rows.indexOf(fromTask.row); \r\n        let endIndex = rows.indexOf(toTask.row); \r\n\r\n        let startY = (startIndex + 0.5) * rowHeight\r\n        let endY = (endIndex + 0.5) * rowHeight\r\n\r\n        return {startX, startY, endX, endY};\r\n    }\r\n\r\n    export default {\r\n        setup(component){\r\n            component.subscribe = subscribe;\r\n            component.update = update;\r\n        },\r\n        components: { Arrow },\r\n        oncreate() {\r\n            \r\n            this.update();\r\n\r\n            this.on('update', ({ changed, current, previous }) => {\r\n                console.log('DOM updated after state change', changed);\r\n                if(previous){\r\n                    unsubscribe(this, previous.fromTask);\r\n                    unsubscribe(this, previous.toTask);\r\n                }\r\n                subscribe(this, current.fromTask);\r\n                subscribe(this, current.toTask);\r\n                this.update();\r\n            });\r\n\r\n            this.on('destroy', () => {\r\n                const { fromTask, toTask } = this.get();\r\n                unsubscribe(this, fromTask);\r\n                unsubscribe(this, toTask);\r\n            });\r\n\r\n            const { fromTask, toTask } = this.get();\r\n            subscribe(this, fromTask);\r\n            subscribe(this, toTask);\r\n        },\r\n        data() {\r\n            return {\r\n                startX: 0,\r\n                startY: 0,\r\n                endX: 100,\r\n                endY: 100\r\n            }\r\n        },/*,\r\n        computed: {\r\n\t\t\tstartX:   ({ fromTask }) => fromTask.left + fromTask.width,\r\n\t\t\tendX: ({ toTask }) => toTask.left,\r\n            startY: ({ fromTask, $rows, $rowHeight }) => ($rows.indexOf(fromTask.row) + 0.5) * $rowHeight,\r\n            endY: ({ toTask, $rows, $rowHeight }) => ($rows.indexOf(toTask.row) + 0.5) * $rowHeight\r\n        }*/\r\n        methods: {\r\n            update() {\r\n                const { rows, rowHeight } = this.store.get();\r\n                const { fromTask, toTask, dependency } = this.get();\r\n\r\n                //if(fromTask && fromTask.left && toTask.left){\r\n                    let startX = fromTask.left + fromTask.width;\r\n                    let endX = toTask.left;\r\n\r\n                    let startIndex = rows.indexOf(fromTask.row); \r\n                    let endIndex = rows.indexOf(toTask.row); \r\n\r\n                    let startY = (startIndex + 0.5) * rowHeight\r\n                    let endY = (endIndex + 0.5) * rowHeight\r\n\r\n                    if(startX == NaN || startX == undefined) \r\n                        debugger;\r\n                    this.set({startX, startY, endX, endY});\r\n                    Object.assign(dependency, {startX, startY, endX, endY});\r\n                //}\r\n            }\r\n        }\r\n    };\r\n</script>",
    "<div class=\"task\" style=\"left:{task.left}px;width:{task.width}px;\"\r\n use:drag>\r\n    {task.label}\r\n</div>\r\n\r\n<style>\r\n    .task {\r\n\t\tposition: absolute;     \r\n        top: 0;\r\n        bottom: 0;   \r\n        height: 80%;\r\n        margin: auto;\r\n        background: rgb(116, 191, 255);\r\n\t}\r\n</style>\r\n\r\n<script>\r\n    import moment from \"../node_modules/moment/src/moment.js\";\r\n    import { Utils } from \"./task.js\";\r\n\r\n    const resizeHandleWidth = 15;\r\n\r\n    let SvelteTask;\r\n\r\n    function notify(task) {\r\n        if(task.dependencies){\r\n            for(let i = 0; i < task.dependencies.length; i++){\r\n                task.dependencies[i].update();\r\n            }\r\n        }\r\n    }\r\n\r\n    function updatePosition(task, options){\r\n        if(!options.to || !task) return;\r\n\r\n        const left = Utils.getPositionByDate(task.from, options.from, options.to, options.width);\r\n        const right = Utils.getPositionByDate(task.to, options.from, options.to, options.width); \r\n\r\n        task.left = left;\r\n        task.width = right - left;\r\n    }\r\n\r\n    export default {\r\n        setup(component) {\r\n            SvelteTask = component;\r\n            SvelteTask.updatePosition = updatePosition;\r\n        },\r\n        oncreate() {\r\n            const { task, row } = this.get();\r\n            task.row = row;\r\n\r\n            this.updateTaskPosition();\r\n        },\r\n        actions: {\r\n\t\t\tdrag(node) {\r\n\r\n                //var self = this;\r\n                const bodyElement  = document.getElementsByClassName(\"row-container\");\r\n                const windowElement = window;\r\n\r\n                const { task } = this.get();\r\n                task.component = this;\r\n                //const { rows } = this.store.get();\r\n\r\n                let mouseStartPosX;\r\n                let mouseStartRight;\r\n\r\n                function onmousedown(event) {\r\n                    \r\n                    event.preventDefault();\r\n                    console.log('drag down');\r\n\r\n                    \r\n                    mouseStartPosX = Utils.getRelativePos(bodyElement[0], event).x - task.left; //Utils.getRelativePos(node, event).x; //  \r\n                    \r\n                    mouseStartRight = task.left + task.width;\r\n\r\n                    if(mouseStartPosX < resizeHandleWidth) {\r\n                        task.resizing = true;\r\n                        task.direction = 'left';\r\n                    }\r\n                    else if(mouseStartPosX > task.width - resizeHandleWidth) {\r\n                        task.resizing = true;\r\n                        task.direction = 'right';\r\n                    }\r\n                    else {\r\n                        task.dragging = true;\r\n                    }\r\n\r\n\r\n\r\n                    \r\n                    windowElement.addEventListener('mousemove', onmousemove, false);\r\n                    Utils.addEventListenerOnce(windowElement, 'mouseup', onmouseup);\r\n                }\r\n                \r\n                function onmousemove(event) {\r\n                    \r\n                    event.preventDefault();\r\n                    if(task.resizing) {\r\n\r\n                        const mousePos = Utils.getRelativePos(bodyElement[0], event);\r\n\r\n\r\n                        var x = mousePos.x// - mouseStartPosX;\r\n                        \r\n                        if(task.direction === 'left') { //resize ulijevo\r\n                            if(mousePos.x > task.left + task.width) {\r\n                                task.left = mouseStartRight; //mousePos.x //\r\n                                task.width = task.left - mousePos.x;\r\n                                task.direction = 'right'\r\n                                mouseStartRight = task.left + task.width;\r\n                            }\r\n                            else{\r\n                                task.left = x;\r\n                                task.width = mouseStartRight - x;\r\n                            }\r\n                        }\r\n                        else if(task.direction === 'right') {//resize desno\r\n                            if(mousePos.x <= task.left) {\r\n                                task.width = task.left - mousePos.x;\r\n                                task.left = mousePos.x;\r\n                                task.direction = 'left';\r\n                                mouseStartRight = task.left + task.width;\r\n                            }\r\n                            else {\r\n                                task.width = mousePos.x - task.left;\r\n                            }\r\n                        }\r\n\r\n                        console.log(mousePos.x, mouseStartPosX)\r\n\r\n                        console.log(x)\r\n\r\n                        task.component.updateTaskDate();\r\n                        task.component.updateTaskPosition();\r\n                        task.component.set({ task });\r\n                        task.component.fire('taskResized', { task: task });\r\n                    }\r\n\r\n                    if(task.dragging) {\r\n                        const mousePos = Utils.getRelativePos(bodyElement[0], event);\r\n\r\n\r\n                        var x = mousePos.x - mouseStartPosX;\r\n\r\n                        const store = task.component.store.get();\r\n                        const from = Utils.getDateByPosition(x, store.from, store.to, store.width);\r\n                        const to = Utils.getDateByPosition(x + task.width, store.from, store.to, store.width);\r\n                \r\n\r\n                        task.left = x;\r\n\r\n                        task.component.updateTaskDate();//pomaknuti na kraj funkcije\r\n                        task.component.updateTaskPosition();\r\n                        //task.component.set({ task: task }); \r\n                        \r\n                        //row switching\r\n                        const rowCenterX = bodyElement[0].getBoundingClientRect().left + bodyElement[0].getBoundingClientRect().width / 2;\r\n                        const sourceRow = task.row;\r\n                        let targetRow;\r\n\r\n                        let elements = document.elementsFromPoint(rowCenterX, event.clientY);\r\n                        let rowElement = elements.find((element) => element.classList.contains('row'));\r\n                        if(rowElement !== undefined && rowElement !== sourceRow.rowElement) {\r\n\r\n                            const rows = task.component.store.get().visibleRows;\r\n\r\n                            const targetRows = rows.filter((r) => r.rowElement === rowElement);\r\n                            console.log(\"TARGET ROWS:\", targetRows)\r\n                            const targetRow = rows.find((r) => r.rowElement === rowElement);\r\n                            console.log('move task to '+targetRow.label, targetRow);\r\n\r\n                            task.row = targetRow;\r\n                            targetRow.tasks.push(task);\r\n                            \r\n                            let i, task_;\r\n                            for (i = 0; i < sourceRow.tasks.length; i++) {\r\n                                task_ = sourceRow.tasks[i]\r\n                                if (task_ === task) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            sourceRow.tasks.splice(i, 1);\r\n                            task.component.store.set({visibleRows: rows});\r\n                            \r\n                            task.component.fire('taskMovedRow', { task: task, row: targetRow });\r\n                            targetRow.component.moved();\r\n                        }\r\n                        task.component.fire('taskMoved', { task: task });\r\n                        //task.component.fire('updateVisibleRows');\r\n                    }\r\n                    task.component.set({task:task});\r\n                    notify(task);\r\n                }\r\n\r\n                function onmouseup(event) {\r\n                    console.log('drag up'); \r\n                    task.dragging = false;\r\n                    task.resizing = false;\r\n                    windowElement.removeEventListener('mousemove', onmousemove, false);\r\n                }\r\n\r\n                node.addEventListener('mousedown', onmousedown, false);\r\n                \r\n                //bind mousemove on body, only on move\r\n                //node.addEventListener('mousemove', onmousemove, false);\r\n                \r\n                //bind on body, only on down\r\n                //node.addEventListener('mouseup', onmouseup, false);\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\tupdate() {\r\n                        \r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tdestroy() {\r\n\t\t\t\t\t\tnode.removeEventListener('mousedown', onmousedown, false);\r\n\t\t\t\t\t\tnode.removeEventListener('mousemove', onmousemove, false);\r\n\t\t\t\t\t\tnode.removeEventListener('mouseup', onmouseup, false);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n        methods: {\r\n\t\t\tupdateTaskPosition() {\r\n                const store = this.store.get();\r\n                const { task } = this.get();\r\n            \r\n                //console.log(task.from.format('DD-MM-YYYY HH:mm:ss:SSS'), task.to.format('DD-MM-YYYY HH:mm:ss:SSS'));\r\n                updatePosition(task, store);\r\n\r\n\r\n                //console.log(task.left, task.width);\r\n                //this.set({ task: task });\r\n            },\r\n            updateTaskDate() {\r\n                const store = this.store.get();\r\n                const { task } = this.get();\r\n                \r\n                if(task) {\r\n                    const from = Utils.getDateByPosition(task.left, store.from, store.to, store.width);\r\n                    const to = Utils.getDateByPosition(task.left + task.width, store.from, store.to, store.width);\r\n                    \r\n\r\n                    task.from = this.magnetDate(from);\r\n                    task.to = this.magnetDate(to);\r\n\r\n                    //console.log(from.format('DD-MM-YYYY HH:mm'), to.format('DD-MM-YYYY HH:mm'));\r\n                            \r\n                    //this.set({ task: task });\r\n                }\r\n                \r\n            },\r\n            magnetDate(date) {\r\n                const { magnetUnit, magnetOffset } = this.store.get();\r\n                return Utils.roundTo(date, magnetUnit, magnetOffset);\r\n            }\r\n        },\r\n\r\n        data() {\r\n            return {\r\n                task: { dragging: false }\r\n            }\r\n        }\r\n    };\r\n</script>",
    "<svg xmlns=\"http://www.w3.org/2000/svg\" shape-rendering=\"crispEdges\" class=\"arrow\" height=\"100%\" width=\"100%\">\r\n  <path d=\"{path}\" stroke=\"red\" fill=\"transparent\" />\r\n  \r\n  <path d=\"{arrowPath}\" \r\n  fill=\"red\"\r\n  />\r\n</svg>\r\n\r\n<style>\r\n    .arrow {\r\n        position: absolute;\r\n        left: 0px;    \r\n        pointer-events: none;\r\n    }\r\n</style>\r\n<script>\r\n\t\t//dependency -> props: from-task, to-task\r\n        //arrow -> start x,y -> end x,y\r\n        /*M{startX} {startY} \r\n  L {startX+width/2} {startY} \r\n  L {startX+width/2} {startY+height/2}\r\n  L {startX-width/2} {startY+height/2}\r\n  L {startX-width/2} {startY+height}\r\n  L {endX} {endY}\r\n  \r\n  transform=\"translate(5,5)\"*/ \r\n\r\n\r\n  /*startX >= endX\r\n  \r\n  M{startX} {startY} \r\n  L {startX+minLen} {startY} \r\n  L {startX+minLen} {startY+height/2}\r\n  L {endX-minLen} {startY+height/2}\r\n  L {endX-minLen} {endY}\r\n  L {endX} {endY}\r\n  \r\n  */\r\n\r\n /*normal\r\n M{startX} {startY} \r\n  L {startX+width/2} {startY} \r\n  L {startX+width/2} {endY}\r\n  L {endX-5} {endY}\r\n \r\n */\r\n        export default {\r\n            oncreate() {\r\n\r\n            },\r\n            data() {\r\n                return {\r\n                    startX: 0,\r\n                    startY: 0,\r\n                    endX: 100,\r\n                    endY: 100,\r\n                    minLen: 12\r\n                }\r\n            },\r\n            computed: {\r\n                height:   ({ endY, startY }) => (endY-startY), //Math.abs\r\n                width: ({ endX, startX }) => (endX-startX),\r\n                path: function ({startX, startY, endX, endY, minLen, width, height}) {\r\n                    let result;\r\n\r\n                    if(startX == NaN || startX == undefined) \r\n                        return 'M0 0';\r\n\r\n\r\n                    if(startX + minLen >= endX && startY != endY) {\r\n                        result = `L ${startX+minLen} ${startY} \r\n                                L ${startX+minLen} ${startY+height/2}\r\n                                L ${endX-minLen} ${startY+height/2}\r\n                                L ${endX-minLen} ${endY} `\r\n                    }\r\n                    else{\r\n                        result = `L ${startX+width/2} ${startY} \r\n                                L ${startX+width/2} ${endY}`\r\n                    }\r\n\r\n\r\n                    return `M${startX} ${startY}` + result + `L ${endX-2} ${endY}` //so it doesnt stick out of arrow head\r\n\r\n                },\r\n                arrowPath: function({endX, endY}){\r\n                    \r\n                    if(endX == NaN || endX == undefined) \r\n                        return 'M0 0';\r\n\r\n                    return `M${endX-5} ${endY-5} L${endX} ${endY} L${endX-5} ${endY+5} Z`\r\n                }\r\n            }\r\n        };\r\n</script>"
  ],
  "names": [],
  "mappings": "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"
}