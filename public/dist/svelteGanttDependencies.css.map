{
  "version": 3,
  "file": "svelteGanttDependencies.css",
  "sources": [
    "..\\..\\src\\modules\\dependencies\\GanttDependencies.html",
    "..\\..\\src\\modules\\dependencies\\Dependency.html",
    "..\\..\\src\\modules\\dependencies\\Arrow.html"
  ],
  "sourcesContent": [
    "<div class=\"dependency-container\">\r\n    {#each visibleDependencies as dependency (dependency.model.id)}\r\n        <Dependency {dependency}/>\r\n\r\n            <!-- //\r\n        fromTask={dependency.fromTask} \r\n            toTask={dependency.toTask} -->\r\n    {/each}\r\n</div>\r\n\r\n<style>\r\n    .dependency-container {\r\n        position: absolute;\r\n        width: 100%;\r\n        height: 100%;\r\n        \r\n        pointer-events: none;\r\n        top: 0;\r\n        float: left;\r\n        overflow: hidden;\r\n    }\r\n</style>\r\n\r\n<script>\r\n    import Dependency from './Dependency.html';\r\n    import SvelteDependency from './dependency.js';\r\n\r\n    export default {\r\n        setup(component) {\r\n            component.bindToGantt = function (params) {\r\n                params.ganttBodyModules.push(component);\r\n            }\r\n        },\r\n        components: { Dependency },\r\n        oncreate() {\r\n            this.fire('init', {module: this});\r\n        },\r\n        methods: {\r\n            initModule (options) {\r\n                this.set(options);\r\n                const {_gantt} = this.get();\r\n                /*const {dependencies, _allTasks} = _gantt.get();\r\n\r\n                for(let i=0; i < dependencies.length; i++){\r\n                    let dependency = dependencies[i];\r\n                    const fromTask = _allTasks.find(t => t.id == dependency.fromTask);\r\n                    const toTask = _allTasks.find(t => t.id == dependency.toTask);\r\n                    dependency.fromTask = fromTask;\r\n                    dependency.toTask = toTask;\r\n\r\n                    dependencies[i] = new SvelteDependency(dependency, _gantt.store.get());\r\n                }*/\r\n            },\r\n            onGanttCreated() {\r\n                const {_gantt} = this.get();\r\n                const {dependencies, _allTasks, _taskCache} = _gantt.get();\r\n\r\n                /*for(let i=0; i < dependencies.length; i++){\r\n                    let dependency = dependencies[i];\r\n                    const fromTask = _taskCache[dependency.fromTask]; //_allTasks.find(t => t.id == dependency.fromTask);\r\n                    const toTask = _taskCache[dependency.toTask];//_allTasks.find(t => t.id == dependency.toTask);\r\n                    dependency.fromTask = fromTask;\r\n                    dependency.toTask = toTask;\r\n\r\n                    dependencies[i] = new SvelteDependency(_gantt, dependency);\r\n                }*/\r\n\r\n                //this.updateVisible({scrollAmount:0, viewportHeight:400});\r\n                //this.set({visibleDependencies});\r\n            },\r\n            initData(data){\r\n                const {_gantt, visibleDependencies} = this.get();\r\n\r\n                const dependencies = [];\r\n                //this.set({dependencies: [], visibleDependencies: []});\r\n                for(let i=0; i < data.dependencies.length; i++){\r\n                    const dependency = data.dependencies[i];\r\n                    dependencies.push(new SvelteDependency(_gantt, dependency));\r\n                }\r\n                this.set({dependencies});\r\n            },\r\n            updateVisible({scrollAmount, viewportHeight}){\r\n                const { dependencies } = this.get()//._options;\r\n\r\n                //interval tree or just debounce a bit\r\n                const visibleDependencies = [];\r\n                \r\n                const viewportTop = scrollAmount;\r\n                const viewportBottom = scrollAmount + viewportHeight;\r\n\r\n                for(let i = 0; i < dependencies.length; i++){\r\n                    const dependency = dependencies[i];\r\n                    let { startY, endY } = dependency;\r\n                    \r\n                    //let yMax = Math.max(startY, endY);//can be done \r\n                    //let yMin = Math.min(startY, endY);//with an if //todo research performance\r\n                    let yMax, yMin;\r\n                    if(startY > endY){\r\n                        yMax = startY;\r\n                        yMin = endY;\r\n                    }\r\n                    else{\r\n                        yMax = endY;\r\n                        yMin = startY;\r\n                    }\r\n\r\n                    if(!(yMax < viewportTop && yMin < viewportTop || yMax > viewportBottom && yMin > viewportBottom)) {\r\n                        //cant see dependency\r\n                        visibleDependencies.push(dependency);\r\n                    }\r\n                }\r\n\r\n                this.set({ visibleDependencies });\r\n            },\r\n            updateView({from, to, headers}){\r\n                const { dependencies } = this.get();\r\n                dependencies.forEach(dependency => {\r\n                    dependency.update();\r\n                });\r\n                this.set({ visibleDependencies: this.get().visibleDependencies });\r\n            }\r\n        },\r\n        data() {\r\n            return {\r\n                _gantt: null, //gantt this\r\n                _options: {}, //gantt this.get()\r\n                visibleDependencies: [],\r\n                dependencies: []\r\n            }\r\n        }\r\n    };\r\n</script>",
    "<div class=\"dependency\" style=\"left:{0}px;top:{0}px;\">\r\n    <Arrow \r\n        startX={dependency.startX}\r\n        startY={dependency.startY}\r\n        endX={dependency.endX}\r\n        endY={dependency.endY}/>\r\n</div>\r\n\r\n<style>\r\n    .dependency {\r\n\t\tposition: absolute;     \r\n        width:100%;\r\n        height: 100%;\r\n\t}\r\n</style>\r\n<script>\r\n    import Arrow from './Arrow.html';\r\n\r\n    export default {\r\n        components: { Arrow },\r\n        oncreate() { \r\n            const a = this.get().dependency\r\n            const { fromTask, toTask } = this.get().dependency;\r\n            fromTask.subscribe(this);\r\n            toTask.subscribe(this);\r\n        },\r\n        onupdate({ changed, current, previous }){\r\n            if(changed.dependency && previous && current.dependency !== previous.dependency){\r\n                previous.dependency.fromTask.unsubscribe(this);\r\n                previous.dependency.toTask.unsubscribe(this);\r\n\r\n                current.dependency.fromTask.subscribe(this);\r\n                current.dependency.toTask.subscribe(this);\r\n            }\r\n        },\r\n        ondestroy() {\r\n            const { fromTask, toTask } = this.get().dependency;\r\n            fromTask.unsubscribe(this);\r\n            toTask.unsubscribe(this);\r\n        },\r\n        data() {\r\n            return {}\r\n        },\r\n        methods: {\r\n            update() {\r\n                const { dependency } = this.get();\r\n                const result = dependency.update();\r\n                //this.set(result);\r\n                this.set({ dependency });\r\n            }\r\n        }\r\n    };\r\n</script>",
    "<svg xmlns=\"http://www.w3.org/2000/svg\" shape-rendering=\"crispEdges\" class=\"arrow\" height=\"100%\" width=\"100%\">\r\n  <path d=\"{path}\" stroke=\"red\" fill=\"transparent\" class=\"select-area\" on:click=\"test()\"/>\r\n  \r\n  <path d=\"{arrowPath}\" \r\n  fill=\"red\"\r\n  />\r\n</svg>\r\n\r\n<style>\r\n    .arrow {\r\n        position: absolute;\r\n        left: 0px;    \r\n        pointer-events: none;\r\n    }\r\n\r\n    .select-area {\r\n        pointer-events: visible;\r\n        position: absolute;\r\n    }\r\n</style>\r\n<script>\r\n\t\t//dependency -> props: from-task, to-task\r\n        //arrow -> start x,y -> end x,y\r\n        /*M{startX} {startY} \r\n  L {startX+width/2} {startY} \r\n  L {startX+width/2} {startY+height/2}\r\n  L {startX-width/2} {startY+height/2}\r\n  L {startX-width/2} {startY+height}\r\n  L {endX} {endY}\r\n  \r\n  transform=\"translate(5,5)\"*/ \r\n\r\n\r\n  /*startX >= endX\r\n  \r\n  M{startX} {startY} \r\n  L {startX+minLen} {startY} \r\n  L {startX+minLen} {startY+height/2}\r\n  L {endX-minLen} {startY+height/2}\r\n  L {endX-minLen} {endY}\r\n  L {endX} {endY}\r\n  \r\n  */\r\n\r\n /*normal\r\n M{startX} {startY} \r\n  L {startX+width/2} {startY} \r\n  L {startX+width/2} {endY}\r\n  L {endX-5} {endY}\r\n \r\n */\r\n        export default {\r\n            oncreate() {\r\n\r\n            },\r\n            data() {\r\n                return {\r\n                    startX: 0,\r\n                    startY: 0,\r\n                    endX: 100,\r\n                    endY: 100,\r\n                    minLen: 12\r\n                }\r\n            },\r\n            methods: {\r\n                test() {\r\n                    console.log('CLICKED ARROW');\r\n                }\r\n            },\r\n            computed: {\r\n                height:   ({ endY, startY }) => (endY-startY), //Math.abs\r\n                width: ({ endX, startX }) => (endX-startX),\r\n                path: function ({startX, startY, endX, endY, minLen, width, height}) {\r\n                    let result;\r\n\r\n                    if(startX == NaN || startX == undefined) \r\n                        return 'M0 0';\r\n\r\n\r\n                    if(startX + minLen >= endX && startY != endY) {\r\n                        result = `L ${startX+minLen} ${startY} \r\n                                L ${startX+minLen} ${startY+height/2}\r\n                                L ${endX-minLen} ${startY+height/2}\r\n                                L ${endX-minLen} ${endY} `\r\n                    }\r\n                    else{\r\n                        result = `L ${startX+width/2} ${startY} \r\n                                L ${startX+width/2} ${endY}`\r\n                    }\r\n\r\n\r\n                    return `M${startX} ${startY}` + result + `L ${endX-2} ${endY}` //so it doesnt stick out of arrow head\r\n\r\n                },\r\n                arrowPath: function({endX, endY}){\r\n                    \r\n                    if(endX == NaN || endX == undefined) \r\n                        return 'M0 0';\r\n\r\n                    return `M${endX-5} ${endY-5} L${endX} ${endY} L${endX-5} ${endY+5} Z`\r\n                }\r\n            }\r\n        };\r\n</script>"
  ],
  "names": [],
  "mappings": "AAWI,qBAAqB,cAAC,CAAC,AACnB,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CAEZ,cAAc,CAAE,IAAI,CACpB,GAAG,CAAE,CAAC,CACN,KAAK,CAAE,IAAI,CACX,QAAQ,CAAE,MAAM,AACpB,CAAC;ACXD,WAAW,eAAC,CAAC,AACf,QAAQ,CAAE,QAAQ,CACZ,MAAM,IAAI,CACV,MAAM,CAAE,IAAI,AACnB,CAAC;ACJE,MAAM,cAAC,CAAC,AACJ,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,GAAG,CACT,cAAc,CAAE,IAAI,AACxB,CAAC,AAED,YAAY,cAAC,CAAC,AACV,cAAc,CAAE,OAAO,CACvB,QAAQ,CAAE,QAAQ,AACtB,CAAC"
}