{
  "version": 3,
  "file": "svelteGantt.css",
  "sources": [
    "..\\..\\src\\Gantt.html",
    "..\\..\\src\\Row.html",
    "..\\..\\src\\Task.html",
    "..\\..\\src\\Column.html",
    "..\\..\\src\\ColumnHeader.html",
    "..\\..\\src\\TimeRange.html",
    "..\\..\\src\\TimeRangeHeader.html"
  ],
  "sourcesContent": [
    "<div class=\"gantt {$classes}\" ref:ganttElement>\r\n    {#each _ganttTableModules as module (module.key)}\r\n        <svelte:component this={module} {rowContainerHeight} {paddingTop} {paddingBottom} on:init=\"initModule(event.module)\" {visibleRows}/>\r\n    {/each}\r\n\r\n    <div class=\"main-header-container\" ref:sideContainer>\r\n        <div class=\"header-intermezzo\" style=\"width:{$headerWidth}px;\" use:horizontalScrollListener >\r\n            <div class=\"header-container\" style=\"width:{$width}px\">\r\n                {#each $headers as header}\r\n                    <ColumnHeader header={header}/>\r\n                {/each}\r\n                {#each $_timeRanges as timeRange (timeRange.id)}\r\n                    <TimeRangeHeader timeRange={timeRange}/>\r\n                {/each}\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <div class=\"main-container\" style=\"height:{$height}px\" use:scrollable ref:mainContainer>\r\n        <div class=\"content\" style=\"width:{$width}px\">\r\n            <div class=\"column-container\">\r\n                {#each columns as column}\r\n                    <Column {...column}/>\r\n                {/each}\r\n            </div>\r\n            <div class=\"row-container\" \r\n                ref:rowContainer style=\"height:{rowContainerHeight}px;\">\r\n                <!--padding-bottom:{paddingBottom}px;padding-top:{paddingTop}px; -->\r\n                <div style=\"transform: translateY({paddingTop}px);\">\r\n                {#each visibleRows as row (row.model.id)}\r\n                    <Row row={row}\r\n                        on:updateVisibleRows=\"updateViewport()\"/>\r\n                {/each}\r\n                </div>\r\n            </div>\r\n                <div class=\"s-g-foreground\">\r\n                    {#each $_timeRanges as timeRange (timeRange.id)}\r\n                        <TimeRange timeRange={timeRange}/>\r\n                    {/each}\r\n\r\n                    {#each visibleTasks as task (task.model.id)}\r\n                        <TaskComponent model=\"{task.model}\" \r\n                            bind:left=\"task.left\" \r\n                            bind:width=\"task.width\"\r\n                            bind:height=\"task.height\"\r\n                            bind:widthT=\"task.widthT\"\r\n                            bind:posX=\"task.posX\"\r\n                            bind:posY=\"task.posY\"/>\r\n                    {/each}\r\n                </div>\r\n            {#each _ganttBodyModules as module (module.key)}\r\n                <svelte:component this={module} on:init=\"initModule(event.module)\" />\r\n            {/each}\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<style>\r\n    .gantt {\r\n        width: 100%;\r\n        height: 100%;\r\n        position: relative;\r\n    }\r\n\r\n    .s-g-foreground {\r\n        box-sizing: border-box;\r\n        overflow: hidden;\r\n        top: 0;\r\n        left: 0;\r\n        position: absolute;\r\n        width: 100%;\r\n        height: 100%;\r\n    }\r\n\r\n    .column-container {\r\n        position: absolute;\r\n        height: 100%;\r\n        width: 100%;\r\n        float: left;\r\n        overflow: hidden;\r\n    }\r\n\r\n    .row-container {\r\n        width: 100%;\r\n        /* display: inline-block; */\r\n        box-sizing: border-box;\r\n        overflow: hidden;\r\n    }\r\n\r\n    .main-container {\r\n        /* position: relative; */\r\n        overflow: auto;\r\n    }\r\n\r\n    .main-header-container {\r\n        position: relative;\r\n        overflow: hidden;\r\n    }\r\n\r\n    .header-intermezzo {\r\n        overflow:hidden;\r\n    }\r\n\r\n    .content {\r\n        position: relative;\r\n    }\r\n\r\n    :global(*) {\r\n        box-sizing: border-box;\r\n    }\r\n</style>\r\n\r\n<script>\r\n    import Row from './Row.html';\r\n    import TaskComponent from './Task.html';\r\n    import Column from './Column.html';\r\n    import ColumnHeader from './ColumnHeader.html';\r\n    import { Store } from 'svelte/store.js';\r\n    import SelectionManager from './utils/selectionManager';\r\n    import GanttUtils from './utils/utils';\r\n    import GanttApi from './core/api';\r\n    import TimeRange from './TimeRange.html';\r\n    import TimeRangeHeader from './TimeRangeHeader.html';\r\n\r\n    import Task from \"./Task.html\";\r\n    import { SvelteTask } from \"./core/task\";\r\n    import { SvelteRow } from \"./core/row\";\r\n    import { SvelteTimeRange } from \"./core/timeRange\";\r\n\r\n    //import GanttDependencies from './modules/dependencies/GanttDependencies.html';\r\n    //import Table from './modules/table/Table.html';\r\n    import { GanttStore } from \"./store\";\r\n\r\n    window.test = new GanttStore();\r\n\r\n    let SvelteGantt;\r\n\r\n    export default {\r\n        setup(component){\r\n            SvelteGantt = component;\r\n            SvelteGantt.defaults = {\r\n                // datetime timeline starts on, currently moment-js object\r\n                from: null,\r\n                // datetime timeline ends on, currently moment-js object\r\n                to: null,\r\n                // width of main gantt area in px\r\n                width: 800, //rename to timelinewidth\r\n                // should timeline stretch width to fit, true overrides timelineWidth\r\n                stretchTimelineWidthToFit: false,\r\n                // height of main gantt area in px\r\n                height: 400,\r\n                // minimum unit of time task date values will round to \r\n                magnetUnit: 'minute',\r\n                // amount of units task date values will round to\r\n                magnetOffset: 15,\r\n                // duration unit of columns\r\n                columnUnit: 'minute',\r\n                // duration width of column\r\n                columnOffset: 15,\r\n                // list of headers used for main gantt area\r\n                // unit: time unit used, e.g. day will create a cell in the header for each day in the timeline\r\n                // format: datetime format used for header cell label\r\n                headers: [{unit: 'day', format: 'DD.MM.YYYY'}, {unit: 'hour', format: 'HH'}],\r\n                // height of a single row in px\r\n                rowHeight: 52,\r\n                // modules used in gantt\r\n                modules: [],\r\n                // enables right click context menu\r\n                enableContextMenu: false,\r\n                // sets top level gantt class which can be used for styling\r\n                classes: '',\r\n                // width of handle for resizing task\r\n                resizeHandleWidth: 10,\r\n                // handler of button clicks\r\n                onTaskButtonClick: null, // e.g. (task) => {debugger},\r\n                // task content factory function\r\n                taskContent: null, // e.g. (task) => '<div>Custom task content</div>'\r\n\r\n                rows: [],\r\n                tasks: [],\r\n                _timeRanges: []\r\n            };\r\n\r\n            SvelteGantt.create = function(target, data, options) {\r\n\r\n                // bind gantt modules\r\n                const ganttModules = {\r\n                    ganttBodyModules: [],\r\n                    ganttTableModules: [],\r\n                    defaults: {}\r\n                }\r\n\r\n                if(options.modules) {\r\n                    options.modules.forEach((module) => {\r\n                        module.bindToGantt(ganttModules);\r\n                    })\r\n                }\r\n\r\n                // initialize gantt state\r\n                const newData = {\r\n                    initialRows: data.rows,\r\n                    initialTasks: data.tasks,\r\n                    initialDependencies: data.dependencies,\r\n                    _ganttBodyModules: ganttModules.ganttBodyModules,\r\n                    _ganttTableModules: ganttModules.ganttTableModules\r\n                };\r\n\r\n                // initialize all the gantt options\r\n                const ganttOptions = Object.assign({}, SvelteGantt.defaults, ganttModules.defaults, options);\r\n                \r\n                const store = new Store(ganttOptions);\r\n\r\n                // store.compute(\r\n                //     'paddingTop',\r\n                //     ['startIndex', 'rowHeight'],\r\n                //     (startIndex, rowHeight) => startIndex * rowHeight\r\n                // );\r\n\r\n                // store.compute(\r\n                //     'paddingBottom',\r\n                //     ['rows', 'endIndex', 'rowHeight'],\r\n                //     (rows, endIndex, rowHeight) => (rows.length - endIndex - 1) * rowHeight\r\n                // );\r\n\r\n                // store.compute(\r\n                //     'startIndex',\r\n                //     ['scrollTop', 'rowHeight'],\r\n                //     (scrollTop, rowHeight) => Math.floor(scrollTop / rowHeight)\r\n                // );\r\n                \r\n                // store.compute(\r\n                //     'endIndex',\r\n                //     ['startIndex', 'viewportHeight', 'rowHeight', 'rows'],\r\n                //     (startIndex, viewportHeight, rowHeight, rows) => Math.min(startIndex + Math.ceil(viewportHeight / rowHeight ), rows.length - 1)\r\n                // );\r\n\r\n                return new SvelteGantt({\r\n                    target,\r\n                    data: newData,\r\n                    store\r\n                });\r\n            }\r\n        },\r\n        components: { Row, Column, ColumnHeader, TaskComponent, TimeRange, TimeRangeHeader },\r\n        oncreate(){\r\n            const {rows, initialRows, initialTasks, initialDependencies} = this.get();\r\n\r\n            this.initGantt();\r\n            \r\n            this.initRows(initialRows);\r\n            window.addEventListener('resize', this.onWindowResizeEventHandler.bind(this)); // or this.onW... .bind(this);\r\n            this.recalculateGanttDimensions();\r\n            this.initColumns();\r\n\r\n            this.initTasks(initialTasks);\r\n            \r\n            this.broadcastModules('onGanttCreated');\r\n            this.updateViewport();\r\n        },\r\n        ondestroy(){\r\n            //remove event listener\r\n            window.removeEventListener('resize', this.onWindowResizeEventHandler)\r\n        },\r\n        actions: {\r\n            scrollable(node){\r\n                const { scrollables } = this.get();\r\n                const self = this;\r\n\r\n                function onscroll(event) {\r\n                    const scrollAmount = node.scrollTop; \r\n                    for(let i=0; i< scrollables.length; i++){\r\n                        const scrollable = scrollables[i];\r\n                        if(scrollable.orientation === 'horizontal') {\r\n                            scrollable.node.scrollLeft = node.scrollLeft;\r\n                        }\r\n                        else {\r\n                            scrollable.node.scrollTop = scrollAmount;\r\n                        }\r\n                    }\r\n                    //TODO: only for vertical scroll\r\n                    self.set({scrollTop: scrollAmount, clientHeight: node.clientHeight});\r\n                    self.store.set({scrollTop: scrollAmount, clientHeight: node.clientHeight});\r\n                    self.updateVisibleRows();\r\n\r\n                    self.broadcastModules('updateVisible', {scrollAmount, viewportHeight: node.clientHeight});\r\n                }\r\n\r\n                node.addEventListener('scroll', onscroll);\r\n                return {\r\n\t\t\t\t\tdestroy() {\r\n\t\t\t\t\t\tnode.removeEventListener('scroll', onscroll, false);\r\n\t\t\t\t\t}\r\n                }\r\n            },\r\n            horizontalScrollListener(node){\r\n                const { scrollables } = this.get();\r\n                scrollables.push({node, orientation: 'horizontal'});\r\n            }\r\n\t\t},\r\n        methods: {\r\n            onWindowResizeEventHandler(event){\r\n                this.recalculateGanttDimensions();\r\n                if(this.store.get().stretchTimelineWidthToFit){\r\n                    this.initColumns();\r\n                    this.refreshTasks();\r\n                }\r\n            },\r\n            recalculateGanttDimensions() {\r\n                const parentWidth = this.refs.ganttElement.clientWidth;\r\n                const parentHeight = this.refs.ganttElement.clientHeight;\r\n                \r\n                this.store.set({parentWidth});\r\n                \r\n                const tableWidth = this.store.get().tableWidth || 0;\r\n\r\n                const height = parentHeight - this.refs.sideContainer.clientHeight;\r\n\r\n                // -17 only if side scrollbar shows (rowContainerHeight > height)\r\n                const { rowContainerHeight } = this.get();\r\n                const headerWidth = rowContainerHeight > height ? parentWidth - tableWidth - 17 :  parentWidth - tableWidth;\r\n\r\n                this.store.set({\r\n                    height, headerWidth\r\n                });\r\n\r\n                if(this.store.get().stretchTimelineWidthToFit){\r\n                    this.store.set({width: headerWidth});\r\n                }\r\n            },\r\n            initRows(rowsData){\r\n                const rows = [];\r\n                const _rowCache = {};\r\n                let y = 0;\r\n                for(let i=0; i < rowsData.length; i++){\r\n                    const currentRow = rowsData[i];\r\n                    const row = new SvelteRow(this, currentRow);\r\n                    rows.push(row);\r\n                    _rowCache[row.model.id] = row;\r\n                    row.posY = y;\r\n                    y += row.height;\r\n                }\r\n                this.set({\r\n                    _rowCache,\r\n                    rows\r\n                });\r\n                this.store.set({rows});\r\n            },\r\n            initTimeRanges(timeRangeData){\r\n                const _timeRanges = [];\r\n                const _timeRangeCache = [];\r\n\r\n                for(let i = 0; i < timeRangeData.length; i++){\r\n                    const currentTimeRange = timeRangeData[i];\r\n                    const timeRange = new SvelteTimeRange(this, currentTimeRange);\r\n                    _timeRanges.push(timeRange);\r\n                    _timeRangeCache[currentTimeRange.id] = timeRange;\r\n                }\r\n\r\n                this.store.set({_timeRanges, _timeRangeCache})\r\n            },\r\n            initTasks(taskData){\r\n                const _allTasks = [];\r\n                const tasks = _allTasks;\r\n                const _taskCache = {};\r\n\r\n                for(let i=0; i < taskData.length; i++){\r\n                    const currentTask = taskData[i];\r\n                    const task = new SvelteTask(this, currentTask);\r\n                    _allTasks.push(task);\r\n                    _taskCache[task.model.id] = task;\r\n                }\r\n\r\n                this.set({\r\n                    _allTasks,\r\n                    _taskCache,\r\n                    tasks,\r\n                });\r\n                this.store.set({tasks, _taskCache});\r\n                this.selectionManager.clearSelection();\r\n            },\r\n            initGantt(){\r\n                if(!this.store.get().gantt){\r\n                    this.store.set({\r\n                        bodyElement: this.refs.mainContainer, \r\n                        rowContainerElement: this.refs.rowContainer,\r\n                        gantt: this\r\n                    });\r\n                    \r\n                    this.selectionManager = new SelectionManager(this.store);\r\n                    this.utils = new GanttUtils(this);\r\n                    this.api = new GanttApi(this);\r\n\r\n                    this.api.registerEvent('tasks', 'move');\r\n                    this.api.registerEvent('tasks', 'select');\r\n                    this.api.registerEvent('tasks', 'switchRow');\r\n                    this.api.registerEvent('tasks', 'moveEnd');\r\n                    this.api.registerEvent('tasks', 'changed');\r\n\r\n                    this.row = SvelteRow;\r\n                    this.task = SvelteTask;\r\n                }\r\n            },\r\n            initModule(module){\r\n                const moduleOptions = Object.assign({\r\n                    _gantt: this,\r\n                    _options: this.get()\r\n                }, {});//merge with module specific data, modules[module.constructor.key]);\r\n                module.initModule(moduleOptions);\r\n                \r\n                const {_modules} = this.get();\r\n                _modules.push(module);\r\n            },\r\n            broadcastModules(event, data) {\r\n                const {_modules} = this.get();\r\n                _modules.forEach((module) => {\r\n                    if (typeof module[event] === 'function') {\r\n                        module[event](data);\r\n                    }\r\n                });\r\n            },\r\n            updateVisibleRows(){\r\n                // const { scrollTop, viewportHeight } = this.get();\r\n                // const { rows, rowHeight } = this.store.get();\r\n\r\n\r\n\r\n                // const visibleRows = rows.slice(startIndex, endIndex + 1);\r\n\r\n                // const visibleTasks = []\r\n                // if(this.includeInRender || visibleTasks.indexOf(this.includeInRender) !== -1){\r\n                //     visibleTasks.push(this.includeInRender);\r\n                // }\r\n\r\n                // this.set({ visibleRows, paddingTop, paddingBottom, visibleTasks });\r\n                // this.store.set({ visibleRows, paddingTop, paddingBottom, visibleTasks });\r\n            },\r\n            updateVisibleEntities(){\r\n                const { _timeRanges } = this.store.get();\r\n                _timeRanges.forEach(timeRange => {\r\n                    timeRange.updatePosition();\r\n                    timeRange.updateView();\r\n                });\r\n            },\r\n            updateViewport(){\r\n                const {scrollTop, clientHeight} = this.refs.mainContainer;\r\n                this.store.set({scrollTop, viewportHeight: clientHeight});\r\n                this.set({scrollTop, viewportHeight: clientHeight});\r\n                this.updateVisibleRows();\r\n                this.broadcastModules('updateVisible', {scrollAmount: scrollTop, viewportHeight: clientHeight});\r\n            },\r\n            initColumns() {\r\n                const {columnOffset, columnUnit, from, width, headers} = this.store.get();\r\n                const columnWidth = this.utils.getPositionByDate(from.clone().add(columnOffset, columnUnit));\r\n                const columnCount = Math.ceil((width) / columnWidth) \r\n\r\n                const columns = [];\r\n                const columnFrom = from.clone();\r\n                for(let i = 0; i < columnCount; i++){\r\n                    columns.push({width: columnWidth, from: columnFrom.clone(), left: this.utils.getPositionByDate(columnFrom)});\r\n                    columnFrom.add(columnOffset, columnUnit);\r\n                }\r\n                \r\n                this.set({ columns });\r\n                this.store.set({ headers });\r\n            },\r\n            refreshTasks(){\r\n                const { _allTasks } = this.get();\r\n                _allTasks.forEach(task => {\r\n                    task.updatePosition();\r\n                    task.updateView();\r\n                });\r\n                this.updateVisibleEntities();\r\n            },\r\n            updateView(options){ // {from, to, headers, width}\r\n                this.store.set(options);\r\n                if(this.store.get().stretchTimelineWidthToFit){\r\n                    this.recalculateGanttDimensions();\r\n                }\r\n                else{\r\n                    this.initColumns();\r\n                }\r\n\r\n                this.refreshTasks();\r\n\r\n                this.broadcastModules('updateView', options);//{ from, to, headers });\r\n            },\r\n            selectTask(id) {\r\n                const { _taskCache } = this.get();\r\n                const task = _taskCache[id];\r\n                if(task) {\r\n                    this.selectionManager.selectSingle(task);\r\n                    task.updateView();\r\n                }\r\n            }\r\n        },\r\n        data() {\r\n            return {\r\n                columns: [],\r\n                scrollables: [],\r\n                visibleRows: [],\r\n                visibleTasks: [],\r\n                _ganttBodyModules: [],\r\n                _ganttTableModules: [],\r\n                _modules: [],\r\n\r\n                _allTasks: [],\r\n                rows: [],\r\n\r\n                paddingTop: 0,\r\n                paddingBottom: 0,\r\n                scrollTop: 0\r\n            }\r\n        },\r\n        onstate(){\r\n\r\n        },\r\n        computed: {\r\n            rowContainerHeight: ({$rows, $rowHeight}) => $rows.length * $rowHeight,\r\n            startIndex: ({scrollTop, $rowHeight}) => Math.floor(scrollTop / $rowHeight),\r\n            endIndex: ({startIndex, viewportHeight, $rowHeight, $rows}) => Math.min(startIndex + Math.ceil(viewportHeight / $rowHeight ), $rows.length - 1),\r\n            paddingTop: ({startIndex, $rowHeight}) => startIndex * $rowHeight,\r\n            paddingBottom: ({$rows, endIndex, $rowHeight}) => ($rows.length - endIndex - 1) * $rowHeight,\r\n\r\n            visibleRows: ({$rows, startIndex, endIndex}) => $rows.slice(startIndex, endIndex + 1),\r\n            visibleTasks: ({$_taskCache, visibleRows}) => {\r\n                const visibleTasks = [];\r\n                visibleRows.forEach(row => {\r\n                    Array.prototype.push.apply(visibleTasks, row.tasks);\r\n                });\r\n                return visibleTasks;\r\n            }\r\n        }\r\n    };\r\n</script>",
    "<div class=\"row {row.model.classes}\" ref:row style=\"height:{$rowHeight}px\">\r\n    <!-- {#each row.tasks as task (task.model.id)}\r\n        <Task   row={row}\r\n        task={task}\r\n        on:taskMovedRow=\"taskAdded()\"\r\n        on:taskRemovedRow=\"taskRemoved()\"\r\n        on:taskDropped=\"taskDropped(task)\"/>\r\n    {/each} -->\r\n    {#if row.model.contentHtml}\r\n        {@html row.model.contentHtml}\r\n    {/if}\r\n</div>    \r\n<style>\r\n    .row {\r\n        position: relative;\r\n        width: 100%;\r\n        box-sizing: border-box;\r\n    }\r\n</style>\r\n<script>\r\n    import { DOMUtils } from \"./utils/domUtils\";\r\n\r\n    export default {\r\n        oncreate() {\r\n            const { row } = this.get();\r\n            row.rowElement = this.refs.row;\r\n            row.component = this;\r\n\r\n            if(!row.classes){ //default\r\n                row.classes = [];\r\n            }\r\n        },\r\n        onupdate({ changed, current, previous }) {\r\n            if(changed.row){\r\n                current.row.rowElement = this.refs.row;\r\n                current.row.component = this;\r\n            }\r\n        },\r\n        ondestroy(){\r\n            const { row } = this.get();\r\n            row.rowElement = null;\r\n            row.component = null;\r\n        },\r\n        methods: {\r\n            taskMoved() {\r\n                console.log('Task moved');\r\n            },\r\n            taskAdded() {\r\n                //when task moving to row, need to update row to show new task\r\n                const { row } = this.get();\r\n                //console.log('Task moved to row', row);\r\n                this.set({ row });\r\n            },\r\n            taskRemoved() {\r\n                const { row } = this.get();\r\n                //console.log('Task removed from row', row);\r\n                this.set({ row });\r\n            },\r\n            taskDropped(task) {\r\n                //this.handleOverlaps();\r\n            },\r\n            handleOverlaps(){\r\n                this.sortTasks();\r\n                const { row } = this.get();\r\n                const overlaps = [];\r\n                let previous = row.tasks[0];\r\n                for(let i = 1; i < row.tasks.length; i++){\r\n                    const current = row.tasks[i];\r\n\r\n                    if(current.overlaps(previous))\r\n                    {\r\n                        if(current.overlapping !== true){\r\n                            current.overlapping = true;\r\n                            current.component.set({ task: current });\r\n                        }\r\n                        if(previous.overlapping !== true){\r\n                            previous.overlapping = true;\r\n                            previous.component.set({ task: previous });\r\n                        }\r\n\r\n                        if(overlaps.indexOf(current.id) === -1){\r\n                            overlaps.push(current.id);\r\n                        }\r\n\r\n                        if(overlaps.indexOf(previous.id) === -1){\r\n                            overlaps.push(previous.id);\r\n                        }\r\n                    }\r\n\r\n                    if (previous.left + previous.width < current.left + current.width) {\r\n                        previous = current;\r\n                    }\r\n                }\r\n\r\n                for(let i = 0; i < row.tasks.length; i++){\r\n                    const current = row.tasks[i];\r\n                    if(overlaps.indexOf(current.id) === -1){\r\n                        if(!!current.overlapping) {\r\n                            current.overlapping = false;\r\n                            current.component.set({ task: current });\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            sortTasks() {\r\n                const { row } =  this.get();\r\n                row.tasks.sort(function (a, b) {\r\n                    if (a.left < b.left) {\r\n                        return -1\r\n                    } else if (a.left > b.left) {\r\n                        return 1\r\n                    }\r\n                    return 0\r\n                });\r\n            },\r\n            updateVisible(){\r\n                const { row } = this.get();\r\n\r\n                const visibleTasks = this.visibleTasks(row);\r\n                this.set({visibleTasks});\r\n            },\r\n            visibleTasks(row){\r\n                const { gantt, from, to } = this.store.get();\r\n                const scrollLeft = gantt.refs.mainContainer.scrollLeft;\r\n                const clientWidth = gantt.refs.mainContainer.clientWidth;\r\n                //finish this\r\n                //this.store.set({scrollLeft, clientWidth});\r\n\r\n                //da su sortirani -> index prvog, zadnjeg, i onda slice\r\n                //da su sortirani -> nakon zadnjeg break\r\n                const visibleTasks = [];\r\n                row.tasks.forEach(task => {\r\n                    if(!(task.to < from || task.from > to)){\r\n                        visibleTasks.push(task);\r\n                    }\r\n                });\r\n                //console.log(visibleTasks.length);\r\n                return visibleTasks;\r\n            }\r\n        }\r\n    };\r\n</script>",
    "<div ref:taskElement\r\n    class=\"task {model.classes}\" \r\n    style=\"\r\n    width:{widthT}px;\r\n    height:{height}px;\r\n    transform: translate({posX}px, {posY}px);\"\r\n    use:drag \r\n    use:selectable\r\n    class:overlapping=\"overlapping\"\r\n    class:selected=\"selected\"\r\n    class:moving=\"dragging||resizing\">\r\n    <div class=\"task-background\" style=\"width:{model.amountDone}%\"></div>\r\n    <div class=\"task-content\">\r\n        {#if model.html}\r\n            {@html model.html}\r\n        {:elseif $taskContent}\r\n            {@html $taskContent(this)}\r\n        {:else}\r\n            {model.label}\r\n        {/if}\r\n\r\n        {#if model.showButton}\r\n            <span class=\"task-button {model.buttonClasses}\" on:click=\"onclick(event)\">\r\n                {@html model.buttonHtml}\r\n            </span>\r\n        {/if}\r\n    </div>\r\n</div>\r\n\r\n<style>\r\n    .task {\r\n\t\tposition: absolute;     \r\n        top: 0;\r\n        bottom: 0;\r\n\r\n        white-space: nowrap;\r\n        overflow: hidden;\r\n\r\n        transition: background-color 0.2s;\r\n\t}\r\n\r\n    .task-background {\r\n        position: absolute;\r\n        height: 100%;\r\n        top: 0;\r\n    }\r\n\r\n    .task-content {\r\n        position: absolute;\r\n        height: 100%;\r\n        top: 0;\r\n\r\n        \r\n        padding-left: 14px;\r\n        font-size: 14px;\r\n        display: flex;\r\n        align-items: center;\r\n        justify-content: flex-start;\r\n    }\r\n\r\n    .task:not(.moving) {\r\n        transition: transform 0.2s, background-color 0.2s, width 0.2s;\r\n    }\r\n\r\n    .task.moving{\r\n        z-index: 1;\r\n    }\r\n\r\n    .task:hover::before {\r\n        content: '';\r\n        width: 4px;\r\n        height: 50%;\r\n        top: 25%;\r\n        position: absolute;\r\n        cursor: ew-resize;\r\n        border-style: solid;\r\n        border-color: rgba(255, 255, 255, 0.5);\r\n            \r\n        margin-left: 3px;\r\n        left: 0;\r\n        border-width: 0 1px;\r\n    }\r\n\r\n    .task:hover::after {\r\n        content: '';\r\n        width: 4px;\r\n        height: 50%;\r\n        top: 25%;\r\n        position: absolute;\r\n        cursor: ew-resize;\r\n        border-style: solid;\r\n        border-color: rgba(255, 255, 255, 0.5);\r\n\r\n        margin-right: 3px;\r\n        right: 0;\r\n        border-width: 0 1px;\r\n    }\r\n\r\n    .task.selected {\r\n        outline: 2px solid rgba(3, 169, 244, 0.5);\r\n        outline-offset: 3px;\r\n        z-index: 1;\r\n    }\r\n</style>\r\n\r\n<script>\r\n    import { DOMUtils } from \"./utils/domUtils\";\r\n\r\n\r\n    export default {\r\n        setup(component) {\r\n        },\r\n        oncreate() {\r\n            \r\n        },\r\n        ondestroy() {\r\n            \r\n        },\r\n        onupdate({ changed, current, previous }) {\r\n            if(changed.task){\r\n                //console.log('current', current.task);\r\n                //console.log('previous', previous && previous.task);\r\n                //current.row.rowElement = this.refs.row;\r\n                current.task.component = this;\r\n            }\r\n\r\n            if(changed.task && changed.row){\r\n                current.task.row = current.row;\r\n            }\r\n        },\r\n        actions: {\r\n\t\t\tdrag(node) {\r\n                const { rowContainerElement, ganttUtils, gantt, resizeHandleWidth } = this.store.get();\r\n                const windowElement = window;\r\n\r\n                let { model } = this.get();\r\n                //update reference when tasks are loaded with new data\r\n                // const listener = this.on('update', ({ changed, current, previous }) => {\r\n                //     if(changed.task){\r\n                //         task = current.task;\r\n                //     }\r\n                // });\r\n\r\n                let mouseStartPosX, mouseStartPosY;\r\n                let mouseStartRight;\r\n                \r\n                let originalRow;\r\n                let taskOriginalFrom, taskOriginalTo;\r\n                \r\n                    \r\n                const onmousedown = (event) => {\r\n                    if(event.which !== 1){\r\n                        //debugger;\r\n                        return;\r\n                    }\r\n\r\n                    const { left, posY, width } = this.get();\r\n\r\n                    event.stopPropagation();\r\n                    event.preventDefault();\r\n                    \r\n                    const { _rowCache } = gantt.get();\r\n                    originalRow = _rowCache[model.resourceId];\r\n                    taskOriginalFrom = model.from.clone();\r\n                    taskOriginalTo = model.to.clone();\r\n\r\n                    if(originalRow.model.enableDragging && model.enableDragging){\r\n                        mouseStartPosX = DOMUtils.getRelativePos(rowContainerElement, event).x - left;\r\n                        mouseStartPosY = DOMUtils.getRelativePos(rowContainerElement, event).y - posY;\r\n                        mouseStartRight = left + width;\r\n\r\n                        if(mouseStartPosX < resizeHandleWidth) {\r\n                            this.set({\r\n                                resizing: true,\r\n                                direction: 'left'\r\n                            })\r\n                            //gantt.includeInRender = task;\r\n                        }\r\n                        else if(mouseStartPosX > width - resizeHandleWidth) {\r\n\r\n                            this.set({\r\n                                resizing: true,\r\n                                direction: 'right'\r\n                            })\r\n                            //gantt.includeInRender = task;\r\n                        }\r\n                        else {\r\n                            this.set({\r\n                                dragging: true\r\n                            })\r\n                            // gantt.includeInRender = task;\r\n                        }\r\n\r\n                        windowElement.addEventListener('mousemove', onmousemove, false);\r\n                        DOMUtils.addEventListenerOnce(windowElement, 'mouseup', onmouseup);\r\n                    }\r\n                }\r\n                \r\n                const onmousemove = (event) => {\r\n\r\n                    const { resizing, dragging } = this.get()\r\n\r\n                    event.preventDefault();\r\n                    if(resizing) {\r\n                        const mousePos = DOMUtils.getRelativePos(rowContainerElement, event);\r\n                        const { direction, left, width } = this.get()\r\n                        \r\n                        if(direction === 'left') { //resize ulijevo\r\n                            if(mousePos.x > left + width) {\r\n                                this.set({\r\n                                    left: mouseStartRight,\r\n                                    posX: mouseStartRight,\r\n                                    width: mouseStartRight - mousePos.x,\r\n                                    widthT: mouseStartRight - mousePos.x,\r\n                                    direction: 'right',\r\n                                    mouseStartRight: mouseStartRight + width\r\n                                })\r\n                            }\r\n                            else{\r\n                                this.set({\r\n                                    left: mousePos.x,\r\n                                    posX: mousePos.x,\r\n                                    width: mouseStartRight - mousePos.x,\r\n                                    widthT: mouseStartRight - mousePos.x\r\n                                })\r\n                            }\r\n                        }\r\n                        else if(direction === 'right') {//resize desno\r\n                            if(mousePos.x <= left) {\r\n                                this.set({\r\n                                    width: left - mousePos.x,\r\n                                    widthT: left - mousePos.x,\r\n                                    left: mousePos.x,\r\n                                    posX: mousePos.x,\r\n                                    direction: 'left',\r\n                                    mouseStartRight: mousePos.x + left - mousePos.x\r\n                                })\r\n                            }\r\n                            else {\r\n                                this.set({\r\n                                    width: mousePos.x - left,\r\n                                    widthT: mousePos.x - left\r\n                                })\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // mouseup\r\n                    if(dragging) {\r\n                        const mousePos = DOMUtils.getRelativePos(rowContainerElement, event);\r\n\r\n                        this.set({\r\n                            left: mousePos.x - mouseStartPosX,\r\n                            posX: mousePos.x - mouseStartPosX,\r\n                            posY: mousePos.y - mouseStartPosY\r\n                        });\r\n                    }\r\n                    \r\n                }\r\n\r\n                const onmouseup = (event) => {\r\n                    \r\n                    const { left, width, dragging } = this.get()\r\n\r\n                    const { _taskCache, gantt } = this.store.get()\r\n\r\n                    if(dragging) {\r\n                        //row switching\r\n                        const rowCenterX = gantt.refs.mainContainer.getBoundingClientRect().left + gantt.refs.mainContainer.getBoundingClientRect().width / 2;\r\n                        const { _rowCache } = gantt.get();\r\n                        const sourceRow = _rowCache[model.resourceId];\r\n\r\n                        let elements = document.elementsFromPoint(rowCenterX, event.clientY);\r\n                        let rowElement = elements.find((element) => element.classList.contains('row'));\r\n                        if(rowElement !== undefined && rowElement !== sourceRow.rowElement) {\r\n\r\n                            const { rows } = gantt.store.get(); //visibleRows\r\n                            const targetRow = rows.find((r) => r.rowElement === rowElement); //vr\r\n\r\n                            if(targetRow.model.enableDragging){\r\n                                //targetRow.moveTask(this);\r\n                                model.resourceId = targetRow.model.id;\r\n                                \r\n                                sourceRow.component.taskRemoved();\r\n                                targetRow.component.taskAdded();\r\n                                gantt.api.tasks.raise.switchRow(this, targetRow, sourceRow);\r\n                            }\r\n                        }\r\n                    }\r\n                    \r\n                    this.set({\r\n                        posX: Math.ceil(left),\r\n                        posY: model.resourceId * 52,\r\n                        widthT: Math.ceil(width),\r\n                        \r\n                        dragging: false,\r\n                        resizing: false,\r\n                        direction: null,\r\n                    });\r\n\r\n                    _taskCache[model.id].updateDate();\r\n                    _taskCache[model.id].updatePosition();\r\n                    this.store.set({ _taskCache });\r\n\r\n\r\n                    //gantt.includeInRender = null;\r\n                    windowElement.removeEventListener('mousemove', onmousemove, false);\r\n                    //component.fire('taskDropped', { task });\r\n                    //component.set({task});\r\n\r\n                    //code this better\r\n                    const { _rowCache } = gantt.get();\r\n                    if(originalRow && originalRow !== _rowCache[model.resourceId]) {\r\n                        //originalRow.component.handleOverlaps();\r\n                        //_rowCache[task.model.resourceId].component.handleOverlaps();\r\n                    }\r\n\r\n                    // gantt.api.tasks.raise.moveEnd(task, task.row, originalRow);\r\n                    // if(!taskOriginalFrom.isSame(task.model.from) || !taskOriginalTo.isSame(task.model.to) || (originalRow && originalRow !== task.row)) {\r\n                    //     gantt.api.tasks.raise.changed(task, task.row, originalRow);\r\n                    // }\r\n                }\r\n\r\n                node.addEventListener('mousedown', onmousedown, false);\r\n\r\n                const cursorOnMove = (e) => {\r\n                    const { left, width } = this.get()\r\n\r\n                    const mouseStartPosX = DOMUtils.getRelativePos(rowContainerElement, e).x - left;\r\n\r\n                    //TODO globally set cursor ON mousedown\r\n                    if(mouseStartPosX < resizeHandleWidth || mouseStartPosX > width - resizeHandleWidth) {\r\n                        this.updateCursor('e-resize');\r\n                    }\r\n                    else{\r\n                        this.updateCursor();\r\n                    }\r\n\r\n                };\r\n                node.addEventListener('mousemove', cursorOnMove, false)\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\tupdate() {\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tdestroy() {\r\n\t\t\t\t\t\tnode.removeEventListener('mousedown', onmousedown, false);\r\n\t\t\t\t\t\t//windowElement.removeEventListener('mousemove', onmousemove, false);\r\n\t\t\t\t\t\tnode.removeEventListener('mousemove', onmousemove, false);\r\n                        node.removeEventListener('mouseup', onmouseup, false);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n            },\r\n            selectable(node) {\r\n                const { gantt } = this.store.get();\r\n                const self = this;\r\n                node.addEventListener('click', (e) => {\r\n                    const { model } = this.get();\r\n                    if(e.ctrlKey){\r\n                        gantt.selectionManager.toggleSelection(model);\r\n                    }\r\n                    else{\r\n                        gantt.selectionManager.selectSingle(model);\r\n                    }\r\n\r\n                    if(model.selected){\r\n                        gantt.api.tasks.raise.select(model);\r\n                    }\r\n                });\r\n            }\r\n        },\r\n        methods: {\r\n            updateCursor(cursor){\r\n                const element = this.refs.taskElement;\r\n                element.style.cursor = cursor || 'default';\r\n            },\r\n            onclick(event){\r\n                const { onTaskButtonClick } = this.store.get();\r\n                if(onTaskButtonClick) {\r\n                    event.stopPropagation();\r\n                    const { task } = this.get();\r\n                    onTaskButtonClick(task);\r\n                }\r\n            }\r\n        },\r\n        data() {\r\n            return {\r\n                dragging: false,\r\n                overlapping: false,\r\n                selected: false,\r\n                resizing: false\r\n            }\r\n        },\r\n        computed: {\r\n            selected: ({$selection, model}) => $selection.indexOf(model) !== -1\r\n        }\r\n    };\r\n</script>",
    "<div class=\"column\" style=\"width:{width}px;left:{left}px\"></div>\r\n<style>\r\n    .column {\r\n        position: absolute;\r\n        height: 100%;\r\n        box-sizing: border-box;\r\n    }\r\n</style>\r\n<script>\r\n    export default {\r\n        oncreate() {\r\n        },\r\n        data(){\r\n            return {}\r\n        }\r\n    }\r\n</script>",
    "<div class=\"column-header-row\" style=\"width:{width}px\">\r\n    {#each headers as header}\r\n        <div class=\"column-header\" style=\"width:{header.width}px\">\r\n            {header.label || 'N/A'}\r\n        </div>\r\n    {/each}\r\n</div>\r\n<style>\r\n    .column-header-row {\r\n        box-sizing: border-box;\r\n        white-space: nowrap;\r\n        overflow: hidden;\r\n\r\n        height: 32px;\r\n    }\r\n\r\n    .column-header {\r\n        position: relative;\r\n        display: inline-block;\r\n        height: 100%;\r\n        box-sizing: border-box;\r\n        text-overflow: clip;\r\n        /* vertical-align: top; */\r\n        text-align: center;\r\n\r\n        display: inline-flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n        font-size: 1em;    \r\n        font-size: 14px;\r\n        font-weight: 300;\r\n        transition: background 0.2s;\r\n    }\r\n\r\n    .column-header:hover {\r\n        background: #f9f9f9;\r\n    }\r\n    \r\n</style>\r\n<script>\r\n    export default {\r\n        oncreate() {\r\n            this.initHeaders();\r\n        },\r\n        onupdate({ changed, current, previous }){\r\n            if(previous != null){\r\n                this.initHeaders();\r\n            }\r\n        },\r\n        methods: {\r\n            initHeaders() {\r\n                this.root.initGantt();\r\n                const { header } = this.get();\r\n                const { from, width, gantt } = this.store.get();\r\n                const columnWidth = gantt.utils.getPositionByDate(from.clone().add(1, header.unit));\r\n                const columnCount = Math.ceil(width / columnWidth) \r\n\r\n                const headers = [];\r\n                let headerTime = from.clone();\r\n\r\n                for(let i=0; i< columnCount; i++){\r\n                    headers.push({width: columnWidth, label: headerTime.format(header.format)});\r\n                    headerTime.add(1, header.unit);\r\n                }\r\n\r\n                this.set({headers});\r\n            }\r\n        },\r\n        data(){\r\n            return {\r\n                headers: [],\r\n                width: null\r\n            }\r\n        }\r\n    };\r\n</script>",
    "<div class=\"s-g-time-range\" class:moving=\"timeRange.resizing\" style=\"width:{timeRange.width}px;left:{timeRange.left}px\">\r\n    <div class=\"s-g-time-range-label\">{timeRange.model.label}</div>\r\n</div>\r\n<style>\r\n    .s-g-time-range {\r\n        height: 100%;\r\n        position: absolute;\r\n        display: flex;\r\n        flex-direction: column;\r\n        align-items: center;\r\n\r\n        background-image: linear-gradient(-45deg, rgba(0, 0, 0, 0) 46%, #e03218 49%, #e03218 51%, rgba(0, 0, 0, 0) 55%);\r\n        background-size: 6px 6px !important;\r\n        color: red;\r\n        font-weight: 400;\r\n    }\r\n\r\n    .s-g-time-range-label {\r\n        margin-top: 10px;\r\n        background: #fff;\r\n        white-space: nowrap;\r\n        padding: 4px;\r\n        font-weight: 400;\r\n        font-size: 10px;\r\n    }\r\n</style>\r\n<script>\r\n    export default {\r\n        oncreate() {\r\n            const { timeRange } = this.get();\r\n            timeRange.component = this;\r\n        },\r\n        ondestroy(){\r\n            const { timeRange } = this.get();\r\n            timeRange.component = null;\r\n        },\r\n        data(){\r\n            return {\r\n                timeRange: null\r\n            }\r\n        }\r\n    }\r\n</script>",
    "<div class=\"s-g-time-range-control\" style=\"width:{timeRange.width}px;left:{timeRange.left}px\">\r\n    <div class=\"s-g-time-range-handle-left\" use:drag></div>\r\n    <div class=\"s-g-time-range-handle-right\" use:drag></div>\r\n</div>\r\n<style>\r\n    .s-g-time-range-control {\r\n        position: absolute;\r\n    }\r\n\r\n    .s-g-time-range-handle-left {\r\n        position: absolute;\r\n        left: 0;\r\n    }\r\n\r\n    .s-g-time-range-handle-right {\r\n        position: absolute;\r\n        right: 0;\r\n    }\r\n\r\n    .s-g-time-range-handle-left::before, .s-g-time-range-handle-right::before {\r\n        position: absolute;\r\n        content: '';\r\n        bottom: 4px;\r\n        border-radius: 6px 6px 6px 0;\r\n        border: 2px solid #b0b0b7;\r\n        width: 9px;\r\n        height: 9px;\r\n        transform: translateX(-50%) rotate(-45deg);\r\n        background-color: #fff;\r\n\r\n        border-color: #e03218;\r\n        cursor: ew-resize;\r\n    }\r\n</style>\r\n<script>\r\n    import { DOMUtils } from \"./utils/domUtils\";\r\n\r\n    export default {\r\n        oncreate() {\r\n            const { timeRange } = this.get();\r\n            timeRange.handle = this;\r\n        },\r\n        actions: {\r\n            drag(node) {\r\n                const { rowContainerElement, ganttUtils, gantt, resizeHandleWidth } = this.store.get();\r\n                const windowElement = window;\r\n\r\n                let mouseStartPosX;\r\n                let mouseStartRight;\r\n                \r\n                const { timeRange } = this.get();\r\n                \r\n                const onmousedown = (event) => {\r\n                    event.stopPropagation();\r\n                    event.preventDefault();\r\n                    \r\n                    if(true){\r\n                        mouseStartPosX = DOMUtils.getRelativePos(rowContainerElement, event).x - timeRange.left;\r\n                        mouseStartRight = timeRange.left + timeRange.width;\r\n\r\n                        if(mouseStartPosX < resizeHandleWidth) {\r\n                            timeRange.resizing = true;\r\n                            timeRange.direction = 'left';\r\n                        }\r\n                        else if(mouseStartPosX > timeRange.width - resizeHandleWidth) {\r\n                            timeRange.resizing = true;\r\n                            timeRange.direction = 'right';\r\n                        }\r\n                        else {\r\n                            timeRange.dragging = true;\r\n                        }\r\n\r\n                        windowElement.addEventListener('mousemove', onmousemove, false);\r\n                        DOMUtils.addEventListenerOnce(windowElement, 'mouseup', onmouseup);\r\n                    }\r\n                }\r\n                \r\n                const onmousemove = (event) => {\r\n                    event.preventDefault();\r\n                    if(timeRange.resizing) {\r\n                        const mousePos = DOMUtils.getRelativePos(rowContainerElement, event);\r\n                        \r\n                        if(timeRange.direction === 'left') { \r\n                            if(mousePos.x > timeRange.left + timeRange.width) {\r\n                                timeRange.left = mouseStartRight;\r\n                                timeRange.width = timeRange.left - mousePos.x;\r\n                                timeRange.direction = 'right'\r\n                                mouseStartRight = timeRange.left + timeRange.width;\r\n                            }\r\n                            else{\r\n                                timeRange.left = mousePos.x;\r\n                                timeRange.width = mouseStartRight - mousePos.x;\r\n                            }\r\n                        }\r\n                        else if(timeRange.direction === 'right') {//resize desno\r\n                            if(mousePos.x <= timeRange.left) {\r\n                                timeRange.width = timeRange.left - mousePos.x;\r\n                                timeRange.left = mousePos.x;\r\n                                timeRange.direction = 'left';\r\n                                mouseStartRight = timeRange.left + timeRange.width;\r\n                            }\r\n                            else {\r\n                                timeRange.width = mousePos.x - timeRange.left;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(timeRange.resizing){\r\n                        timeRange.updateView();\r\n                    }\r\n                }\r\n\r\n                const onmouseup = (event) => {\r\n                    timeRange.updateDate();\r\n                    timeRange.updatePosition();\r\n                    \r\n                    timeRange.dragging = false;\r\n                    timeRange.resizing = false;\r\n                    timeRange.direction = null;\r\n                    timeRange.updateView();\r\n\r\n                    windowElement.removeEventListener('mousemove', onmousemove, false);\r\n                }\r\n\r\n                node.addEventListener('mousedown', onmousedown, false);\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\tupdate() {\r\n                        \r\n\t\t\t\t\t},\r\n\t\t\t\t\tdestroy() {\r\n                        node.removeEventListener('mousedown', onmousedown, false);\r\n\t\t\t\t\t\tnode.removeEventListener('mousemove', onmousemove, false);\r\n                        node.removeEventListener('mouseup', onmouseup, false);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n            }\r\n        },\r\n        data(){\r\n            return {\r\n                timeRange: null\r\n            }\r\n        }\r\n    }\r\n</script>"
  ],
  "names": [],
  "mappings": "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"
}