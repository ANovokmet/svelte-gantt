{
  "version": 3,
  "file": "svelteGantt.css",
  "sources": [
    "..\\src\\Gantt.html",
    "..\\src\\Row.html",
    "..\\src\\Column.html",
    "..\\src\\ColumnHeader.html",
    "..\\src\\Task.html",
    "..\\src\\ContextMenu.html"
  ],
  "sourcesContent": [
    "<div class=\"gantt {$classes}\" use:disableContextMenu ref:ganttElement>\r\n    {#each _ganttTableModules as module (module.key)}\r\n        <svelte:component this={module} on:init=\"initModule(event.module)\" {visibleRows}/>\r\n    {/each}\r\n\r\n    <div class=\"main-header-container\" use:horizontalScrollListener  ref:sideContainer>\r\n        <div class=\"header-container\" style=\"width:{$width}px\">\r\n            {#each $headers as header}\r\n                <ColumnHeader header={header}/>\r\n            {/each}\r\n        </div>\r\n    </div>\r\n\r\n    <div class=\"main-container\" style=\"height:{$height}px\" use:scrollable ref:mainContainer>\r\n        <div class=\"content\" style=\"width:{$width}px\">\r\n            <div class=\"column-container\">\r\n                {#each columns as column}\r\n                    <Column width={column.width}/>\r\n                {/each}\r\n            </div>\r\n            <div class=\"row-container\" style=\"padding-top:{paddingTop}px;padding-bottom:{paddingBottom}px;height:{rowContainerHeight}px;\"\r\n                ref:rowContainer>\r\n                {#each visibleRows as row (row.model.id)}\r\n                    <Row row={row}\r\n                        on:updateVisibleRows=\"updateViewport()\"/>\r\n                {/each}\r\n            </div>\r\n            {#each _ganttBodyModules as module (module.key)}\r\n                <svelte:component this={module} on:init=\"initModule(event.module)\" />\r\n            {/each}\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<style>\r\n    .gantt {\r\n        width: 100%;\r\n        height: 100%;\r\n        position: relative;\r\n    }\r\n\r\n    .column-container {\r\n        position: absolute;\r\n        height: 100%;\r\n\r\n        float: left;\r\n        overflow: hidden;\r\n    }\r\n\r\n    .row-container {\r\n        width: 100%;\r\n        /* display: inline-block; */\r\n        box-sizing: border-box;\r\n    }\r\n\r\n    .main-container {\r\n        /* position: relative; */\r\n        overflow: auto;\r\n    }\r\n\r\n    .main-header-container {\r\n        position: relative;\r\n        overflow: hidden;\r\n    }\r\n\r\n    .content {\r\n        position: relative;\r\n    }\r\n\r\n    :global(*) {\r\n        box-sizing: border-box;\r\n    }\r\n</style>\r\n\r\n<script>\r\n    import Row from './Row.html';\r\n    import Column from './Column.html';\r\n    import ColumnHeader from './ColumnHeader.html';\r\n    import { Store } from 'svelte/store.js';\r\n    import ContextMenuManager from './contextMenuManager.js'\r\n    import SelectionManager from './selectionManager.js';\r\n    import GanttUtils from './utils.js';\r\n    import GanttApi from './api.js';\r\n\r\n    import Task from \"./Task.html\";\r\n    import { SvelteTask } from \"./task.js\";\r\n    import { SvelteRow } from \"./row.js\";\r\n\r\n    //import GanttDependencies from './modules/dependencies/GanttDependencies.html';\r\n    //import Table from './modules/table/Table.html';\r\n\r\n    let SvelteGantt;\r\n\r\n    export default {\r\n        setup(component){\r\n            SvelteGantt = component;\r\n            SvelteGantt.defaults = {\r\n                // datetime timeline starts on, currently moment-js object\r\n                from: null,\r\n                // datetime timeline ends on, currently moment-js object\r\n                to: null,\r\n                // width of main gantt area in px\r\n                width: 800, //rename to timelinewidth\r\n                // should timeline stretch width to fit, true overrides timelineWidth\r\n                stretchTimelineWidthToFit: false,\r\n                // height of main gantt area in px\r\n                height: 400,\r\n                // minimum unit of time task date values will round to \r\n                magnetUnit: 'minute',\r\n                // amount of units task date values will round to\r\n                magnetOffset: 15,\r\n                // list of headers used for main gantt area\r\n                // unit: time unit used, e.g. day will create a cell in the header for each day in the timeline\r\n                // format: datetime format used for header cell label\r\n                headers: [{unit: 'day', format: 'DD.MM.YYYY'}, {unit: 'hour', format: 'HH'}],\r\n                // height of a single row in px\r\n                rowHeight: 24,\r\n                // modules used in gantt\r\n                modules: [],\r\n                // enables right click context menu\r\n                enableContextMenu: false,\r\n                // sets top level gantt class which can be used for styling\r\n                classes: '',\r\n                // width of handle for resizing task\r\n                resizeHandleWidth: 5\r\n            };\r\n\r\n            SvelteGantt.create = function(target, data, options) {\r\n\r\n                // bind gantt modules\r\n                const ganttModules = {\r\n                    ganttBodyModules: [],\r\n                    ganttTableModules: [],\r\n                    defaults: {}\r\n                }\r\n\r\n                if(options.modules) {\r\n                    options.modules.forEach((module) => {\r\n                        module.bindToGantt(ganttModules);\r\n                    })\r\n                }\r\n\r\n                // initialize gantt state\r\n                const newData = {\r\n                    initialRows: data.rows,\r\n                    initialDependencies: data.dependencies,\r\n                    _ganttBodyModules: ganttModules.ganttBodyModules,\r\n                    _ganttTableModules: ganttModules.ganttTableModules\r\n                };\r\n\r\n                // initialize all the gantt options\r\n                const ganttOptions = Object.assign({}, SvelteGantt.defaults, ganttModules.defaults, options);\r\n                \r\n                const store = new Store();\r\n                store.set(ganttOptions);\r\n\r\n                return new SvelteGantt({\r\n                    target,\r\n                    data: newData,\r\n                    store\r\n                });\r\n            }\r\n        },\r\n        components: { Row, Column, ColumnHeader },\r\n        oncreate(){\r\n            this.initGantt();\r\n            \r\n            const {rows, initialRows, initialDependencies} = this.get();\r\n            this.initData({rows: initialRows, dependencies: initialDependencies});\r\n            this.initColumns();\r\n\r\n            this.refs.mainContainer.addEventListener('mouseup', function(event){\r\n                console.log('mouse up on ', event.target);\r\n            });\r\n\r\n            this.onWindowResizeHandler = (event) => {\r\n                const parentWidth = this.refs.ganttElement.clientWidth;\r\n                const parentHeight = this.refs.ganttElement.clientHeight;\r\n                \r\n                const stretchWidth = this.store.get().stretchTimelineWidthToFit;\r\n                const tableWidth = this.store.get().tableWidth || 0;\r\n\r\n                this.refs.sideContainer.style.width = parentWidth - tableWidth - 17 + 'px';\r\n                this.refs.mainContainer.style.width = parentWidth - tableWidth + 'px';\r\n\r\n                const update = {};\r\n                update.height = parentHeight - this.refs.sideContainer.clientHeight - 17;\r\n                if(stretchWidth){\r\n                    update.width = parentWidth - tableWidth - 17;\r\n                }\r\n\r\n                this.store.set(update);\r\n                if(stretchWidth){\r\n                    this.initColumns();\r\n                }\r\n            };\r\n\r\n            window.addEventListener('resize', this.onWindowResizeHandler); // or this.onW... .bind(this);\r\n            this.onWindowResizeHandler(null);\r\n            \r\n            this.broadcastModules('onGanttCreated');\r\n            this.updateViewport();\r\n        },\r\n        ondestroy(){\r\n            //remove event listener\r\n            window.removeEventListener('resize', this.onWindowResizeHandler)\r\n        },\r\n        actions: {\r\n            disableContextMenu(node) {\r\n                if(this.store.get().enableContextMenu){\r\n                    node.addEventListener('contextmenu', function(e) {\r\n                        e.preventDefault();\r\n                    }, false);\r\n                    //ovo dolje radi kad stvori≈° svelte contextmenu, klikne na sam contextmenu TO DO remove\r\n                    document.addEventListener('contextmenu', function(e) {\r\n                        e.preventDefault();\r\n                    }, false);\r\n                }\r\n            },\r\n            scrollable(node){\r\n                const { scrollables } = this.get();\r\n                const self = this;\r\n\r\n                function onscroll(event) {\r\n                    const scrollAmount = node.scrollTop; \r\n                    for(let i=0; i< scrollables.length; i++){\r\n                        const scrollable = scrollables[i];\r\n                        if(scrollable.orientation === 'horizontal') {\r\n                            scrollable.node.scrollLeft = node.scrollLeft;\r\n                        }\r\n                        else {\r\n                            scrollable.node.scrollTop = scrollAmount;\r\n                        }\r\n                    }\r\n                    //TODO: only for vertical scroll\r\n                    self.updateVisibleRows(scrollAmount, node.clientHeight);\r\n\r\n                    self.broadcastModules('updateVisible', {scrollAmount, viewportHeight: node.clientHeight});\r\n                }\r\n\r\n                node.addEventListener('scroll', onscroll);\r\n                return {\r\n\t\t\t\t\tdestroy() {\r\n\t\t\t\t\t\tnode.removeEventListener('scroll', onscroll, false);\r\n\t\t\t\t\t}\r\n                }\r\n            },\r\n            scrollListener(node){\r\n                const { scrollables } = this.get();\r\n                scrollables.push({node});\r\n            },\r\n            horizontalScrollListener(node){\r\n                const { scrollables } = this.get();\r\n                scrollables.push({node, orientation: 'horizontal'});\r\n            }\r\n\t\t},\r\n        methods: {\r\n            initData(data){\r\n                const rows = [];\r\n                const _allTasks = [];\r\n                const _taskCache = {};\r\n                for(let i=0; i < data.rows.length; i++){\r\n                    const currentRow = data.rows[i];\r\n                    const row = new SvelteRow(this, currentRow);\r\n                    for(let j=0; j < currentRow.tasks.length; j++){\r\n                        const currentTask = currentRow.tasks[j];\r\n                        \r\n                        const task = new SvelteTask(this, currentTask, row);\r\n                        row.addTask(task);\r\n                        _allTasks.push(task);\r\n                        _taskCache[task.model.id] = task;\r\n                    }\r\n                    rows.push(row);\r\n                }\r\n                this.set({\r\n                    _allTasks,\r\n                    _taskCache,\r\n                    rows\r\n                });\r\n                this.store.set({rows});\r\n                this.selectionManager.clearSelection();\r\n                this.broadcastModules('initData', data);\r\n                this.updateViewport();\r\n            },\r\n            initGantt(){\r\n                if(!this.store.get().gantt){\r\n                    this.store.set({\r\n                        bodyElement: this.refs.mainContainer, \r\n                        rowContainerElement: this.refs.rowContainer,\r\n                        gantt: this\r\n                    });\r\n                    \r\n                    this.menuManager = new ContextMenuManager(this);\r\n                    this.selectionManager = new SelectionManager();\r\n                    this.utils = new GanttUtils(this);\r\n                    this.api = new GanttApi(this);\r\n\r\n                    this.api.registerEvent('tasks', 'move');\r\n                    this.api.registerEvent('tasks', 'select');\r\n                    this.api.registerEvent('tasks', 'switchRow');\r\n                    this.api.registerEvent('tasks', 'moveEnd');\r\n\r\n                    this.row = SvelteRow;\r\n                    this.task = SvelteTask;\r\n                }\r\n            },\r\n            initModule(module){\r\n                const moduleOptions = Object.assign({\r\n                    _gantt: this,\r\n                    _options: this.get()\r\n                }, {});//merge with module specific data, modules[module.constructor.key]);\r\n                module.initModule(moduleOptions);\r\n                \r\n                const {_modules} = this.get();\r\n                _modules.push(module);\r\n            },\r\n            broadcastModules(event, data) {\r\n                const {_modules} = this.get();\r\n                _modules.forEach((module) => {\r\n                    if (typeof module[event] === 'function') {\r\n                        module[event](data);\r\n                    }\r\n                });\r\n            },\r\n            updateVisibleRows(scrollTop, viewportHeight){\r\n                const { rows, rowHeight } = this.store.get();\r\n\r\n                let startIndex = Math.floor(scrollTop / rowHeight);\r\n                let endIndex = Math.min(startIndex + Math.ceil(viewportHeight / rowHeight ), rows.length - 1);\r\n\r\n                const paddingTop = startIndex * rowHeight;\r\n                const paddingBottom = (rows.length - endIndex - 1) * rowHeight;\r\n\r\n                const visibleRows = rows.slice(startIndex, endIndex + 1);\r\n\r\n                //only horizontal scroll\r\n                /*visibleRows.forEach(row => {\r\n                    row.visibleTasks = this.visibleTasks(row);\r\n                });*/\r\n\r\n                this.set({ visibleRows, paddingTop, paddingBottom });\r\n                this.store.set({ visibleRows, paddingTop, paddingBottom });\r\n            },\r\n            visibleTasks(row){\r\n                const scrollLeft = this.refs.mainContainer.scrollLeft;\r\n                const clientWidth = this.refs.mainContainer.clientWidth;\r\n                //finish this\r\n                //this.store.set({scrollLeft, clientWidth});\r\n\r\n                //da su sortirani -> index prvog, zadnjeg, i onda slice\r\n                //da su sortirani -> nakon zadnjeg break\r\n                const visibleTasks = [];\r\n                row.tasks.forEach(task => {\r\n                    if(!(task.left + task.width < scrollLeft || task.left > scrollLeft + clientWidth)){\r\n                        visibleTasks.push(task);\r\n                    }\r\n                });\r\n                console.log(visibleTasks.length);\r\n                return visibleTasks;\r\n            },\r\n            updateViewport(){\r\n                const {scrollTop, clientHeight} = this.refs.mainContainer;\r\n\r\n                this.updateVisibleRows(scrollTop, clientHeight);\r\n                this.broadcastModules('updateVisible', {scrollAmount: scrollTop, viewportHeight: clientHeight});\r\n            },\r\n            initColumns() {\r\n                const {magnetOffset, magnetUnit, from, width, headers} = this.store.get();\r\n                const columnWidth = this.utils.getPositionByDate(from.clone().add(magnetOffset, magnetUnit));\r\n                const columnCount = Math.ceil((width) / columnWidth) \r\n\r\n                const columns = [];\r\n                for(let i = 0; i < columnCount; i++){\r\n                    //const columnFrom = from.clone().add(magnetOffset, magnetUnit);\r\n                    columns.push({width: columnWidth, /*from: columnFrom*/});\r\n                }\r\n\r\n                const {_allTasks} = this.get();\r\n                _allTasks.forEach(task => {\r\n                    task.updatePosition();\r\n                    task.updateView();\r\n                });\r\n                this.broadcastModules('updateView', {});\r\n\r\n                this.set({ columns });\r\n                this.store.set({ headers });\r\n            },\r\n            updateView(options){ // {from, to, headers, width}\r\n                this.store.set(options);\r\n                if(this.store.get().stretchTimelineWidthToFit){\r\n                    this.onWindowResizeHandler(null);\r\n                }\r\n                else{\r\n                    this.initColumns();\r\n                }\r\n\r\n                const { _allTasks } = this.get();\r\n                _allTasks.forEach(task => {\r\n                    task.updatePosition();\r\n                    task.updateView();\r\n                });\r\n\r\n                const { rows } = this.store.get();\r\n                rows.forEach(row => {\r\n                    if(row.component)\r\n                        row.component.updateVisible();\r\n                });\r\n\r\n                this.broadcastModules('updateView', options);//{ from, to, headers });\r\n            }\r\n        },\r\n        data() {\r\n            return {\r\n                columns: [],\r\n                scrollables: [],\r\n                visibleRows: [],\r\n                _ganttBodyModules: [],\r\n                _ganttTableModules: [],\r\n                _modules: [],\r\n\r\n                rows: [],\r\n\r\n                paddingTop: 0,\r\n                paddingBottom: 0\r\n            }\r\n        },\r\n        computed: {\r\n            rowContainerHeight: ({rows, $rowHeight}) => rows.length * $rowHeight\r\n        }\r\n    };\r\n</script>",
    "<div class=\"row {row.model.classes}\" ref:row style=\"height:{$rowHeight}px\" use:contextMenu>\r\n    {#each row.tasks as task (task.model.id)}\r\n        <Task   row={row}\r\n                task={task}\r\n                on:taskMovedRow=\"taskAdded()\"\r\n                on:taskRemovedRow=\"taskRemoved()\"\r\n                on:taskDropped=\"taskDropped(task)\"/>\r\n    {/each}\r\n    {#if row.model.contentHtml}\r\n        {@html row.model.contentHtml}\r\n    {/if}\r\n</div>\r\n<style>\r\n    .row {\r\n        position: relative;\r\n        width: 100%;\r\n        box-sizing: border-box;\r\n    }\r\n</style>\r\n<script>\r\n    import Task from './Task.html';\r\n    import ContextMenu from \"./ContextMenu.html\";\r\n    import { DOMUtils } from \"./domUtils.js\";\r\n\r\n    export default {\r\n        components: { Task },\r\n        oncreate() {\r\n            const { row } = this.get();\r\n            row.rowElement = this.refs.row;\r\n            row.component = this;\r\n\r\n            if(!row.classes){ //default\r\n                row.classes = [];\r\n            }\r\n        },\r\n        onupdate({ changed, current, previous }) {\r\n            if(changed.row){\r\n                current.row.rowElement = this.refs.row;\r\n                current.row.component = this;\r\n            }\r\n        },\r\n        ondestroy(){\r\n            const { row } = this.get();\r\n            row.rowElement = null;\r\n            row.component = null;\r\n        },\r\n        methods: {\r\n            taskMoved() {\r\n                console.log('Task moved');\r\n            },\r\n            taskAdded() {\r\n                //when task moving to row, need to update row to show new task\r\n                const { row } = this.get();\r\n                console.log('Task moved to row', row);\r\n                this.set({ row });\r\n            },\r\n            taskRemoved() {\r\n                const { row } = this.get();\r\n                console.log('Task removed from row', row);\r\n                this.set({ row });\r\n            },\r\n            taskDropped(task) {\r\n                this.handleOverlaps();\r\n            },\r\n            handleOverlaps(){\r\n                this.sortTasks();\r\n                const { row } = this.get();\r\n                const overlaps = [];\r\n                let previous = row.tasks[0];\r\n                for(let i = 1; i < row.tasks.length; i++){\r\n                    const current = row.tasks[i];\r\n\r\n                    if(current.overlaps(previous))\r\n                    {\r\n                        if(current.overlapping !== true){\r\n                            current.overlapping = true;\r\n                            current.component.set({ task: current });\r\n                        }\r\n                        if(previous.overlapping !== true){\r\n                            previous.overlapping = true;\r\n                            previous.component.set({ task: previous });\r\n                        }\r\n\r\n                        if(overlaps.indexOf(current.id) === -1){\r\n                            overlaps.push(current.id);\r\n                        }\r\n\r\n                        if(overlaps.indexOf(previous.id) === -1){\r\n                            overlaps.push(previous.id);\r\n                        }\r\n                    }\r\n\r\n                    if (previous.left + previous.width < current.left + current.width) {\r\n                        previous = current;\r\n                    }\r\n                }\r\n\r\n                for(let i = 0; i < row.tasks.length; i++){\r\n                    const current = row.tasks[i];\r\n                    if(overlaps.indexOf(current.id) === -1){\r\n                        if(!!current.overlapping) {\r\n                            current.overlapping = false;\r\n                            current.component.set({ task: current });\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            sortTasks() {\r\n                const { row } =  this.get();\r\n                row.tasks.sort(function (a, b) {\r\n                    if (a.left < b.left) {\r\n                        return -1\r\n                    } else if (a.left > b.left) {\r\n                        return 1\r\n                    }\r\n                    return 0\r\n                });\r\n            },\r\n            updateVisible(){\r\n                const { row } = this.get();\r\n\r\n                const visibleTasks = this.visibleTasks(row);\r\n                this.set({visibleTasks});\r\n            },\r\n            visibleTasks(row){\r\n                const { gantt, from, to } = this.store.get();\r\n                const scrollLeft = gantt.refs.mainContainer.scrollLeft;\r\n                const clientWidth = gantt.refs.mainContainer.clientWidth;\r\n                //finish this\r\n                //this.store.set({scrollLeft, clientWidth});\r\n\r\n                //da su sortirani -> index prvog, zadnjeg, i onda slice\r\n                //da su sortirani -> nakon zadnjeg break\r\n                const visibleTasks = [];\r\n                row.tasks.forEach(task => {\r\n                    if(!(task.to < from || task.from > to)){\r\n                        visibleTasks.push(task);\r\n                    }\r\n                });\r\n                console.log(visibleTasks.length);\r\n                return visibleTasks;\r\n            }\r\n        },\r\n        actions: {\r\n            contextMenu(node){\r\n                const { gantt } = this.store.get();\r\n\r\n                if(gantt.enableContextMenu){\r\n                    const { row } = this.get();\r\n                    const options = [\r\n                        {\r\n                            label: 'Copy row',\r\n                            action: () => console.log('clicked action 1 for task ', row.id)\r\n                        },\r\n                        {\r\n                            label: 'Clear dependencies',\r\n                            action: () => console.log('clicked action 2 for task ', row.id)\r\n                        }\r\n                    ];\r\n\r\n                    function onClose(event) {\r\n                        //if(!contextMenu.isTarget(e))\r\n                        gantt.menuManager.close();\r\n                    }\r\n\r\n                    node.addEventListener('mouseup', (e) => {\r\n                        //e.stopPropagation();\r\n                        if(e.which === 3){\r\n                            gantt.menuManager.open(options, {x: e.x, y: e.y});\r\n\r\n                            DOMUtils.addEventListenerOnce(node, 'mousedown', onClose); //document.body\r\n                        }\r\n                    });\r\n                }\r\n                \r\n                return {\r\n                    destroy() {\r\n                        gantt.menuManager.close();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n</script>",
    "<div class=\"column\" style=\"width:{width}px\"></div>\r\n<style>\r\n    .column {\r\n        position: relative;\r\n        display: inline-block;\r\n        height: 100%;\r\n        box-sizing: border-box;\r\n    }\r\n</style>\r\n<script>\r\n    export default {\r\n        oncreate() {\r\n        },\r\n        data(){\r\n            return {}\r\n        }\r\n    }\r\n</script>",
    "<div class=\"column-header-row\" style=\"width:{width}px\">\r\n    {#each headers as header}\r\n        <div class=\"column-header\" style=\"width:{header.width}px\">\r\n            {header.label || 'N/A'}\r\n        </div>\r\n    {/each}\r\n</div>\r\n<style>\r\n    .column-header-row {\r\n        box-sizing: border-box;\r\n        border-top: 1px solid #ddd;\r\n        white-space: nowrap;\r\n        overflow: hidden;\r\n    }\r\n\r\n    .column-header {\r\n        position: relative;\r\n        display: inline-block;\r\n        height: 100%;\r\n        box-sizing: border-box;\r\n        text-overflow: clip;\r\n        /* vertical-align: top; */\r\n        text-align: center;\r\n    }\r\n</style>\r\n<script>\r\n    export default {\r\n        oncreate() {\r\n            this.initHeaders();\r\n        },\r\n        onupdate({ changed, current, previous }){\r\n            if(previous != null){\r\n                this.initHeaders();\r\n            }\r\n        },\r\n        methods: {\r\n            initHeaders() {\r\n                this.root.initGantt();\r\n                const { header } = this.get();\r\n                const { from, width, gantt } = this.store.get();\r\n                const columnWidth = gantt.utils.getPositionByDate(from.clone().add(1, header.unit));\r\n                const columnCount = Math.ceil(width / columnWidth) \r\n\r\n                const headers = [];\r\n                let headerTime = from.clone();\r\n\r\n                for(let i=0; i< columnCount; i++){\r\n                    headers.push({width: columnWidth, label: headerTime.format(header.format)});\r\n                    headerTime.add(1, header.unit);\r\n                }\r\n\r\n                this.set({headers});\r\n            }\r\n        },\r\n        data(){\r\n            return {\r\n                headers: [],\r\n                width: null\r\n            }\r\n        }\r\n    };\r\n</script>",
    "<div ref:taskElement\r\n    class=\"task {task.model.classes}\" \r\n    style=\"left:{task.truncated ? task.truncatedLeft : task.left}px;width:{task.truncated ? task.truncatedWidth : task.width}px;\"\r\n    use:drag \r\n    use:contextMenu\r\n    use:selectable\r\n    class:overlapping=\"task.overlapping\"\r\n    class:selected=\"task.selected\"\r\n    class:moving=\"task.dragging||task.resizing\">\r\n    <div class=\"task-background\" style=\"width:{task.model.amountDone}%\"></div>\r\n    <div class=\"task-content\">\r\n        {#if task.model.html}\r\n            {@html task.model.html}\r\n        {:else}\r\n            {task.model.label}\r\n        {/if}\r\n    </div>\r\n</div>\r\n\r\n<style>\r\n    .task {\r\n\t\tposition: absolute;     \r\n        top: 0;\r\n        bottom: 0;\r\n        margin: auto;  \r\n        white-space: nowrap;\r\n        overflow: hidden;\r\n\t}\r\n\r\n    .task-background {\r\n        position: absolute;\r\n        height: 100%;\r\n        top: 0;\r\n    }\r\n\r\n    .task-content {\r\n        position: absolute;\r\n        height: 100%;\r\n        top: 0;\r\n    }\r\n</style>\r\n\r\n<script>\r\n    import { DOMUtils } from \"./domUtils.js\";\r\n    import ContextMenu from \"./ContextMenu.html\";\r\n\r\n\r\n    export default {\r\n        setup(component) {\r\n        },\r\n        oncreate() {\r\n            const { task, row } = this.get();\r\n            task.row = row;\r\n            task.component = this;\r\n        },\r\n        ondestroy() {\r\n            const { task } = this.get();\r\n            //does automatically (?)\r\n            if(task.component === this) {\r\n                task.component = null;\r\n            }\r\n        },\r\n        onupdate({ changed, current, previous }) {\r\n            if(changed.task){\r\n                //console.log('current', current.task);\r\n                //console.log('previous', previous && previous.task);\r\n                //current.row.rowElement = this.refs.row;\r\n                current.task.component = this;\r\n            }\r\n\r\n            if(changed.task && changed.row){\r\n                current.task.row = current.row;\r\n            }\r\n        },\r\n        actions: {\r\n\t\t\tdrag(node) {\r\n                const { rowContainerElement, ganttUtils, gantt, resizeHandleWidth } = this.store.get();\r\n                const windowElement = window;\r\n\r\n                let { task } = this.get();\r\n                //update reference when tasks are loaded with new data\r\n                const listener = this.on('update', ({ changed, current, previous }) => {\r\n                    if(changed.task){\r\n                        task = current.task;\r\n                    }\r\n                });\r\n\r\n                let mouseStartPosX;\r\n                let mouseStartRight;\r\n                \r\n                let originalRow;\r\n                    \r\n                function onmousedown(event) {\r\n                    if(event.which !== 1){\r\n                        //debugger;\r\n                        return;\r\n                    }\r\n\r\n                    event.stopPropagation();\r\n                    event.preventDefault();\r\n                    \r\n                    originalRow = task.row;\r\n\r\n                    if(originalRow.model.enableDragging){\r\n                        mouseStartPosX = DOMUtils.getRelativePos(rowContainerElement, event).x - task.left;\r\n                        mouseStartRight = task.left + task.width;\r\n\r\n                        if(mouseStartPosX < resizeHandleWidth) {\r\n                            task.resizing = true;\r\n                            task.direction = 'left';\r\n                        }\r\n                        else if(mouseStartPosX > task.width - resizeHandleWidth) {\r\n                            task.resizing = true;\r\n                            task.direction = 'right';\r\n                        }\r\n                        else {\r\n                            task.dragging = true;\r\n                        }\r\n\r\n                        windowElement.addEventListener('mousemove', onmousemove, false);\r\n                        DOMUtils.addEventListenerOnce(windowElement, 'mouseup', onmouseup);\r\n                    }\r\n                }\r\n                \r\n                function onmousemove(event) {\r\n\r\n                    event.preventDefault();\r\n                    if(task.resizing) {\r\n                        const mousePos = DOMUtils.getRelativePos(rowContainerElement, event);\r\n                        \r\n                        if(task.direction === 'left') { //resize ulijevo\r\n                            if(mousePos.x > task.left + task.width) {\r\n                                task.left = mouseStartRight; //mousePos.x //\r\n                                task.width = task.left - mousePos.x;\r\n                                task.direction = 'right'\r\n                                mouseStartRight = task.left + task.width;\r\n                            }\r\n                            else{\r\n                                task.left = mousePos.x;\r\n                                task.width = mouseStartRight - mousePos.x;\r\n                            }\r\n                        }\r\n                        else if(task.direction === 'right') {//resize desno\r\n                            if(mousePos.x <= task.left) {\r\n                                task.width = task.left - mousePos.x;\r\n                                task.left = mousePos.x;\r\n                                task.direction = 'left';\r\n                                mouseStartRight = task.left + task.width;\r\n                            }\r\n                            else {\r\n                                task.width = mousePos.x - task.left;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(task.dragging) {\r\n                        const mousePos = DOMUtils.getRelativePos(rowContainerElement, event);\r\n                        task.left = mousePos.x - mouseStartPosX;\r\n                        \r\n                        //row switching\r\n                        const rowCenterX = gantt.refs.mainContainer.getBoundingClientRect().left + gantt.refs.mainContainer.getBoundingClientRect().width / 2;\r\n                        const sourceRow = task.row;\r\n\r\n                        let elements = document.elementsFromPoint(rowCenterX, event.clientY);\r\n                        let rowElement = elements.find((element) => element.classList.contains('row'));\r\n                        if(rowElement !== undefined && rowElement !== sourceRow.rowElement) {\r\n\r\n                            const { visibleRows } = gantt.store.get();\r\n                            const targetRow = visibleRows.find((r) => r.rowElement === rowElement);\r\n\r\n                            if(targetRow.model.enableDragging){\r\n                                targetRow.moveTask(task);\r\n                                \r\n                                sourceRow.component.taskRemoved();\r\n                                targetRow.component.taskAdded();\r\n                                gantt.api.tasks.raise.switchRow(task, targetRow, sourceRow);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(task.dragging || task.resizing){\r\n                        const self = task.component;\r\n\r\n                        self.updateTaskDate();\r\n                        self.updateTaskPosition();\r\n                        self.set({task});\r\n                        self.truncate();\r\n                        task.notify();\r\n                        gantt.api.tasks.raise.move(task);\r\n                    }\r\n                }\r\n\r\n                function onmouseup(event) {\r\n                    task.dragging = false;\r\n                    task.resizing = false;\r\n                    task.direction = null;\r\n                    windowElement.removeEventListener('mousemove', onmousemove, false);\r\n                    task.component.fire('taskDropped', { task });\r\n                    task.component.set({task});\r\n\r\n                    //code this better\r\n                    if(originalRow && originalRow !== task.row) {\r\n                        originalRow.component.handleOverlaps();\r\n                    }\r\n                    gantt.api.tasks.raise.moveEnd(task, task.row, originalRow);\r\n                }\r\n\r\n                node.addEventListener('mousedown', onmousedown, false);\r\n\r\n                const cursorOnMove = (e) => {\r\n                    const mouseStartPosX = DOMUtils.getRelativePos(rowContainerElement, e).x - task.left;\r\n\r\n                    //TODO globally set cursor ON mousedown\r\n                    if(mouseStartPosX < resizeHandleWidth || mouseStartPosX > task.width - resizeHandleWidth) {\r\n                        this.updateCursor('e-resize');\r\n                    }\r\n                    else{\r\n                        this.updateCursor();\r\n                    }\r\n\r\n                };\r\n                node.addEventListener('mousemove', cursorOnMove, false)\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\tupdate() {\r\n                        //ne radi??\r\n                        task = this.get().task;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tdestroy() {\r\n\t\t\t\t\t\tnode.removeEventListener('mousedown', onmousedown, false);\r\n\t\t\t\t\t\t//windowElement.removeEventListener('mousemove', onmousemove, false);\r\n\t\t\t\t\t\tnode.removeEventListener('mousemove', onmousemove, false);\r\n                        node.removeEventListener('mouseup', onmouseup, false);\r\n                        listener.cancel();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n            },\r\n            contextMenu(node){\r\n                const { gantt } = this.store.get();\r\n\r\n                if(gantt.enableContextMenu){\r\n                    const { task } = this.get();\r\n                    const options = [\r\n                        {\r\n                            label: 'Copy',\r\n                            action: () => console.log('clicked action 1 for task ', task.model.id)\r\n                        },\r\n                        {\r\n                            label: 'Clear dependencies',\r\n                            action: () => console.log('clicked action 2 for task ', task.model.id)\r\n                        }\r\n                    ];\r\n\r\n                    function onClose(event) {\r\n                        //if(!contextMenu.isTarget(e))\r\n                        gantt.menuManager.close();\r\n                    }\r\n\r\n                    node.addEventListener('mouseup', (e) => {\r\n                        if(e.which === 3){\r\n                            e.stopPropagation();\r\n                            gantt.menuManager.open(options, {x: e.x, y: e.y})\r\n\r\n                            DOMUtils.addEventListenerOnce(node, 'mousedown', onClose); //document.body\r\n                        }\r\n                    });\r\n                }\r\n                \r\n\t\t\t\treturn {\r\n\t\t\t\t\tdestroy() {\r\n                        gantt.menuManager.close();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n            },\r\n            selectable(node) {\r\n                const { gantt } = this.store.get();\r\n                const self = this;\r\n                node.addEventListener('click', (e) => {\r\n                    const { task } = this.get();\r\n                    if(e.ctrlKey){\r\n                        gantt.selectionManager.toggleSelection(task);\r\n                    }\r\n                    else{\r\n                        gantt.selectionManager.selectSingle(task);\r\n                    }\r\n\r\n                    if(task.selected){\r\n                        gantt.api.tasks.raise.select(task);\r\n                    }\r\n                });\r\n            }\r\n\t\t},\r\n        methods: {\r\n\t\t\tupdateTaskPosition() {\r\n                const { task } = this.get();\r\n                task.updatePosition();\r\n            },\r\n            updateTaskDate() {\r\n                const { task } = this.get();\r\n                task.updateDate();\r\n            },\r\n            updateCursor(cursor){\r\n                const element = this.refs.taskElement;\r\n                element.style.cursor = cursor || 'default';\r\n            },\r\n            truncate(){\r\n                const { task } = this.get();\r\n                if(!task){\r\n                    return;\r\n                }\r\n\r\n                const ganttWidth = this.store.get().width;\r\n                if(task.left + task.width > ganttWidth){\r\n                    task.truncated = true;\r\n                    task.truncatedWidth = ganttWidth - task.left;\r\n                    task.truncatedLeft = task.left;\r\n                }\r\n                /*else{\r\n                    task.truncated = false;\r\n                }*/\r\n                \r\n                else if(task.left < 0){\r\n                    task.truncated = true;\r\n                    task.truncatedLeft = 0;\r\n                    task.truncatedWidth = task.width + task.left;\r\n                }\r\n                else{\r\n                    task.truncated = false;\r\n                }\r\n            }\r\n        },\r\n\r\n        data() {\r\n            return {\r\n                task: { dragging: false }\r\n            }\r\n        }\r\n    };\r\n</script>",
    "<div class=\"context-menu\" style=\"top:{top}px;left:{left}px\" ref:contextMenu>\r\n    {#each actions as action}\r\n        <div class=\"context-option\" on:click=\"execute(event, action)\">{action.label}</div>\r\n    {/each}\r\n</div>\r\n\r\n<style>\r\n    .context-menu {\r\n        position: absolute;\r\n        background: white;\r\n        border: 1px solid #ccc;\r\n        padding: 0.25em 0;\r\n        font-size: 10px;\r\n        transition: opacity 0.4s ease 0s;\r\n        opacity: 1;\r\n        box-shadow: rgba(0, 0, 0, 0.32) 1px 1px 3px 0px;\r\n    }\r\n\r\n    .context-option:hover {\r\n        background: #eee;\r\n    }\r\n\r\n    .context-option {\r\n        cursor: default;\r\n        padding: 0.2em 1em;\r\n    }\r\n</style>\r\n<script>\r\n        export default {\r\n            oncreate(dsds) {\r\n                this.position(this.options.position);\r\n                //this.set({ actions: this.options.actions });\r\n            },\r\n            methods: {\r\n                position(point) {\r\n                    this.set({top: point.y, left: point.x});\r\n                },\r\n                execute(event, action) {\r\n                    event.stopPropagation();\r\n                    action.action();\r\n\r\n                    this.options.onactionend();\r\n                    //close();\r\n                },\r\n                close() {\r\n                    //this.refs.yolo.remove();\r\n                    this.destroy();\r\n                },\r\n                isTarget(event) {\r\n                    return this.refs.contextMenu === event.target;\r\n                }\r\n            },\r\n            data() {\r\n                return {\r\n                    actions: [],\r\n                    top: 0,\r\n                    left: 0\r\n                }\r\n            }\r\n        };\r\n</script>"
  ],
  "names": [],
  "mappings": "AAmCI,MAAM,cAAC,CAAC,AACJ,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,QAAQ,AACtB,CAAC,AAED,iBAAiB,cAAC,CAAC,AACf,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,IAAI,CAEZ,KAAK,CAAE,IAAI,CACX,QAAQ,CAAE,MAAM,AACpB,CAAC,AAED,cAAc,cAAC,CAAC,AACZ,KAAK,CAAE,IAAI,CAEX,UAAU,CAAE,UAAU,AAC1B,CAAC,AAED,eAAe,cAAC,CAAC,AAEb,QAAQ,CAAE,IAAI,AAClB,CAAC,AAED,sBAAsB,cAAC,CAAC,AACpB,QAAQ,CAAE,QAAQ,CAClB,QAAQ,CAAE,MAAM,AACpB,CAAC,AAED,QAAQ,cAAC,CAAC,AACN,QAAQ,CAAE,QAAQ,AACtB,CAAC,AAEO,CAAC,AAAE,CAAC,AACR,UAAU,CAAE,UAAU,AAC1B,CAAC;AC1DD,IAAI,eAAC,CAAC,AACF,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,UAAU,AAC1B,CAAC;ACfD,OAAO,cAAC,CAAC,AACL,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,YAAY,CACrB,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,UAAU,AAC1B,CAAC;ACCD,kBAAkB,eAAC,CAAC,AAChB,UAAU,CAAE,UAAU,CACtB,UAAU,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CAC1B,WAAW,CAAE,MAAM,CACnB,QAAQ,CAAE,MAAM,AACpB,CAAC,AAED,cAAc,eAAC,CAAC,AACZ,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,YAAY,CACrB,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,UAAU,CACtB,aAAa,CAAE,IAAI,CAEnB,UAAU,CAAE,MAAM,AACtB,CAAC;ACHD,KAAK,eAAC,CAAC,AACT,QAAQ,CAAE,QAAQ,CACZ,GAAG,CAAE,CAAC,CACN,MAAM,CAAE,CAAC,CACT,MAAM,CAAE,IAAI,CACZ,WAAW,CAAE,MAAM,CACnB,QAAQ,CAAE,MAAM,AACvB,CAAC,AAEE,gBAAgB,eAAC,CAAC,AACd,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,IAAI,CACZ,GAAG,CAAE,CAAC,AACV,CAAC,AAED,aAAa,eAAC,CAAC,AACX,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,IAAI,CACZ,GAAG,CAAE,CAAC,AACV,CAAC;AChCD,aAAa,eAAC,CAAC,AACX,QAAQ,CAAE,QAAQ,CAClB,UAAU,CAAE,KAAK,CACjB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CACtB,OAAO,CAAE,MAAM,CAAC,CAAC,CACjB,SAAS,CAAE,IAAI,CACf,UAAU,CAAE,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAChC,OAAO,CAAE,CAAC,CACV,UAAU,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,AACnD,CAAC,AAED,8BAAe,MAAM,AAAC,CAAC,AACnB,UAAU,CAAE,IAAI,AACpB,CAAC,AAED,eAAe,eAAC,CAAC,AACb,MAAM,CAAE,OAAO,CACf,OAAO,CAAE,KAAK,CAAC,GAAG,AACtB,CAAC"
}