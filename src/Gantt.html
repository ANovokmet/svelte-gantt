<div class="gantt {$classes}" ref:ganttElement>
    {#each _ganttTableModules as module (module.key)}
        <svelte:component this={module} {rowContainerHeight} {paddingTop} {paddingBottom} on:init="initModule(event.module)" {visibleRows}/>
    {/each}

    <div class="main-header-container" ref:sideContainer>
        <div class="header-intermezzo" style="width:{$headerWidth}px;" use:horizontalScrollListener >
            <div class="header-container" style="width:{$width}px">
                {#each $headers as header}
                    <ColumnHeader header={header}/>
                {/each}
                {#each $_timeRanges as timeRange (timeRange.id)}
                    <TimeRangeHeader timeRange={timeRange}/>
                {/each}
            </div>
        </div>
    </div>

    <div class="main-container" style="height:{$height}px" use:scrollable ref:mainContainer on:mousewheel="onwheel(event)" bind:clientWidth="$cw">
        <div class="content" style="width:{$width}px">
            <div class="column-container">
                {#each columns as column}
                    <Column {...column}/>
                {/each}
            </div>
            <div class="row-container" 
                ref:rowContainer style="height:{rowContainerHeight}px;">
                <!--padding-bottom:{paddingBottom}px;padding-top:{paddingTop}px; -->
                <div style="transform: translateY({paddingTop}px);">
                {#each visibleRows as row (row.model.id)}
                    <Row row={row}
                        on:updateVisibleRows="updateViewport()"/>
                {/each}
                </div>
            </div>
                <div class="s-g-foreground">
                    {#each $_timeRanges as timeRange (timeRange.id)}
                        <TimeRange timeRange={timeRange}/>
                    {/each}

                    {#each visibleTasks as task (task.model.id)}
                        <TaskComponent model={task.model}
                            left={task.left} 
                            width={task.width}
                            height={task.height}
                            widthT={task.widthT}
                            posX={task.posX}
                            posY={task.posY}/>
                    {/each}
                </div>
            {#each _ganttBodyModules as module (module.key)}
                <svelte:component this={module} on:init="initModule(event.module)" />
            {/each}
        </div>
    </div>
</div>

<style>
    .gantt {
        width: 100%;
        height: 100%;
        position: relative;
    }

    .s-g-foreground {
        box-sizing: border-box;
        overflow: hidden;
        top: 0;
        left: 0;
        position: absolute;
        width: 100%;
        height: 100%;
    }

    .column-container {
        position: absolute;
        height: 100%;
        width: 100%;
        float: left;
        overflow: hidden;
    }

    .row-container {
        width: 100%;
        /* display: inline-block; */
        box-sizing: border-box;
        overflow: hidden;
    }

    .main-container {
        /* position: relative; */
        overflow: auto;
    }

    .main-header-container {
        position: relative;
        overflow: hidden;
    }

    .header-container {
        position: relative;
    }

    .header-intermezzo {
        overflow:hidden;
    }

    .content {
        position: relative;
    }

    :global(*) {
        box-sizing: border-box;
    }
</style>

<script>
    import Row from './Row.html';
    import TaskComponent from './Task.html';
    import Column from './Column.html';
    import ColumnHeader from './ColumnHeader.html';
    import { Store } from 'svelte/store.js';
    import SelectionManager from './utils/selectionManager';
    import { GanttUtils, getPositionByDate } from './utils/utils';
    import GanttApi from './core/api';
    import TimeRange from './TimeRange.html';
    import TimeRangeHeader from './TimeRangeHeader.html';

    import Task from "./Task.html";
    import { SvelteTask } from "./core/task";
    import { SvelteRow } from "./core/row";
    import { SvelteTimeRange } from "./core/timeRange";

    //import GanttDependencies from './modules/dependencies/GanttDependencies.html';
    //import Table from './modules/table/Table.html';
    import { GanttStore } from "./store";


    let SvelteGantt;

    export default {
        setup(component){
            SvelteGantt = component;
            SvelteGantt.defaults = {
                // datetime timeline starts on, currently moment-js object
                from: null,
                // datetime timeline ends on, currently moment-js object
                to: null,
                // width of main gantt area in px
                width: 800, //rename to timelinewidth
                // should timeline stretch width to fit, true overrides timelineWidth
                stretchTimelineWidthToFit: false,
                // height of main gantt area in px
                height: 400,
                // minimum unit of time task date values will round to 
                magnetUnit: 'minute',
                // amount of units task date values will round to
                magnetOffset: 15,
                // duration unit of columns
                columnUnit: 'minute',
                // duration width of column
                columnOffset: 15,
                // list of headers used for main gantt area
                // unit: time unit used, e.g. day will create a cell in the header for each day in the timeline
                // format: datetime format used for header cell label
                headers: [{unit: 'day', format: 'DD.MM.YYYY'}, {unit: 'hour', format: 'HH'}],
                // height of a single row in px
                rowHeight: 52,
                // modules used in gantt
                modules: [],
                // enables right click context menu
                enableContextMenu: false,
                // sets top level gantt class which can be used for styling
                classes: '',
                // width of handle for resizing task
                resizeHandleWidth: 10,
                // handler of button clicks
                onTaskButtonClick: null, // e.g. (task) => {debugger},
                // task content factory function
                taskContent: null, // e.g. (task) => '<div>Custom task content</div>'

                rows: [],
                tasks: [],
                _timeRanges: []
            };

            SvelteGantt.create = function(target, data, options) {

                // bind gantt modules
                const ganttModules = {
                    ganttBodyModules: [],
                    ganttTableModules: [],
                    defaults: {}
                }

                if(options.modules) {
                    options.modules.forEach((module) => {
                        module.bindToGantt(ganttModules);
                    })
                }

                // initialize gantt state
                const newData = {
                    initialRows: data.rows,
                    initialTasks: data.tasks,
                    initialDependencies: data.dependencies,
                    _ganttBodyModules: ganttModules.ganttBodyModules,
                    _ganttTableModules: ganttModules.ganttTableModules
                };

                // initialize all the gantt options
                const ganttOptions = Object.assign({}, SvelteGantt.defaults, ganttModules.defaults, options);
                
                const store = new GanttStore(ganttOptions);

                // store.compute(
                //     'paddingTop',
                //     ['startIndex', 'rowHeight'],
                //     (startIndex, rowHeight) => startIndex * rowHeight
                // );

                // store.compute(
                //     'paddingBottom',
                //     ['rows', 'endIndex', 'rowHeight'],
                //     (rows, endIndex, rowHeight) => (rows.length - endIndex - 1) * rowHeight
                // );

                // store.compute(
                //     'startIndex',
                //     ['scrollTop', 'rowHeight'],
                //     (scrollTop, rowHeight) => Math.floor(scrollTop / rowHeight)
                // );
                
                // store.compute(
                //     'endIndex',
                //     ['startIndex', 'viewportHeight', 'rowHeight', 'rows'],
                //     (startIndex, viewportHeight, rowHeight, rows) => Math.min(startIndex + Math.ceil(viewportHeight / rowHeight ), rows.length - 1)
                // );

                return new SvelteGantt({
                    target,
                    data: newData,
                    store
                });
            }
        },
        components: { Row, Column, ColumnHeader, TaskComponent, TimeRange, TimeRangeHeader },
        oncreate(){
            const {rows, initialRows, initialTasks, initialDependencies} = this.get();

            this.initGantt();
            
            this.initRows(initialRows);
            window.addEventListener('resize', this.onWindowResizeEventHandler.bind(this)); // or this.onW... .bind(this);
            this.recalculateGanttDimensions();

            this.initTasks(initialTasks);
            
            this.broadcastModules('onGanttCreated');
            this.updateViewport();
        },
        ondestroy(){
            //remove event listener
            window.removeEventListener('resize', this.onWindowResizeEventHandler)
        },
        actions: {
            scrollable(node){
                const { scrollables } = this.get();

                const onscroll = (event) => {
                    const scrollAmount = node.scrollTop; 
                    for(let i=0; i< scrollables.length; i++){
                        const scrollable = scrollables[i];
                        if(scrollable.orientation === 'horizontal') {
                            scrollable.node.scrollLeft = node.scrollLeft;
                        }
                        else {
                            scrollable.node.scrollTop = scrollAmount;
                        }
                    }
                    //TODO: only for vertical scroll
                    this.set({scrollTop: scrollAmount, clientHeight: node.clientHeight});
                    this.store.set({scrollTop: scrollAmount, clientHeight: node.clientHeight});

                    this.broadcastModules('updateVisible', {scrollAmount, viewportHeight: node.clientHeight});
                }

                node.addEventListener('scroll', onscroll);
                return {
					destroy() {
						node.removeEventListener('scroll', onscroll, false);
					}
                }
            },
            horizontalScrollListener(node){
                const { scrollables } = this.get();
                scrollables.push({node, orientation: 'horizontal'});
            }
		},
        methods: {
            onwheel(e){
                console.log('skrol',e);
                if(e.ctrlKey){
                e.preventDefault();
                    const { width } = this.store.get();
                    if(event.deltaY > 0) {
                        this.store.set({width: width - 100});
                    }else {
                        this.store.set({width: width + 100});
                    }
                    this.refreshTasks();
                }
            },
            onWindowResizeEventHandler(event){
                this.recalculateGanttDimensions();
                if(this.store.get().stretchTimelineWidthToFit){
                    this.refreshTasks();
                }
            },
            recalculateGanttDimensions() {
                const parentWidth = this.refs.ganttElement.clientWidth;
                const parentHeight = this.refs.ganttElement.clientHeight;
                
                this.store.set({parentWidth});
                
                const tableWidth = this.store.get().tableWidth || 0;

                const height = parentHeight - this.refs.sideContainer.clientHeight;

                // -17 only if side scrollbar shows (rowContainerHeight > height)
                const { rowContainerHeight } = this.get();
                const headerWidth = rowContainerHeight > height ? parentWidth - tableWidth - 17 :  parentWidth - tableWidth;

                this.store.set({
                    height, headerWidth
                });

                if(this.store.get().stretchTimelineWidthToFit){
                    this.store.set({width: headerWidth});
                }
            },
            initRows(rowsData){
                const rows = [];
                const _rowCache = {};
                let y = 0;
                for(let i=0; i < rowsData.length; i++){
                    const currentRow = rowsData[i];
                    const row = new SvelteRow(this, currentRow);
                    rows.push(row);
                    _rowCache[row.model.id] = row;
                    row.posY = y;
                    y += row.height;

                    //this.store.addRow(row);
                }
                this.set({
                    _rowCache,
                    rows
                });
                this.store.addAllRow(rows);
                this.store.set({rows});
            },
            initTasks(taskData){
                const _allTasks = [];
                const tasks = _allTasks;
                const _taskCache = {};

                for(let i=0; i < taskData.length; i++){
                    const currentTask = taskData[i];
                    const task = new SvelteTask(this, currentTask);
                    _allTasks.push(task);
                    _taskCache[task.model.id] = task;
                }

                this.set({
                    _allTasks,
                    _taskCache,
                    tasks,
                });

                this.store.addAllTask(_allTasks);
                this.store.set({tasks, _taskCache});
                this.selectionManager.clearSelection();
            },
            initTimeRanges(timeRangeData){
                const _timeRanges = [];
                const _timeRangeCache = [];

                for(let i = 0; i < timeRangeData.length; i++){
                    const currentTimeRange = timeRangeData[i];
                    const timeRange = new SvelteTimeRange(this, currentTimeRange);
                    _timeRanges.push(timeRange);
                    _timeRangeCache[currentTimeRange.id] = timeRange;
                }

                this.store.set({_timeRanges, _timeRangeCache})
            },
            initGantt(){
                if(!this.store.get().gantt){
                    this.store.set({
                        bodyElement: this.refs.mainContainer, 
                        rowContainerElement: this.refs.rowContainer,
                        gantt: this
                    });
                    
                    this.selectionManager = new SelectionManager(this.store);
                    this.utils = new GanttUtils(this);
                    this.api = new GanttApi(this);

                    this.api.registerEvent('tasks', 'move');
                    this.api.registerEvent('tasks', 'select');
                    this.api.registerEvent('tasks', 'switchRow');
                    this.api.registerEvent('tasks', 'moveEnd');
                    this.api.registerEvent('tasks', 'changed');

                    this.row = SvelteRow;
                    this.task = SvelteTask;
                }
            },
            initModule(module){
                const moduleOptions = Object.assign({
                    _gantt: this,
                    _options: this.get()
                }, {});//merge with module specific data, modules[module.constructor.key]);
                module.initModule(moduleOptions);
                
                const {_modules} = this.get();
                _modules.push(module);
            },
            broadcastModules(event, data) {
                const {_modules} = this.get();
                _modules.forEach((module) => {
                    if (typeof module[event] === 'function') {
                        module[event](data);
                    }
                });
            },
            updateVisibleEntities(){
                const { _timeRanges } = this.store.get();
                _timeRanges.forEach(timeRange => {
                    timeRange.updatePosition();
                    timeRange.updateView();
                });
            },
            updateViewport(){
                const {scrollTop, clientHeight} = this.refs.mainContainer;
                this.store.set({scrollTop, viewportHeight: clientHeight});
                this.set({scrollTop, viewportHeight: clientHeight});
                this.broadcastModules('updateVisible', {scrollAmount: scrollTop, viewportHeight: clientHeight});
            },
            getPositionByDate(){

            },
            refreshTasks(){
                const { _allTasks } = this.get();
                _allTasks.forEach(task => {
                    task.updatePosition();
                    task.updateView();
                });
                this.store.set({taskMap: this.store.get().taskMap});
                this.updateVisibleEntities();
            },
            updateView(options){ // {from, to, headers, width}
                this.store.set(options);
                if(this.store.get().stretchTimelineWidthToFit){
                    this.recalculateGanttDimensions();
                }

                this.refreshTasks();

                this.broadcastModules('updateView', options);//{ from, to, headers });
            },
            selectTask(id) {
                const { _taskCache } = this.get();
                const task = _taskCache[id];
                if(task) {
                    this.selectionManager.selectSingle(task);
                    task.updateView();
                }
            }
        },
        data() {
            return {
                columns: [],
                scrollables: [],
                visibleRows: [],
                visibleTasks: [],
                _ganttBodyModules: [],
                _ganttTableModules: [],
                _modules: [],

                _allTasks: [],
                rows: [],

                paddingTop: 0,
                paddingBottom: 0,
                scrollTop: 0
            }
        },
        computed: {
            // exctract to columns component
            columnWidth: ({$from, $to, $width, $columnOffset, $columnUnit}) => getPositionByDate($from.clone().add($columnOffset, $columnUnit), $from, $to, $width),
            columnCount: ({$width, columnWidth}) => Math.ceil($width / columnWidth),
            columns: ({$from, columnWidth, columnCount, $columnOffset, $columnUnit, $to, $width}) => {
                const columns = [];
                const columnFrom = $from.clone();
                for(let i = 0; i < columnCount; i++){
                    columns.push({width: columnWidth, from: columnFrom.clone(), left: getPositionByDate(columnFrom, $from, $to, $width)});
                    columnFrom.add($columnOffset, $columnUnit);
                }
                return columns;
            },

            rowContainerHeight: ({$rows, $rowHeight}) => $rows.length * $rowHeight,
            startIndex: ({scrollTop, $rowHeight}) => Math.floor(scrollTop / $rowHeight),
            endIndex: ({startIndex, viewportHeight, $rowHeight, $rows}) => Math.min(startIndex + Math.ceil(viewportHeight / $rowHeight ), $rows.length - 1),
            paddingTop: ({startIndex, $rowHeight}) => startIndex * $rowHeight,
            paddingBottom: ({$rows, endIndex, $rowHeight}) => ($rows.length - endIndex - 1) * $rowHeight,

            visibleRows: ({$rows, startIndex, endIndex}) => $rows.slice(startIndex, endIndex + 1),
            visibleTasks: ({$taskMap, visibleRows, rowTaskMap}) => {
                const visibleTasks = [];
                visibleRows.forEach(row => {
                    if(!rowTaskMap[row.model.id])
                        return;

                    rowTaskMap[row.model.id].forEach(id => {
                        visibleTasks.push($taskMap[id]);
                    });
                });
                return visibleTasks;
            },
            rowTaskMap: ({_allTasks, $taskMap}) => {
                const reducer = (cache, task) => {
                    if(!cache[task.model.resourceId])
                        cache[task.model.resourceId] = [];

                    cache[task.model.resourceId].push(task.model.id);
                    return cache;
                }
                console.log('recaculated map');
                return _allTasks.reduce(reducer, {});
            },

        }
    };
</script>