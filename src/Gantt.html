<div class="gantt {$classes}" use:disableContextMenu ref:ganttElement>
    {#each _ganttTableModules as module (module.key)}
        <svelte:component this={module} on:init="initModule(event.module)" {visibleRows}/>
    {/each}

    <div class="main-header-container" ref:sideContainer>
        <div class="header-intermezzo" style="width:{$headerWidth}px;" use:horizontalScrollListener >
            <div class="header-container" style="width:{$width}px">
                {#each $headers as header}
                    <ColumnHeader header={header}/>
                {/each}
            </div>
        </div>
    </div>

    <div class="main-container" style="height:{$height}px" use:scrollable ref:mainContainer>
        <div class="content" style="width:{$width}px">
            <div class="column-container">
                {#each columns as column}
                    <Column {...column}/>
                {/each}
            </div>
            <div class="row-container" 
                ref:rowContainer>
                <!-- style="padding-top:{paddingTop}px;padding-bottom:{paddingBottom}px;height:{rowContainerHeight}px;" -->
                {#each $rows as row (row.model.id)}
                    <Row row={row}
                        on:updateVisibleRows="updateViewport()"/>
                {/each}
                {#each $tasks as task (task.model.id)}
                    <TaskComponent task={task}/>
                {/each}
            </div>
            {#each _ganttBodyModules as module (module.key)}
                <svelte:component this={module} on:init="initModule(event.module)" />
            {/each}
        </div>
    </div>
</div>

<style>
    .gantt {
        width: 100%;
        height: 100%;
        position: relative;
    }

    .column-container {
        position: absolute;
        height: 100%;
        width: 100%;
        float: left;
        overflow: hidden;
    }

    .row-container {
        width: 100%;
        /* display: inline-block; */
        box-sizing: border-box;
        overflow: hidden;
    }

    .main-container {
        /* position: relative; */
        overflow: auto;
    }

    .main-header-container {
        position: relative;
        overflow: hidden;
    }

    .header-intermezzo {
        overflow:hidden;
    }

    .content {
        position: relative;
    }

    :global(*) {
        box-sizing: border-box;
    }
</style>

<script>
    import Row from './Row.html';
    import TaskComponent from './Task.html';
    import Column from './Column.html';
    import ColumnHeader from './ColumnHeader.html';
    import { Store } from 'svelte/store.js';
    import ContextMenuManager from './contextMenuManager.js'
    import SelectionManager from './selectionManager.js';
    import GanttUtils from './utils.js';
    import GanttApi from './api.js';

    import Task from "./Task.html";
    import { SvelteTask } from "./task.js";
    import { SvelteRow } from "./row.js";

    //import GanttDependencies from './modules/dependencies/GanttDependencies.html';
    //import Table from './modules/table/Table.html';

    let SvelteGantt;

    export default {
        setup(component){
            SvelteGantt = component;
            SvelteGantt.defaults = {
                // datetime timeline starts on, currently moment-js object
                from: null,
                // datetime timeline ends on, currently moment-js object
                to: null,
                // width of main gantt area in px
                width: 800, //rename to timelinewidth
                // should timeline stretch width to fit, true overrides timelineWidth
                stretchTimelineWidthToFit: false,
                // height of main gantt area in px
                height: 400,
                // minimum unit of time task date values will round to 
                magnetUnit: 'minute',
                // amount of units task date values will round to
                magnetOffset: 15,
                // duration unit of columns
                columnUnit: 'minute',
                // duration width of column
                columnOffset: 15,
                // list of headers used for main gantt area
                // unit: time unit used, e.g. day will create a cell in the header for each day in the timeline
                // format: datetime format used for header cell label
                headers: [{unit: 'day', format: 'DD.MM.YYYY'}, {unit: 'hour', format: 'HH'}],
                // height of a single row in px
                rowHeight: 24,
                // modules used in gantt
                modules: [],
                // enables right click context menu
                enableContextMenu: false,
                // sets top level gantt class which can be used for styling
                classes: '',
                // width of handle for resizing task
                resizeHandleWidth: 5,
                // handler of button clicks
                onTaskButtonClick: null, // e.g. (task) => {debugger},
                // task content factory function
                taskContent: null, // e.g. (task) => '<div>Custom task content</div>'

                rows: [],
                tasks: []
            };

            SvelteGantt.create = function(target, data, options) {

                // bind gantt modules
                const ganttModules = {
                    ganttBodyModules: [],
                    ganttTableModules: [],
                    defaults: {}
                }

                if(options.modules) {
                    options.modules.forEach((module) => {
                        module.bindToGantt(ganttModules);
                    })
                }

                // initialize gantt state
                const newData = {
                    initialRows: data.rows,
                    initialTasks: data.tasks,
                    initialDependencies: data.dependencies,
                    _ganttBodyModules: ganttModules.ganttBodyModules,
                    _ganttTableModules: ganttModules.ganttTableModules
                };

                // initialize all the gantt options
                const ganttOptions = Object.assign({}, SvelteGantt.defaults, ganttModules.defaults, options);
                
                const store = new Store();
                store.set(ganttOptions);

                return new SvelteGantt({
                    target,
                    data: newData,
                    store
                });
            }
        },
        components: { Row, Column, ColumnHeader, TaskComponent },
        oncreate(){
            this.initGantt();
            
            const {rows, initialRows, initialTasks, initialDependencies} = this.get();
            this.initData({
                rows: initialRows, 
                dependencies: initialDependencies,
                tasks: initialTasks
            });
            this.initColumns();

            // // ag-grid uses an event for all the elements
            // this.refs.mainContainer.addEventListener('mouseup', function(event){
            //     console.log('mouse up on ', event.target);
            // });

            this.onWindowResizeHandler = (event) => {
                const parentWidth = this.refs.ganttElement.clientWidth;
                const parentHeight = this.refs.ganttElement.clientHeight;
                
                this.store.set({parentWidth});
                
                const stretchWidth = this.store.get().stretchTimelineWidthToFit;
                const tableWidth = this.store.get().tableWidth || 0;

                const height = parentHeight - this.refs.sideContainer.clientHeight;

                // -17 only if side scrollbar shows (rowContainerHeight > height)
                const { rowContainerHeight } = this.get();
                const headerWidth = rowContainerHeight > height ? parentWidth - tableWidth - 17 :  parentWidth - tableWidth;

                if(stretchWidth){
                    this.store.set({width: headerWidth});
                }

                this.store.set({
                    height, headerWidth
                });

                if(stretchWidth){
                    this.initColumns();
                }
            };

            window.addEventListener('resize', this.onWindowResizeHandler); // or this.onW... .bind(this);
            this.onWindowResizeHandler(null);
            
            this.broadcastModules('onGanttCreated');
            this.updateViewport();
        },
        ondestroy(){
            //remove event listener
            window.removeEventListener('resize', this.onWindowResizeHandler)
        },
        actions: {
            disableContextMenu(node) {
                if(this.store.get().enableContextMenu){
                    node.addEventListener('contextmenu', function(e) {
                        e.preventDefault();
                    }, false);
                    //ovo dolje radi kad stvori≈° svelte contextmenu, klikne na sam contextmenu TO DO remove
                    document.addEventListener('contextmenu', function(e) {
                        e.preventDefault();
                    }, false);
                }
            },
            scrollable(node){
                const { scrollables } = this.get();
                const self = this;

                function onscroll(event) {
                    const scrollAmount = node.scrollTop; 
                    for(let i=0; i< scrollables.length; i++){
                        const scrollable = scrollables[i];
                        if(scrollable.orientation === 'horizontal') {
                            scrollable.node.scrollLeft = node.scrollLeft;
                        }
                        else {
                            scrollable.node.scrollTop = scrollAmount;
                        }
                    }
                    //TODO: only for vertical scroll
                    self.updateVisibleRows(scrollAmount, node.clientHeight);

                    self.broadcastModules('updateVisible', {scrollAmount, viewportHeight: node.clientHeight});
                }

                node.addEventListener('scroll', onscroll);
                return {
					destroy() {
						node.removeEventListener('scroll', onscroll, false);
					}
                }
            },
            scrollListener(node){
                const { scrollables } = this.get();
                scrollables.push({node});
            },
            horizontalScrollListener(node){
                const { scrollables } = this.get();
                scrollables.push({node, orientation: 'horizontal'});
            }
		},
        methods: {
            initData(data){
                const rows = [];
                const _allTasks = [];
                const tasks = _allTasks;
                const _taskCache = {};
                const _rowCache = {};

                for(let i=0; i < data.rows.length; i++){
                    const currentRow = data.rows[i];
                    const row = new SvelteRow(this, currentRow);
                    rows.push(row);
                    _rowCache[row.model.id] = row;
                }

                for(let i=0; i < data.tasks.length; i++){
                    const currentTask = data.tasks[i];
                    const task = new SvelteTask(this, currentTask, null);
                    _allTasks.push(task);
                    _taskCache[task.model.id] = task;
                }

                this.set({
                    _allTasks,
                    _rowCache,
                    _taskCache,
                    tasks,
                    rows
                });
                this.store.set({rows, tasks});
                this.selectionManager.clearSelection();
                this.broadcastModules('initData', data);
                this.updateViewport();
            },
            initGantt(){
                if(!this.store.get().gantt){
                    this.store.set({
                        bodyElement: this.refs.mainContainer, 
                        rowContainerElement: this.refs.rowContainer,
                        gantt: this
                    });
                    
                    this.menuManager = new ContextMenuManager(this);
                    this.selectionManager = new SelectionManager();
                    this.utils = new GanttUtils(this);
                    this.api = new GanttApi(this);

                    this.api.registerEvent('tasks', 'move');
                    this.api.registerEvent('tasks', 'select');
                    this.api.registerEvent('tasks', 'switchRow');
                    this.api.registerEvent('tasks', 'moveEnd');
                    this.api.registerEvent('tasks', 'changed');

                    this.row = SvelteRow;
                    this.task = SvelteTask;
                }
            },
            initModule(module){
                const moduleOptions = Object.assign({
                    _gantt: this,
                    _options: this.get()
                }, {});//merge with module specific data, modules[module.constructor.key]);
                module.initModule(moduleOptions);
                
                const {_modules} = this.get();
                _modules.push(module);
            },
            broadcastModules(event, data) {
                const {_modules} = this.get();
                _modules.forEach((module) => {
                    if (typeof module[event] === 'function') {
                        module[event](data);
                    }
                });
            },
            updateVisibleRows(scrollTop, viewportHeight){
                const { rows, rowHeight } = this.store.get();

                let startIndex = Math.floor(scrollTop / rowHeight);
                let endIndex = Math.min(startIndex + Math.ceil(viewportHeight / rowHeight ), rows.length - 1);

                const paddingTop = startIndex * rowHeight;
                const paddingBottom = (rows.length - endIndex - 1) * rowHeight;

                const visibleRows = rows.slice(startIndex, endIndex + 1);

                //only horizontal scroll
                /*visibleRows.forEach(row => {
                    row.visibleTasks = this.visibleTasks(row);
                });*/

                const visibleTasks = []
                visibleRows.forEach(row => {
                    Array.prototype.push.apply(visibleTasks, row.tasks);
                });
                this.set

                this.set({ visibleRows, paddingTop, paddingBottom, visibleTasks });
                this.store.set({ visibleRows, paddingTop, paddingBottom, visibleTasks });
            },
            visibleTasks(row){
                const scrollLeft = this.refs.mainContainer.scrollLeft;
                const clientWidth = this.refs.mainContainer.clientWidth;
                //finish this
                //this.store.set({scrollLeft, clientWidth});

                //da su sortirani -> index prvog, zadnjeg, i onda slice
                //da su sortirani -> nakon zadnjeg break
                const visibleTasks = [];
                row.tasks.forEach(task => {
                    if(!(task.left + task.width < scrollLeft || task.left > scrollLeft + clientWidth)){
                        visibleTasks.push(task);
                    }
                });
                console.log(visibleTasks.length);
                return visibleTasks;
            },
            updateViewport(){
                const {scrollTop, clientHeight} = this.refs.mainContainer;

                this.updateVisibleRows(scrollTop, clientHeight);
                this.broadcastModules('updateVisible', {scrollAmount: scrollTop, viewportHeight: clientHeight});
            },
            initColumns() {
                const {columnOffset, columnUnit, from, width, headers} = this.store.get();
                const columnWidth = this.utils.getPositionByDate(from.clone().add(columnOffset, columnUnit));
                const columnCount = Math.ceil((width) / columnWidth) 

                const columns = [];
                const columnFrom = from.clone();
                for(let i = 0; i < columnCount; i++){
                    columns.push({width: columnWidth, from: columnFrom.clone(), left: this.utils.getPositionByDate(columnFrom)});
                    columnFrom.add(columnOffset, columnUnit);
                }

                const {_allTasks} = this.get();
                _allTasks.forEach(task => {
                    task.updatePosition();
                    task.truncate();
                    task.updateView();
                });
                this.broadcastModules('updateView', {});

                this.set({ columns });
                this.store.set({ headers });
            },
            updateView(options){ // {from, to, headers, width}
                this.store.set(options);
                if(this.store.get().stretchTimelineWidthToFit){
                    this.onWindowResizeHandler(null);
                }
                else{
                    this.initColumns();
                }

                const { _allTasks } = this.get();
                _allTasks.forEach(task => {
                    task.updatePosition();
                    task.updateView();
                });

                const { rows } = this.store.get();
                rows.forEach(row => {
                    if(row.component)
                        row.component.updateVisible();
                });

                this.broadcastModules('updateView', options);//{ from, to, headers });
            },
            selectTask(id) {
                const { _taskCache } = this.get();
                const task = _taskCache[id];
                if(task) {
                    this.selectionManager.selectSingle(task);
                    task.updateView();
                }
            }
        },
        data() {
            return {
                columns: [],
                scrollables: [],
                visibleRows: [],
                visibleTasks: [],
                _ganttBodyModules: [],
                _ganttTableModules: [],
                _modules: [],

                rows: [],

                paddingTop: 0,
                paddingBottom: 0
            }
        },
        computed: {
            rowContainerHeight: ({rows, $rowHeight}) => rows.length * $rowHeight
        }
    };
</script>