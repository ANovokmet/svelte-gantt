<div class="row {row.model.classes}" ref:row style="height:{$rowHeight}px" use:contextMenu>
    {#each row.tasks as task (task.model.id)}
        <Task   row={row}
                task={task}  
                on:updateVisibleRows 
                on:taskMoved="taskMoved()"
                on:taskMovedRow="taskAdded()"
                on:taskRemovedRow="taskRemoved()"
                on:taskResized="taskMoved()"
                on:taskDropped="taskDropped(task)"/>
    {/each}
    {#if row.model.contentHtml}
        {@html row.model.contentHtml}
    {/if}
</div>
<style>
    .row {
        position: relative;
        width: 100%;
        box-sizing: border-box;
    }
</style>
<script>
    import Task from './Task.html';
    import ContextMenu from "./ContextMenu.html";
    import { DOMUtils } from "./domUtils.js";

    export default {
        components: { Task },
        oncreate() {
            const { row } = this.get();
            row.rowElement = this.refs.row;
            row.component = this;

            if(!row.classes){ //default
                row.classes = [];
            }
        },
        onupdate({ changed, current, previous }) {
            if(changed.row){
                current.row.rowElement = this.refs.row;
                current.row.component = this;
            }
        },
        ondestroy(){
            const { row } = this.get();
            row.rowElement = null;
            row.component = null;
        },
        methods: {
            taskMoved() {
                console.log('Task moved')
                const { row } = this.get();
                this.set({ row });
            },
            taskAdded() {
                //when task moving to row, need to update row to show new task
                const { row } = this.get();
                console.log('Task moved to row', row);
                this.set({ row });
            },
            taskRemoved() {
                const { row } = this.get();
                console.log('Task removed from row', row);
                this.set({ row });
            },
            taskDropped(task) {
                this.handleOverlaps();
            },
            handleOverlaps(){
                this.sortTasks();
                const { row } = this.get();
                const overlaps = [];
                let previous = row.tasks[0];
                for(let i = 1; i < row.tasks.length; i++){
                    const current = row.tasks[i];

                    if(current.overlaps(previous))
                    {
                        if(current.overlapping !== true){
                            current.overlapping = true;
                            current.component.set({ task: current });
                        }
                        if(previous.overlapping !== true){
                            previous.overlapping = true;
                            previous.component.set({ task: previous });
                        }

                        if(overlaps.indexOf(current.id) === -1){
                            overlaps.push(current.id);
                        }

                        if(overlaps.indexOf(previous.id) === -1){
                            overlaps.push(previous.id);
                        }
                    }

                    if (previous.left + previous.width < current.left + current.width) {
                        previous = current;
                    }
                }

                for(let i = 0; i < row.tasks.length; i++){
                    const current = row.tasks[i];
                    if(overlaps.indexOf(current.id) === -1){
                        if(!!current.overlapping) {
                            current.overlapping = false;
                            current.component.set({ task: current });
                        }
                    }
                }
            },
            sortTasks() {
                const { row } =  this.get();
                row.tasks.sort(function (a, b) {
                    if (a.left < b.left) {
                        return -1
                    } else if (a.left > b.left) {
                        return 1
                    }
                    return 0
                });
            },
            updateVisible(){
                const { row } = this.get();

                const visibleTasks = this.visibleTasks(row);
                this.set({visibleTasks});
            },
            visibleTasks(row){
                const { gantt, from, to } = this.store.get();
                const scrollLeft = gantt.refs.mainContainer.scrollLeft;
                const clientWidth = gantt.refs.mainContainer.clientWidth;
                //finish this
                //this.store.set({scrollLeft, clientWidth});

                //da su sortirani -> index prvog, zadnjeg, i onda slice
                //da su sortirani -> nakon zadnjeg break
                const visibleTasks = [];
                row.tasks.forEach(task => {
                    if(!(task.to < from || task.from > to)){
                        visibleTasks.push(task);
                    }
                });
                console.log(visibleTasks.length);
                return visibleTasks;
            }
        },
        actions: {
            contextMenu(node){
                const { gantt } = this.store.get();

                if(gantt.enableContextMenu){
                    const { row } = this.get();
                    const options = [
                        {
                            label: 'Copy row',
                            action: () => console.log('clicked action 1 for task ', row.id)
                        },
                        {
                            label: 'Clear dependencies',
                            action: () => console.log('clicked action 2 for task ', row.id)
                        }
                    ];

                    function onClose(event) {
                        //if(!contextMenu.isTarget(e))
                        gantt.menuManager.close();
                    }

                    node.addEventListener('mouseup', (e) => {
                        //e.stopPropagation();
                        if(e.which === 3){
                            gantt.menuManager.open(options, {x: e.x, y: e.y});

                            DOMUtils.addEventListenerOnce(node, 'mousedown', onClose); //document.body
                        }
                    });
                }
                
                return {
                    destroy() {
                        gantt.menuManager.close();
                    }
                }
            }
        }
    };
</script>