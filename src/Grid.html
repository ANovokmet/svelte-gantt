<div class="grid">

    <div class="side-header-container" style="height:{$headerHeight}px;width:100px">
    
    </div>

    <div class="main-header-container" style="height:{$headerHeight}px;width:{$width}px">
        {#each $headers as header}
            <ColumnHeader header={header}/>
        {/each}
    </div>

    <div class="side-container" style="height:{$height}px" use:scrollListener>
        <div class="row-header-container" style="padding-top:{paddingTop}px;padding-bottom:{paddingBottom}px;height:{rowContainerHeight}px;"> 
            {#each visibleRows as row (row.id)}
                <RowHeader 
                    bind:label=row.label/>
            {/each}
        </div>
    </div>

    <div class="main-container" style="height:{$height}px;width:{$width}px" use:scrollable ref:rowContainer>
        <div class="content">
            

            <div class="column-container">
                {#each columns as column}
                    <Column width={column.width}/>
                {/each}
            </div>    
            <div class="row-container" style="padding-top:{paddingTop}px;padding-bottom:{paddingBottom}px;height:{rowContainerHeight}px;">
                {#each visibleRows as row}
                    <Row 
                    row={row}
                    bind:tasks=row.tasks
                        width={width}
                        on:updateVisibleRows="updateViewport()"/>
                {/each}
            </div>

            <div class="dependency-container">
                {#each dependencies as dependency}
                    <Dependency 
                    bind:fromTask=dependency.fromTask 
                    bind:toTask=dependency.toTask/>
                {/each}
            </div>
        </div>
    </div>

</div>

<style>
    .grid {
        position: relative;
        
        font-family: tahoma, arial, verdana, Sans-serif;
        font-size: 10px;
        color: #656565;
    }

    .column-container {
        position: absolute;
        height: 100%;

        float: left;
        overflow: hidden;
    }

    .dependency-container {
        position: absolute;
        width: 100%;
        height: 100%;
        
        pointer-events: none;
        top: 0;
        float: left;
        overflow: hidden;
    }

    .row-container {
        width: 100%;
        /* display: inline-block; */
        box-sizing: border-box;
    }

    .row-header-container {
        
        box-sizing: border-box;
    }


    .side-container {
        width: 100px;
        float: left;
        overflow-y: hidden;
    }

    .main-container {
        /* position: relative; */
        overflow: auto;
    }

    .side-header-container {
        float: left;
    }

    .main-header-container {
        position: relative;
        overflow: hidden;
    }

    .content {
        position: relative;
    }
</style>

<script>
    import Row from './Row.html';
    import RowHeader from './RowHeader.html';
    import Column from './Column.html';
    import ColumnHeader from './ColumnHeader.html';
    import Dependency from './Dependency.html';
    import { Utils } from "./task.js";
    import { Store } from 'svelte/store.js';

    let SvelteGantt;

    export default {
        setup(component){
            SvelteGantt = component;
            SvelteGantt.defaults = {
				width: 800,
				height: 400,
				magnetOffset: 15,
				magnetUnit: 'minute',
				headerHeight: 100,
				headers: [{unit: 'day', format: 'DD.MM.YYYY'}, {unit: 'hour', format: 'HH'}],
				rowHeight: 24
            };

            SvelteGantt.create = function(target, data, options) {

                const store = new Store();

                store.set(Object.assign(SvelteGantt.defaults, options));
                store.set({ rows: data.rows });
                return new SvelteGantt({
                    target,
                    data,
                    store
                })
            }
            

        },



        components: { Row, Column, RowHeader, ColumnHeader, Dependency },
        oncreate(){
            
            const {from, to, width, magnetOffset, magnetUnit} = this.store.get();
            let diva;
            const columnWidth = Utils.getPositionByDate(from.clone().add(magnetOffset, magnetUnit), from, to, width);
            diva = width / columnWidth
            const columnCount = Math.ceil(width / columnWidth) 

            var columns = [];
            
            for(let i=0; i< columnCount; i++){
                columns.push({width: columnWidth});
            }

            this.store.set({bodyElement: this.refs.rowContainer})

            this.set({columns: columns});


            this.updateVisibleRows(0, this.refs.rowContainer.clientHeight);
        },
        actions: {
            scrollable(node){
                const { scrollables } = this.get();
                const self = this;

                function onscroll(event) {
                    const scrollAmount = node.scrollTop; 

                    console.log(scrollAmount);
                    for(let i=0; i< scrollables.length; i++){
                        const scrollable = scrollables[i];
                        scrollables[i].scrollTop = scrollAmount;
                    }
                    self.updateVisibleRows(scrollAmount, node.clientHeight);
                }

                node.addEventListener('scroll', onscroll);
                return {
					destroy() {
						node.removeEventListener('scroll', onscroll, false);
					}
                }
            },
            scrollListener(node){
                const { scrollables } = this.get();
                scrollables.push(node);
            }
		},
        methods: {
            updateVisibleRows(scrollTop, viewportHeight){
                const { rows, height, rowHeight } = this.store.get();

                let startIndex = Math.floor(scrollTop / rowHeight);
                let endIndex = Math.min(startIndex + Math.ceil(viewportHeight / rowHeight ), rows.length - 1);

                console.log('['+startIndex+','+endIndex+']');

                const paddingTop = startIndex * rowHeight;
                const paddingBottom = rows.length * rowHeight - viewportHeight - paddingTop;


                const visibleRows = rows.slice(startIndex, endIndex + 1);

                this.set({ visibleRows: visibleRows, paddingTop: paddingTop, paddingBottom: paddingBottom });
                this.store.set({ visibleRows });
                this.set({dependencies: this.get().dependencies});
            },
            updateViewport() {
                const {scrollTop, clientHeight} = this.refs.rowContainer;
                this.updateVisibleRows(scrollTop, clientHeight);
            }
        },
        data() {
            return {
                columns: [],
                scrollables: [],
                visibleRows: []
            }
        },
        computed: {
            rowContainerHeight: ({rows, $rowHeight}) => rows.length * $rowHeight
        }
    };
</script>