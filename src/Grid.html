<div class="grid" use:disableContextMenu>

    <div class="side-header-container" style="width:100px" ref:sideHeaderContainer>
    
    </div>

    <div class="main-header-container" use:horizontalScrollListener  ref:sideContainer>
        <div class="header-container" style="width:{$width}px">
            {#each $headers as header}
                <ColumnHeader header={header}/>
            {/each}
        </div>
    </div>

    <div class="side-container" style="height:{$height}px" use:scrollListener>
        <div class="row-header-container" style="padding-top:{paddingTop}px;padding-bottom:{paddingBottom}px;height:{rowContainerHeight}px;"> 
            {#each visibleRows as row (row.id)}
                <RowHeader 
                    bind:label=row.label/>
            {/each}
        </div>
    </div>

    <div class="main-container" style="height:{$height}px" use:scrollable ref:mainContainer>
        <div class="content" style="width:{$width}px">
            

            <div class="column-container">
                {#each columns as column}
                    <Column width={column.width}/>
                {/each}
            </div>    
            <div class="row-container" style="padding-top:{paddingTop}px;padding-bottom:{paddingBottom}px;height:{rowContainerHeight}px;"
                ref:rowContainer>
                {#each visibleRows as row (row.id)}
                    <Row row={row}
                        width={width}
                        on:updateVisibleRows="updateViewport()"/>
                {/each}
            </div>

            <div class="dependency-container">
                {#each visibleDependencies as dependency (dependency.id)}
                    <Dependency fromTask={dependency.fromTask} 
                        toTask={dependency.toTask}
                        {dependency}/>
                {/each}
            </div>
        </div>
    </div>

</div>

<style>
    .grid {
        width: 100%;
        position: relative;
        font-family: tahoma, arial, verdana, Sans-serif;
        font-size: 10px;
        color: #656565;
    }

    .column-container {
        position: absolute;
        height: 100%;

        float: left;
        overflow: hidden;
    }

    .dependency-container {
        position: absolute;
        width: 100%;
        height: 100%;
        
        pointer-events: none;
        top: 0;
        float: left;
        overflow: hidden;
    }

    .row-container {
        width: 100%;
        /* display: inline-block; */
        box-sizing: border-box;
    }

    .row-header-container {
        
        box-sizing: border-box;
    }


    .side-container {
        width: 100px;
        float: left;
        overflow-y: hidden;
    }

    .main-container {
        /* position: relative; */
        overflow: auto;
    }

    .side-header-container {
        float: left;
    }

    .main-header-container {
        position: relative;
        overflow: hidden;
    }

    .content {
        position: relative;
    }
</style>

<script>
    import Row from './Row.html';
    import RowHeader from './RowHeader.html';
    import Column from './Column.html';
    import ColumnHeader from './ColumnHeader.html';
    import Dependency from './Dependency.html';
    import { Utils } from "./task.js";
    import { Store } from 'svelte/store.js';
    import ContextMenuManager from './contextMenuManager.js'
    import SelectionManager from './selectionManager.js'
    import GanttUtils from "./utils.js";

    import Task from "./Task.html";

    let SvelteGantt;

    export default {
        setup(component){
            SvelteGantt = component;
            SvelteGantt.defaults = {
				width: 800,
				height: 400,
				magnetOffset: 15,
				magnetUnit: 'minute',
				headerHeight: 100,
				headers: [{unit: 'day', format: 'DD.MM.YYYY'}, {unit: 'hour', format: 'HH'}],
				rowHeight: 24
            };

            SvelteGantt.create = function(target, data, options) {

                const store = new Store();

                const ganttOptions = Object.assign(SvelteGantt.defaults, options);
                const ganttUtils = new GanttUtils(ganttOptions);

                store.set(ganttOptions);
                store.set({ 
                    rows: data.rows,
                    contextMenuManager: new ContextMenuManager(),
                    selectionManager: new SelectionManager((t) => { t.component && t.component.set({task: t}) }),
                    ganttUtils: ganttUtils
                });

                for(let i=0; i < data.rows.length; i++){
                    const row = data.rows[i];
                    for(let j=0; j < row.tasks.length; j++){
                        const task = row.tasks[j];
                        task.amountDone = task.amountDone || 0;
                        Task.updatePosition(task, ganttUtils);
                        task.row = row;
                    }
                }

                return new SvelteGantt({
                    target,
                    data,
                    store
                })
            }
        },



        components: { Row, Column, RowHeader, ColumnHeader, Dependency },
        oncreate(){
            
            this.initColumns();

            this.store.set({
                bodyElement: this.refs.mainContainer, 
                rowContainerElement: this.refs.rowContainer
            });
            

            /*for(let i=0; i < rows.length; i++){
                Task.updatePosition(rows[i].tasks[0], this.store.get());
            }*/

            const { rows, rowHeight } = this.store.get();
            const { dependencies } = this.get();
            for(let i=0; i < dependencies.length; i++){
                let dependency = dependencies[i];
                const res = Dependency.update(dependency.fromTask, dependency.toTask, rows, rowHeight);
                Object.assign(dependency, res);
            }

            this.updateVisibleRows(0, this.refs.mainContainer.clientHeight);
            this.updateVisibleDependencies(0, this.refs.mainContainer.clientHeight);

            this.updateHeaderHeight();
        },
        actions: {
            disableContextMenu(node) {
                node.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                }, false);
                //ovo dolje radi kad stvoriÅ¡ svelte contextmenu, klikne na sam contextmenu TO DO remove
                document.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                }, false);
            },
            scrollable(node){
                const { scrollables } = this.get();
                const self = this;

                function onscroll(event) {
                    const scrollAmount = node.scrollTop; 

                    console.log(scrollAmount);
                    for(let i=0; i< scrollables.length; i++){
                        const scrollable = scrollables[i];
                        if(scrollable.orientation === 'horizontal') {
                            scrollable.node.scrollLeft = node.scrollLeft;
                        }
                        else {
                            scrollable.node.scrollTop = scrollAmount;
                        }
                    }
                    //TODO: only for vertical scroll
                    self.updateVisibleRows(scrollAmount, node.clientHeight);
                    self.updateVisibleDependencies(scrollAmount, node.clientHeight);
                }

                node.addEventListener('scroll', onscroll);
                return {
					destroy() {
						node.removeEventListener('scroll', onscroll, false);
					}
                }
            },
            scrollListener(node){
                const { scrollables } = this.get();
                scrollables.push({node});
            },
            horizontalScrollListener(node){
                const { scrollables } = this.get();
                scrollables.push({node, orientation: 'horizontal'});
            }
		},
        methods: {
            updateVisibleRows(scrollTop, viewportHeight){
                console.log('update v rows');
                const { rows, rowHeight } = this.store.get();

                let startIndex = Math.floor(scrollTop / rowHeight);
                let endIndex = Math.min(startIndex + Math.ceil(viewportHeight / rowHeight ), rows.length - 1);

                console.log('['+startIndex+','+endIndex+']');

                const paddingTop = startIndex * rowHeight;
                const paddingBottom = rows.length * rowHeight - viewportHeight - paddingTop;


                const visibleRows = rows.slice(startIndex, endIndex + 1);

                //only horizontal scroll
                visibleRows.forEach(row => {
                    row.visibleTasks = this.visibleTasks(row);
                })

                this.set({ visibleRows: visibleRows, paddingTop: paddingTop, paddingBottom: paddingBottom });
                this.store.set({ visibleRows });
                //this.set({dependencies: this.get().dependencies});
            },
            visibleTasks(row){
                const scrollLeft = this.refs.mainContainer.scrollLeft;
                const clientWidth = this.refs.mainContainer.clientWidth;
                //finish this
                this.store.set({scrollLeft, clientWidth});

                //da su sortirani -> index prvog, zadnjeg, i onda slice
                const visibleTasks = [];
                row.tasks.forEach(task => {
                    if(!(task.left + task.width < scrollLeft || task.left > scrollLeft + clientWidth)){
                        visibleTasks.push(task);
                    }
                });
                console.log(visibleTasks.length);
                return visibleTasks;
            },
            updateViewport(){
                console.log('update v port');
                const {scrollTop, clientHeight} = this.refs.mainContainer;
                this.updateVisibleRows(scrollTop, clientHeight);
                this.updateVisibleDependencies(scrollTop, clientHeight);
            },
            updateVisibleDependencies(scrollTop, viewportHeight){
                const { dependencies } = this.get();

                //interval tree or just debounce a bit
                const visibleDependencies = [];
                
                const viewportTop = scrollTop;
                const viewportBottom = scrollTop + viewportHeight;

                for(let i = 0; i < dependencies.length; i++){
                    const dependency = dependencies[i];
                    let { startY, endY } = dependency; //init dependencies before components oncreate
                    
                    //let yMax = Math.max(startY, endY);//can be done 
                    //let yMin = Math.min(startY, endY);//with an if //todo research performance
                    let yMax, yMin;
                    if(startY > endY){
                        yMax = startY;
                        yMin = endY;
                    }
                    else{
                        yMax = endY;
                        yMin = startY;
                    }

                    if(yMax < viewportTop && yMin < viewportTop || yMax > viewportBottom && yMin > viewportBottom) {
                        //cant see dependency
                    }
                    else {
                        visibleDependencies.push(dependency);
                    }
                }

                this.set({ visibleDependencies });
            },
            initColumns() {
                const {ganttUtils, magnetOffset, magnetUnit} = this.store.get();
                const columnWidth = ganttUtils.getPositionByDate(ganttUtils.from.clone().add(magnetOffset, magnetUnit));
                const columnCount = Math.ceil(ganttUtils.width / columnWidth) 

                const columns = [];
                for(let i = 0; i < columnCount; i++){
                    columns.push({width: columnWidth});
                }

                this.set({ columns });
            },
            updateHeaderHeight() {
                const height = this.refs.sideContainer.clientHeight;
                this.refs.sideHeaderContainer.style.height = height + 'px';
            }
        },
        data() {
            return {
                columns: [],
                scrollables: [],
                visibleRows: [],
                visibleDependencies: []
            }
        },
        computed: {
            rowContainerHeight: ({rows, $rowHeight}) => rows.length * $rowHeight
        }
    };
</script>