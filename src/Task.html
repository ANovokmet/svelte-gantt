<div ref:taskElement
    class="task {task.model.classes}" 
    style="
    width:{task.truncated ? task.truncatedWidth : task.width}px;
    transform: translate({task.posX}px, {task.posY}px);"
    use:drag 
    use:contextMenu
    use:selectable
    class:overlapping="task.overlapping"
    class:selected="task.selected"
    class:moving="task.dragging||task.resizing">
    <div class="task-background" style="width:{task.model.amountDone}%"></div>
    <div class="task-content">
        {#if task.model.html}
            {@html task.model.html}
        {:elseif $taskContent}
            {@html $taskContent(task)}
        {:else}
            {task.model.label}
        {/if}

        {#if task.model.showButton}
            <span class="task-button {task.model.buttonClasses}" on:click="onclick(event)">
                {@html task.model.buttonHtml}
            </span>
        {/if}
    </div>
</div>

<style>
    .task {
		position: absolute;     
        top: 0;
        bottom: 0;

        white-space: nowrap;
        overflow: hidden;

        transition: background-color 0.2s;
	}

    .task-background {
        position: absolute;
        height: 100%;
        top: 0;
    }

    .task-content {
        position: absolute;
        height: 100%;
        top: 0;
    }

    .task:not(.moving) {
        transition: transform 0.2s, background-color 0.2s;
    }

    .task.moving{
        z-index: 1;
    }

    .task:hover::before {
        content: '';
        width: 4px;
        height: 50%;
        top: 25%;
        position: absolute;
        cursor: ew-resize;
        border-style: solid;
        border-color: rgba(255, 255, 255, 0.5);
            
        margin-left: 3px;
        left: 0;
        border-width: 0 1px;
    }

    .task:hover::after {
        content: '';
        width: 4px;
        height: 50%;
        top: 25%;
        position: absolute;
        cursor: ew-resize;
        border-style: solid;
        border-color: rgba(255, 255, 255, 0.5);

        margin-right: 3px;
        right: 0;
        border-width: 0 1px;
    }

    .task.selected {
        outline: 2px solid rgba(3, 169, 244, 0.5);
        outline-offset: 3px;

    }
</style>

<script>
    import { DOMUtils } from "./domUtils.js";
    import ContextMenu from "./ContextMenu.html";

//left:{task.truncated ? task.truncatedLeft : task.left}px;

    export default {
        setup(component) {
        },
        oncreate() {
            const { task } = this.get();
            const row = task.row;
            task.component = this;


            const {rows, rowHeight} = this.store.get();
            
            let startIndex = rows.indexOf(row); 

            let startY = startIndex * rowHeight;

            this.set({startY});
        },
        ondestroy() {
            const { task } = this.get();
            //does automatically (?)
            if(task.component === this) {
                task.component = null;
            }
        },
        onupdate({ changed, current, previous }) {
            if(changed.task){
                //console.log('current', current.task);
                //console.log('previous', previous && previous.task);
                //current.row.rowElement = this.refs.row;
                current.task.component = this;
            }

            if(changed.task && changed.row){
                current.task.row = current.row;
            }
        },
        actions: {
			drag(node) {
                const { rowContainerElement, ganttUtils, gantt, resizeHandleWidth } = this.store.get();
                const windowElement = window;
                const { _rowCache } = gantt.get();

                let { task } = this.get();
                //update reference when tasks are loaded with new data
                const listener = this.on('update', ({ changed, current, previous }) => {
                    if(changed.task){
                        task = current.task;
                    }
                });

                let mouseStartPosX, mouseStartPosY;
                let mouseStartRight;
                
                let originalRow;
                let taskOriginalFrom, taskOriginalTo;
                
                    
                function onmousedown(event) {
                    if(event.which !== 1){
                        //debugger;
                        return;
                    }

                    event.stopPropagation();
                    event.preventDefault();
                    
                    originalRow = _rowCache[task.model.resourceId];
                    taskOriginalFrom = task.model.from.clone();
                    taskOriginalTo = task.model.to.clone();

                    if(originalRow.model.enableDragging){
                        mouseStartPosX = DOMUtils.getRelativePos(rowContainerElement, event).x - task.left;
                        mouseStartPosY = DOMUtils.getRelativePos(rowContainerElement, event).y - task.posY;
                        mouseStartRight = task.left + task.width;

                        if(mouseStartPosX < resizeHandleWidth) {
                            task.resizing = true;
                            task.direction = 'left';
                        }
                        else if(mouseStartPosX > task.width - resizeHandleWidth) {
                            task.resizing = true;
                            task.direction = 'right';
                        }
                        else {
                            task.dragging = true;
                        }

                        windowElement.addEventListener('mousemove', onmousemove, false);
                        DOMUtils.addEventListenerOnce(windowElement, 'mouseup', onmouseup);
                    }
                }
                
                function onmousemove(event) {

                    event.preventDefault();
                    if(task.resizing) {
                        const mousePos = DOMUtils.getRelativePos(rowContainerElement, event);
                        
                        if(task.direction === 'left') { //resize ulijevo
                            if(mousePos.x > task.left + task.width) {
                                task.left = mouseStartRight; //mousePos.x //
                                task.width = task.left - mousePos.x;
                                task.direction = 'right'
                                mouseStartRight = task.left + task.width;
                            }
                            else{
                                task.left = mousePos.x;
                                task.width = mouseStartRight - mousePos.x;
                            }
                        }
                        else if(task.direction === 'right') {//resize desno
                            if(mousePos.x <= task.left) {
                                task.width = task.left - mousePos.x;
                                task.left = mousePos.x;
                                task.direction = 'left';
                                mouseStartRight = task.left + task.width;
                            }
                            else {
                                task.width = mousePos.x - task.left;
                            }
                        }
                    }

                    if(task.dragging) {
                        const mousePos = DOMUtils.getRelativePos(rowContainerElement, event);
                        task.left = mousePos.x - mouseStartPosX;
                        
                        task.posX = mousePos.x - mouseStartPosX;
                        task.posY = mousePos.y - mouseStartPosY;


                        //row switching
                        const rowCenterX = gantt.refs.mainContainer.getBoundingClientRect().left + gantt.refs.mainContainer.getBoundingClientRect().width / 2;
                        const sourceRow = _rowCache[task.model.resourceId];

                        let elements = document.elementsFromPoint(rowCenterX, event.clientY);
                        let rowElement = elements.find((element) => element.classList.contains('row'));
                        if(rowElement !== undefined && rowElement !== sourceRow.rowElement) {

                            const { rows } = gantt.store.get(); //visibleRows
                            const targetRow = rows.find((r) => r.rowElement === rowElement); //vr

                            if(targetRow.model.enableDragging){
                                targetRow.moveTask(task);
                                
                                sourceRow.component.taskRemoved();
                                targetRow.component.taskAdded();
                                gantt.api.tasks.raise.switchRow(task, targetRow, sourceRow);
                            }
                        }
                    }

                    if(task.dragging || task.resizing){
                        const self = task.component;

                        task.updateDate();
                        task.updatePosition();
                        task.truncate();
                        self.set({task});
                        self.setY(event)
                        task.notify();
                        gantt.api.tasks.raise.move(task);
                    }
                }

                function onmouseup(event) {
                    
                    task.updateDate();
                    task.updatePosition();
                    
                    task.posX = task.left;
                    task.posY = task.model.resourceId * 24;

                    task.dragging = false;
                    task.resizing = false;
                    task.direction = null;
                    windowElement.removeEventListener('mousemove', onmousemove, false);
                    task.component.fire('taskDropped', { task });
                    task.component.set({task});
                    task.component.setY()

                    //code this better
                    if(originalRow && originalRow !== _rowCache[task.model.resourceId]) {
                        originalRow.component.handleOverlaps();
                    }

                    gantt.api.tasks.raise.moveEnd(task, task.row, originalRow);
                    if(!taskOriginalFrom.isSame(task.model.from) || !taskOriginalTo.isSame(task.model.to) || (originalRow && originalRow !== task.row)) {
                        gantt.api.tasks.raise.changed(task, task.row, originalRow);
                    }
                }

                node.addEventListener('mousedown', onmousedown, false);

                const cursorOnMove = (e) => {
                    const mouseStartPosX = DOMUtils.getRelativePos(rowContainerElement, e).x - task.left;

                    //TODO globally set cursor ON mousedown
                    if(mouseStartPosX < resizeHandleWidth || mouseStartPosX > task.width - resizeHandleWidth) {
                        this.updateCursor('e-resize');
                    }
                    else{
                        this.updateCursor();
                    }

                };
                node.addEventListener('mousemove', cursorOnMove, false)

				return {
					update() {
                        //ne radi??
                        task = this.get().task;
					},

					destroy() {
						node.removeEventListener('mousedown', onmousedown, false);
						//windowElement.removeEventListener('mousemove', onmousemove, false);
						node.removeEventListener('mousemove', onmousemove, false);
                        node.removeEventListener('mouseup', onmouseup, false);
                        listener.cancel();
					}
				}
            },
            contextMenu(node){
                const { gantt } = this.store.get();

                if(gantt.enableContextMenu){
                    const { task } = this.get();
                    const options = [
                        {
                            label: 'Copy',
                            action: () => console.log('clicked action 1 for task ', task.model.id)
                        },
                        {
                            label: 'Clear dependencies',
                            action: () => console.log('clicked action 2 for task ', task.model.id)
                        }
                    ];

                    function onClose(event) {
                        //if(!contextMenu.isTarget(e))
                        gantt.menuManager.close();
                    }

                    node.addEventListener('mouseup', (e) => {
                        if(e.which === 3){
                            e.stopPropagation();
                            gantt.menuManager.open(options, {x: e.x, y: e.y})

                            DOMUtils.addEventListenerOnce(node, 'mousedown', onClose); //document.body
                        }
                    });
                }
                
				return {
					destroy() {
                        gantt.menuManager.close();
					}
				}
            },
            selectable(node) {
                const { gantt } = this.store.get();
                const self = this;
                node.addEventListener('click', (e) => {
                    const { task } = this.get();
                    if(e.ctrlKey){
                        gantt.selectionManager.toggleSelection(task);
                    }
                    else{
                        gantt.selectionManager.selectSingle(task);
                    }

                    if(task.selected){
                        gantt.api.tasks.raise.select(task);
                    }
                });
            }
        },
        // // could work but questionable if task updates, an action works... but too complex for end user
        // events: {
		// 	customHtmlElemHook(node) {
        //         const elem = document.createElement('div');
        //         elem.innerHTML = 'Custom dynamic template';
        //         node.append(elem);
		// 		const onclick = (event) => {debugger;}
		// 		elem.addEventListener('click', onclick, false);
		// 		return {
		// 			destroy() {
		// 				elem.removeEventListener('mousedown', onclick, false);
		// 			}
		// 		};
		// 	}
		// },
        methods: {
            updateCursor(cursor){
                const element = this.refs.taskElement;
                element.style.cursor = cursor || 'default';
            },
            onclick(event){
                const { onTaskButtonClick } = this.store.get();
                if(onTaskButtonClick) {
                    event.stopPropagation();
                    const { task } = this.get();
                    onTaskButtonClick(task);
                }
            },
            setY(event){
                const { task } = this.get();
                const row = task.row;
                const {rows, rowHeight} = this.store.get();
                if(task.dragging){
                    const { rowContainerElement } = this.store.get();
                    const mousePos = DOMUtils.getRelativePos(rowContainerElement, event);
                    console.log(mousePos.y)
                    
                    this.set({startY: mousePos.y});
                }
                else{
                    
                    let startIndex = rows.indexOf(row); 
                    let startY = startIndex * rowHeight;
                    this.set({startY});
                }
            }
        },
        data() {
            return {
                task: { dragging: false }
            }
        }
    };
</script>