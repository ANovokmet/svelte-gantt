<div ref:taskElement
    class="task {model.classes}" 
    style="
    width:{widthT}px;
    height:{height}px;
    transform: translate({posX}px, {posY}px);"
    use:drag 
    use:selectable
    class:overlapping="overlapping"
    class:selected="selected"
    class:moving="dragging||resizing">
    <div class="task-background" style="width:{model.amountDone}%"></div>
    <div class="task-content">
        {#if model.html}
            {@html model.html}
        {:elseif $taskContent}
            {@html $taskContent(this)}
        {:else}
            {model.label}
        {/if}

        {#if model.showButton}
            <span class="task-button {model.buttonClasses}" on:click="onclick(event)">
                {@html model.buttonHtml}
            </span>
        {/if}
    </div>
</div>

<style>
    .task {
		position: absolute;     
        top: 0;
        bottom: 0;

        white-space: nowrap;
        overflow: hidden;

        transition: background-color 0.2s;
	}

    .task-background {
        position: absolute;
        height: 100%;
        top: 0;
    }

    .task-content {
        position: absolute;
        height: 100%;
        top: 0;

        
        padding-left: 14px;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: flex-start;
    }

    .task:not(.moving) {
        transition: transform 0.2s, background-color 0.2s, width 0.2s;
    }

    .task.moving{
        z-index: 1;
    }

    .task:hover::before {
        content: '';
        width: 4px;
        height: 50%;
        top: 25%;
        position: absolute;
        cursor: ew-resize;
        border-style: solid;
        border-color: rgba(255, 255, 255, 0.5);
            
        margin-left: 3px;
        left: 0;
        border-width: 0 1px;
    }

    .task:hover::after {
        content: '';
        width: 4px;
        height: 50%;
        top: 25%;
        position: absolute;
        cursor: ew-resize;
        border-style: solid;
        border-color: rgba(255, 255, 255, 0.5);

        margin-right: 3px;
        right: 0;
        border-width: 0 1px;
    }

    .task.selected {
        outline: 2px solid rgba(3, 169, 244, 0.5);
        outline-offset: 3px;
        z-index: 1;
    }
</style>

<script>
    import { DOMUtils } from "./utils/domUtils";


    export default {
        onstate({ changed, current, previous }) {
            // before first render
            // if(!previous){
            //     const left = this.root.utils.getPositionByDate(current.model.from);
            //     const right = this.root.utils.getPositionByDate(current.model.to); 
            //     this.set({posX:left, widthT:right-left, left, width:right-left});
            // }
		},
        actions: {
			drag(node) {
                const { rowContainerElement, ganttUtils, gantt, resizeHandleWidth } = this.store.get();
                const windowElement = window;

                let mouseStartPosX, mouseStartPosY;
                let mouseStartRight;
                
                let originalRow;
                let taskOriginalFrom, taskOriginalTo;
                
                    
                const onmousedown = (event) => {
                    if(event.which !== 1){
                        //debugger;
                        return;
                    }

                    const { left, posY, width, model } = this.get();

                    event.stopPropagation();
                    event.preventDefault();
                    
                    const { rowMap } = this.store.get();
                    originalRow = rowMap[model.resourceId];
                    taskOriginalFrom = model.from.clone();
                    taskOriginalTo = model.to.clone();

                    if(originalRow.model.enableDragging && model.enableDragging){
                        mouseStartPosX = DOMUtils.getRelativePos(rowContainerElement, event).x - left;
                        mouseStartPosY = DOMUtils.getRelativePos(rowContainerElement, event).y - posY;
                        mouseStartRight = left + width;

                        if(mouseStartPosX < resizeHandleWidth) {
                            this.set({
                                resizing: true,
                                direction: 'left'
                            })
                            //gantt.includeInRender = task;
                        }
                        else if(mouseStartPosX > width - resizeHandleWidth) {

                            this.set({
                                resizing: true,
                                direction: 'right'
                            })
                            //gantt.includeInRender = task;
                        }
                        else {
                            this.set({
                                dragging: true
                            })
                            // gantt.includeInRender = task;
                        }

                        windowElement.addEventListener('mousemove', onmousemove, false);
                        DOMUtils.addEventListenerOnce(windowElement, 'mouseup', onmouseup);
                    }
                }
                
                const onmousemove = (event) => {

                    const { resizing, dragging } = this.get()

                    event.preventDefault();
                    if(resizing) {
                        const mousePos = DOMUtils.getRelativePos(rowContainerElement, event);
                        const { direction, left, width } = this.get()
                        
                        if(direction === 'left') { //resize ulijevo
                            if(mousePos.x > left + width) {
                                this.set({
                                    left: mouseStartRight,
                                    posX: mouseStartRight,
                                    width: mouseStartRight - mousePos.x,
                                    widthT: mouseStartRight - mousePos.x,
                                    direction: 'right',
                                });
                                mouseStartRight = mouseStartRight + width;
                            }
                            else{
                                this.set({
                                    left: mousePos.x,
                                    posX: mousePos.x,
                                    width: mouseStartRight - mousePos.x,
                                    widthT: mouseStartRight - mousePos.x
                                });
                            }
                        }
                        else if(direction === 'right') {//resize desno
                            if(mousePos.x <= left) {
                                this.set({
                                    width: left - mousePos.x,
                                    widthT: left - mousePos.x,
                                    left: mousePos.x,
                                    posX: mousePos.x,
                                    direction: 'left'
                                });
                                mouseStartRight = left;
                            }
                            else {
                                this.set({
                                    width: mousePos.x - left,
                                    widthT: mousePos.x - left
                                });
                            }
                        }
                    }

                    // mouseup
                    if(dragging) {
                        const mousePos = DOMUtils.getRelativePos(rowContainerElement, event);

                        this.set({
                            left: mousePos.x - mouseStartPosX,
                            posX: mousePos.x - mouseStartPosX,
                            posY: mousePos.y - mouseStartPosY
                        });
                    }
                    
                }

                const onmouseup = (event) => {
                    
                    const { left, width, dragging, model } = this.get()

                    const { taskMap, gantt, rowHeight, rowPadding, rowMap } = this.store.get()

                    if(dragging) {
                        //row switching
                        const rowCenterX = gantt.refs.mainContainer.getBoundingClientRect().left + gantt.refs.mainContainer.getBoundingClientRect().width / 2;
                        const sourceRow = rowMap[model.resourceId];

                        let elements = document.elementsFromPoint(rowCenterX, event.clientY);
                        let rowElement = elements.find((element) => element.classList.contains('row'));
                        if(rowElement !== undefined && rowElement !== sourceRow.rowElement) {

                            const { allRows } = this.store.get(); //visibleRows
                            const targetRow = allRows.find((r) => r.rowElement === rowElement); //vr

                            if(targetRow.model.enableDragging){
                                //targetRow.moveTask(this);
                                model.resourceId = targetRow.model.id;
                                gantt.api.tasks.raise.switchRow(this, targetRow, sourceRow);
                            }
                        }
                    }
                    
                    

                    this.set({
                        posX: left, //Math.ceil(left),
                        posY: rowPadding + rowMap[model.resourceId].posY,
                        widthT: width, // Math.ceil(width),
                        
                        dragging: false,
                        resizing: false,
                        direction: null,
                    });

                    const task = taskMap[model.id];
                    

                    task.left = left;
                    task.width = width;
                    task.posX = Math.ceil(left);
                    task.posY = rowPadding + rowMap[model.resourceId].posY;

                    task.updateDate();
                    task.updatePosition();
                    this.store.updateTask(task);


                    //gantt.includeInRender = null;
                    windowElement.removeEventListener('mousemove', onmousemove, false);
                    
                    // gantt.api.tasks.raise.moveEnd(task, task.row, originalRow);
                    // if(!taskOriginalFrom.isSame(task.model.from) || !taskOriginalTo.isSame(task.model.to) || (originalRow && originalRow !== task.row)) {
                    //     gantt.api.tasks.raise.changed(task, task.row, originalRow);
                    // }
                }

                node.addEventListener('mousedown', onmousedown, false);

                const cursorOnMove = (e) => {
                    const { left, width } = this.get()

                    const mouseStartPosX = DOMUtils.getRelativePos(rowContainerElement, e).x - left;

                    //TODO globally set cursor ON mousedown
                    if(mouseStartPosX < resizeHandleWidth || mouseStartPosX > width - resizeHandleWidth) {
                        this.updateCursor('e-resize');
                    }
                    else{
                        this.updateCursor();
                    }

                };
                node.addEventListener('mousemove', cursorOnMove, false)

				return {
					destroy() {
						node.removeEventListener('mousedown', onmousedown, false);
						//windowElement.removeEventListener('mousemove', onmousemove, false);
						node.removeEventListener('mousemove', onmousemove, false);
                        node.removeEventListener('mouseup', onmouseup, false);
					}
				}
            },
            selectable(node) {
                const { gantt } = this.store.get();
                const self = this;
                node.addEventListener('click', (e) => {
                    const { model } = this.get();
                    if(e.ctrlKey){
                        gantt.selectionManager.toggleSelection(model);
                    }
                    else{
                        gantt.selectionManager.selectSingle(model);
                    }

                    if(model.selected){
                        gantt.api.tasks.raise.select(model);
                    }
                });
            }
        },
        methods: {
            updateCursor(cursor){
                const element = this.refs.taskElement;
                element.style.cursor = cursor || 'default';
            },
            onclick(event){
                const { onTaskButtonClick } = this.store.get();
                if(onTaskButtonClick) {
                    event.stopPropagation();
                    const { task } = this.get();
                    onTaskButtonClick(task);
                }
            }
        },
        data() {
            return {
                dragging: false,
                overlapping: false,
                selected: false,
                resizing: false
            }
        },
        computed: {
            selected: ({$selection, model}) => $selection.indexOf(model) !== -1,
            row: ({$rowMap, model}) => $rowMap[model.resourceId],
            // height: ({row}) => row.height
        }
    };
</script>