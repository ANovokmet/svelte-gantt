<div class="task" 
    style="left:{task.left}px;width:{task.width}px;"
    use:drag 
    use:contextMenu
    use:selectable
    class:overlapping="task.overlapping"
    class:selected="task.selected">
    <div class="task-background" style="width:{task.amountDone}%"></div>
    {task.label}
</div>

<style>
    .task {
		position: absolute;     
        top: 0;
        bottom: 0;   
        height: 80%;
        margin: auto;
        background: rgb(116, 191, 255);
	}

    .task-background {
        position: absolute;
        height: 100%;
        background: rgba(0, 0, 0, 0.2);
    }
</style>

<script>
    import moment from "../node_modules/moment/src/moment.js";
    import { Utils } from "./task.js";
    import ContextMenu from "./ContextMenu.html";

    const resizeHandleWidth = 15;

    let SvelteTask;

    function notify(task) {
        if(task.dependencies){
            for(let i = 0; i < task.dependencies.length; i++){
                task.dependencies[i].update();
            }
        }
    }

    function updatePosition(task, ganttUtils){
        const left = ganttUtils.getPositionByDate(task.from);
        const right = ganttUtils.getPositionByDate(task.to); 

        task.left = left;
        task.width = right - left;
    }

    function overlaps(task, task2) {
        //todo just return boolean expr
        if(task.left <= task2.left && task.left + task.width <= task2.left ||
        task.left >= task2.left + task2.width && task.left + task.width >= task2.left + task2.width){
            return false;
        }
        else{
            return true;
        }
    }

    export default {
        setup(component) {
            SvelteTask = component;
            SvelteTask.updatePosition = updatePosition;
            SvelteTask.overlaps = overlaps;
        },
        oncreate() {
            const { task, row } = this.get();
            task.row = row;
            task.component = this;

            this.updateTaskPosition();
        },
        ondestroy() {
            const { task, row } = this.get();
            if(task.component === this) {
                task.component = null;
            }
        },
        actions: {
			drag(node) {
                const { rowContainerElement, ganttUtils } = this.store.get();
                const windowElement = window;

                const { task } = this.get();

                let mouseStartPosX;
                let mouseStartRight;

                function onmousedown(event) {
                    event.stopPropagation();
                    event.preventDefault();
                    console.log('drag down');
                    task.originalRow = task.row;

                    mouseStartPosX = Utils.getRelativePos(rowContainerElement, event).x - task.left;
                    mouseStartRight = task.left + task.width;

                    if(mouseStartPosX < resizeHandleWidth) {
                        task.resizing = true;
                        task.direction = 'left';
                    }
                    else if(mouseStartPosX > task.width - resizeHandleWidth) {
                        task.resizing = true;
                        task.direction = 'right';
                    }
                    else {
                        task.dragging = true;
                    }

                    windowElement.addEventListener('mousemove', onmousemove, false);
                    Utils.addEventListenerOnce(windowElement, 'mouseup', onmouseup);
                }
                
                function onmousemove(event) {
                    
                    event.preventDefault();
                    if(task.resizing) {
                        const mousePos = Utils.getRelativePos(rowContainerElement, event);
                        
                        if(task.direction === 'left') { //resize ulijevo
                            if(mousePos.x > task.left + task.width) {
                                task.left = mouseStartRight; //mousePos.x //
                                task.width = task.left - mousePos.x;
                                task.direction = 'right'
                                mouseStartRight = task.left + task.width;
                            }
                            else{
                                task.left = mousePos.x;
                                task.width = mouseStartRight - mousePos.x;
                            }
                        }
                        else if(task.direction === 'right') {//resize desno
                            if(mousePos.x <= task.left) {
                                task.width = task.left - mousePos.x;
                                task.left = mousePos.x;
                                task.direction = 'left';
                                mouseStartRight = task.left + task.width;
                            }
                            else {
                                task.width = mousePos.x - task.left;
                            }
                        }

                        console.log(mousePos.x, mouseStartPosX)

                        task.component.updateTaskDate();
                        task.component.updateTaskPosition();
                        task.component.set({ task });
                        task.component.fire('taskResized', { task: task });
                    }

                    if(task.dragging) {
                        const mousePos = Utils.getRelativePos(rowContainerElement, event);
                        task.left = mousePos.x - mouseStartPosX;

                        task.component.updateTaskDate();//pomaknuti na kraj funkcije
                        task.component.updateTaskPosition();
                        
                        //row switching
                        const rowCenterX = rowContainerElement.getBoundingClientRect().left + rowContainerElement.getBoundingClientRect().width / 2;
                        const sourceRow = task.row;
                        let targetRow;

                        let elements = document.elementsFromPoint(rowCenterX, event.clientY);
                        let rowElement = elements.find((element) => element.classList.contains('row'));
                        if(rowElement !== undefined && rowElement !== sourceRow.rowElement) {

                            const { visibleRows } = task.component.store.get();

                            const targetRow = visibleRows.find((r) => r.rowElement === rowElement);
                            console.log('move task to '+targetRow.label, targetRow);

                            task.row = targetRow;
                            targetRow.tasks.push(task);
                            
                            let i, sourceTask;
                            for (i = 0; i < sourceRow.tasks.length; i++) {
                                sourceTask = sourceRow.tasks[i]
                                if (sourceTask === task) {
                                    break;
                                }
                            }
                            sourceRow.tasks.splice(i, 1);
                            task.component.store.set({visibleRows: visibleRows});
                            
                            task.component.fire('taskMovedRow', { task: task, row: targetRow });
                            targetRow.component.moved();
                        }
                        task.component.fire('taskMoved', { task: task });
                        //task.component.fire('updateVisibleRows');
                    }
                    task.component.set({task:task});
                    notify(task);
                }

                function onmouseup(event) {
                    console.log('drag up'); 
                    task.dragging = false;
                    task.resizing = false;
                    task.direction = null;
                    windowElement.removeEventListener('mousemove', onmousemove, false);
                    task.component.fire('taskDropped', { task });

                    //code this better
                    if(task.originalRow && task.originalRow !== task.row) {
                        task.originalRow.component.taskMoved();
                    }
                }

                node.addEventListener('mousedown', onmousedown, false);

				return {
					update() {
                        
					},

					destroy() {
						node.removeEventListener('mousedown', onmousedown, false);
						node.removeEventListener('mousemove', onmousemove, false);
						node.removeEventListener('mouseup', onmouseup, false);
					}
				}
            },
            contextMenu(node){
                const { task } = this.get();
                const { contextMenuManager } = this.store.get();

                const options = [
                    {
                        label: 'Copy',
                        action: () => console.log('clicked action 1 for task ', task.id)
                    },
                    {
                        label: 'Clear dependencies',
                        action: () => console.log('clicked action 2 for task ', task.id)
                    }
                ];

                function onClose(event) {
                    //if(!contextMenu.isTarget(e))
                    contextMenuManager.close();
                }

				node.addEventListener('mouseup', (e) => {
                    if(e.which === 3){
                        e.stopPropagation();
                        contextMenuManager.open(options, {x: e.x, y: e.y})

                        Utils.addEventListenerOnce(node, 'mousedown', onClose); //document.body
                    }
                });

				return {
					destroy() {
                        contextMenuManager.close();
					}
				}
            },
            selectable(node) {
                const { task } = this.get();
                const self = this;
                node.addEventListener('click', (e) => {
                    task.selected = !!!task.selected;
                    self.set({ task });
                });
            }
		},
        methods: {
			updateTaskPosition() {
                const { ganttUtils } = this.store.get();
                const { task } = this.get();
            
                //console.log(task.from.format('DD-MM-YYYY HH:mm:ss:SSS'), task.to.format('DD-MM-YYYY HH:mm:ss:SSS'));
                updatePosition(task, ganttUtils);


                //console.log(task.left, task.width);
                //this.set({ task: task });
            },
            updateTaskDate() {
                const { ganttUtils } = this.store.get();
                const { task } = this.get();
                
                if(task) {
                    const from = ganttUtils.getDateByPosition(task.left);
                    const to = ganttUtils.getDateByPosition(task.left + task.width);
                    

                    task.from = this.magnetDate(from);
                    task.to = this.magnetDate(to);

                    //console.log(from.format('DD-MM-YYYY HH:mm'), to.format('DD-MM-YYYY HH:mm'));
                            
                    //this.set({ task: task });
                }
                
            },
            magnetDate(date) {
                const { ganttUtils } = this.store.get();
                return ganttUtils.roundTo(date);
            }
        },

        data() {
            return {
                task: { dragging: false }
            }
        }
    };
</script>