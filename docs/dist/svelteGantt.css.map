{
  "version": 3,
  "file": "svelteGantt.css",
  "sources": [
    "..\\..\\Gantt.svelte",
    "..\\..\\Column.svelte",
    "..\\..\\ColumnHeaderRow.svelte",
    "..\\..\\Columns.svelte",
    "..\\..\\Milestone.svelte",
    "..\\..\\Row.svelte",
    "..\\..\\Task.svelte",
    "..\\..\\TimeRange.svelte",
    "..\\..\\TimeRangeHeader.svelte",
    "..\\..\\Arrow.svelte",
    "..\\..\\Dependency.svelte",
    "..\\..\\GanttDependencies.svelte",
    "..\\..\\Table.svelte",
    "..\\..\\TableRow.svelte",
    "..\\..\\TableTreeCell.svelte",
    "..\\..\\ContextMenu.svelte",
    "..\\..\\Resizer.svelte"
  ],
  "sourcesContent": [
    "<script>\r\n    import { onMount, setContext, tick, onDestroy } from 'svelte';\r\n    import { writable, derived } from 'svelte/store';\r\n\r\n    let ganttElement;\r\n    let mainHeaderContainer;\r\n    let mainContainer;\r\n    let rowContainer;\r\n    let scrollables = [];\r\n    let mounted = false;\r\n\r\n    import { rowStore, taskStore, timeRangeStore, allTasks, allRows, allTimeRanges, rowTaskCache } from './core/store';\r\n    import { Task, Row, TimeRange, TimeRangeHeader, Milestone } from './entities';\r\n    import { Columns, ColumnHeader } from './column';\r\n    import { Resizer } from \"./ui\";\r\n\r\n    import { GanttUtils, getPositionByDate } from \"./utils/utils\";\r\n    import { getRelativePos, debounce, throttle } from \"./utils/domUtils\";\r\n    import { SelectionManager } from \"./utils/selectionManager\";\r\n    import { GanttApi } from \"./core/api\";\r\n    import { TaskFactory, reflectTask } from \"./core/task\";\r\n    import { RowFactory } from \"./core/row\";\r\n    import { TimeRangeFactory } from \"./core/timeRange\";\r\n    import { DragDropManager } from \"./core/drag\";\r\n    import { findByPosition, findByDate } from './core/column';\r\n    import { onEvent, onDelegatedEvent, offDelegatedEvent } from './core/events';\r\n\r\n    export let rows;\r\n    export let tasks = [];\r\n    export let timeRanges = [];\r\n    $: if(mounted) initRows(rows);\r\n    $: if(mounted) initTasks(tasks);\r\n    $: if(mounted) initTimeRanges(timeRanges);\r\n\r\n    export let rowPadding = 6;\r\n    export let rowHeight = 52;\r\n    const _rowHeight = writable(rowHeight);\r\n    const _rowPadding = writable(rowPadding);\r\n\r\n    export let from;\r\n    export let to;\r\n    const _from = writable(from);\r\n    const _to = writable(to);\r\n    $: $_from = from;\r\n    $: $_to = to;\r\n\r\n    export let minWidth = 800;\r\n    export let fitWidth = false;\r\n    const _minWidth = writable(minWidth);\r\n    const _fitWidth = writable(fitWidth);\r\n\r\n    export let classes = [];\r\n    export let headers = [{unit: 'day', format: 'MMMM Do'}, {unit: 'hour', format: 'H:mm'}];\r\n    export let zoomLevels = [\r\n\t\t{\r\n\t\t\theaders: [\r\n\t\t\t\t{ unit: 'day', format: 'DD.MM.YYYY' },\r\n\t\t\t\t{ unit: 'hour', format: 'HH' }\r\n\t\t\t],\r\n\t\t\tminWidth: 800,\r\n\t\t\tfitWidth: true\r\n\t\t},\r\n\t\t{\r\n\t\t\theaders: [\r\n\t\t\t\t{ unit: 'hour', format: 'ddd D/M, H A' },\r\n\t\t\t\t{ unit: 'minute', format: 'mm', offset: 15 }\r\n\t\t\t],\r\n\t\t\tminWidth: 5000,\r\n\t\t\tfitWidth: false\r\n\t\t}\r\n\t];\r\n    export let taskContent = null;\r\n    export let tableWidth = 100;\r\n    export let resizeHandleWidth = 10;\r\n    export let onTaskButtonClick = null;\r\n\r\n    export let magnetUnit = 'minute';\r\n    export let magnetOffset = 15;\r\n    export let columnUnit = 'minute';\r\n    export let columnOffset = 15;\r\n\r\n    // export until Svelte3 implements Svelte2's setup(component) hook\r\n    export let ganttTableModules = [];\r\n    export let ganttBodyModules = [];\r\n\r\n    export let reflectOnParentRows = true;\r\n    export let reflectOnChildRows = false;\r\n\r\n    const visibleWidth = writable();\r\n    const visibleHeight = writable();\r\n    const headerHeight = writable();\r\n    const _width = derived([visibleWidth, _minWidth, _fitWidth], ([visible, min, stretch]) => {\r\n        return stretch && visible > min ? visible : min;\r\n    });\r\n    \r\n    export const columnService = {\r\n        getColumnByDate(date) {\r\n            const pair = findByDate(columns, date);\r\n            return !pair[0] ? pair[1] : pair[0];\r\n        },\r\n        getColumnByPosition(x) {\r\n            const pair = findByPosition(columns, x);\r\n            return !pair[0] ? pair[1] : pair[0];\r\n        },\r\n        getPositionByDate (date) {\r\n            if(!date) return null;\r\n            const column = this.getColumnByDate(date);\r\n            \r\n            let durationTo = date.diff(column.from, 'milliseconds');\r\n            const position = durationTo / column.duration * column.width;\r\n\r\n            //multiples - skip every nth col, use other duration\r\n            return column.left + position;\r\n        },\r\n        getDateByPosition (x) {\r\n            const column = this.getColumnByPosition(x);\r\n            x = x - column.left;\r\n\r\n            let positionDuration = column.duration / column.width * x;\r\n            const date = moment(column.from).add(positionDuration, 'milliseconds');\r\n\r\n            return date;\r\n        },\r\n        /**\r\n         * \r\n         * @param {Moment} date - Date\r\n         * @returns {Moment} rounded date passed as parameter\r\n         */\r\n        roundTo(date) {\r\n            let value = date.get(magnetUnit);\r\n            value = Math.round(value / magnetOffset);\r\n            date.set(magnetUnit, value * magnetOffset);\r\n\r\n            //round all smaller units to 0\r\n            const units = ['millisecond', 'second', 'minute', 'hour', 'date', 'month', 'year'];\r\n            const indexOf = units.indexOf(magnetUnit);\r\n            for (let i = 0; i < indexOf; i++) {\r\n                date.set(units[i], 0)\r\n            }\r\n            return date\r\n        }\r\n    }\r\n\r\n    const columnWidth = writable(getPositionByDate($_from.clone().add(columnOffset, columnUnit), $_from, $_to, $_width) | 0);\r\n    $: $columnWidth = getPositionByDate($_from.clone().add(columnOffset, columnUnit), $_from, $_to, $_width) | 0;\r\n    let columnCount = Math.ceil($_width / $columnWidth);\r\n    $: columnCount = Math.ceil($_width / $columnWidth);\r\n    let columns = getColumns($_from, columnCount, columnOffset, columnUnit, $columnWidth);\r\n    $: columns = getColumns($_from, columnCount, columnOffset, columnUnit, $columnWidth);\r\n\r\n    function getColumns(from, count, offset, unit, width) {\r\n        let columns = [];\r\n        let columnFrom = from.clone();\r\n        let left = 0;\r\n        for (let i = 0; i < count; i++) {\r\n            const from = columnFrom.clone();\r\n            const to = columnFrom.add(offset, unit);\r\n            const duration = to.diff(from, 'milliseconds');\r\n\r\n            columns.push({\r\n                width: width,\r\n                from,\r\n                left,\r\n                duration\r\n            });\r\n            left += width;\r\n            columnFrom = to;\r\n        }\r\n        \r\n        return columns;\r\n    }\r\n\r\n    const dimensionsChanged = derived([columnWidth, _from, _to], () => ({}));\r\n    $: {\r\n        if($dimensionsChanged) {\r\n            refreshTasks();\r\n            refreshTimeRanges();\r\n        }\r\n    }\r\n\r\n    setContext('dimensions', {\r\n        from: _from,\r\n        to: _to,\r\n        width: _width,\r\n        visibleWidth,\r\n        visibleHeight,\r\n        headerHeight,\r\n        dimensionsChanged\r\n    });\r\n\r\n    setContext('options', {\r\n        taskContent,\r\n        rowPadding: _rowPadding,\r\n        rowHeight: _rowHeight,\r\n        resizeHandleWidth: resizeHandleWidth,\r\n        reflectOnParentRows,\r\n        reflectOnChildRows,\r\n        onTaskButtonClick\r\n    });\r\n\r\n    const hoveredRow = writable();\r\n    const selectedRow = writable();\r\n\r\n    const ganttContext = { \r\n        scrollables, \r\n        hoveredRow, \r\n        selectedRow \r\n    };\r\n    setContext('gantt', ganttContext);\r\n\r\n    onMount(() => {\r\n        Object.assign(ganttContext, {\r\n            rowContainer,\r\n            mainContainer,\r\n            mainHeaderContainer\r\n        });\r\n\r\n        api.registerEvent('tasks', 'move');\r\n        api.registerEvent('tasks', 'select');\r\n        api.registerEvent('tasks', 'switchRow');\r\n        api.registerEvent('tasks', 'moveEnd');\r\n        api.registerEvent('tasks', 'change');\r\n        api.registerEvent('tasks', 'changed');\r\n        api.registerEvent('gantt', 'viewChanged');\r\n\r\n        mounted = true;\r\n    });\r\n\r\n    onDelegatedEvent('click', 'data-task-id', (event, data, target) => {\r\n        const taskId = +data;\r\n        if (event.ctrlKey) {\r\n            selectionManager.toggleSelection(taskId);\r\n        } else {\r\n            selectionManager.selectSingle(taskId);\r\n        }\r\n        api.tasks.raise.select($taskStore.entities[taskId]);\r\n    });\r\n\r\n    onDelegatedEvent('mouseover', 'data-row-id', (event, data, target) => {\r\n        $hoveredRow = +data;\r\n    });\r\n\r\n    onDelegatedEvent('click', 'data-row-id', (event, data, target) => {\r\n        $selectedRow = +data;\r\n    });\r\n    \r\n    onDestroy(() => {\r\n        offDelegatedEvent('click', 'data-task-id');\r\n        offDelegatedEvent('click', 'data-row-id');\r\n    });\r\n\r\n    let __scrollTop = 0;\r\n    let __scrollLeft = 0;\r\n    function scrollable(node) {\r\n        const onscroll = event => {\r\n            const { scrollTop, scrollLeft } = node;\r\n\r\n            scrollables.forEach(scrollable => {\r\n                if (scrollable.orientation === \"horizontal\") {\r\n                    scrollable.node.scrollLeft = scrollLeft;\r\n                } else {\r\n                    scrollable.node.scrollTop = scrollTop;\r\n                }\r\n            });\r\n\r\n            __scrollTop = scrollTop;\r\n            __scrollLeft = scrollLeft;\r\n        };\r\n\r\n        node.addEventListener(\"scroll\", onscroll);\r\n        return {\r\n            destroy() {\r\n                node.removeEventListener(\"scroll\", onscroll, false);\r\n            }\r\n        };\r\n    }\r\n\r\n    function horizontalScrollListener(node) {\r\n        scrollables.push({ node, orientation: \"horizontal\" });\r\n    }\r\n\r\n    function onResize(event) {\r\n        tableWidth = event.detail.left;\r\n    }\r\n\r\n    let zoomLevel = 0;\r\n    let zooming = false;\r\n    async function onwheel(event) {\r\n        if (event.ctrlKey) {\r\n            event.preventDefault();\r\n\r\n            const prevZoomLevel = zoomLevel;\r\n            if (event.deltaY > 0) {\r\n                zoomLevel = Math.max(zoomLevel - 1, 0);\r\n            } else {\r\n                zoomLevel = Math.min(zoomLevel + 1, zoomLevels.length - 1);\r\n            }\r\n\r\n            if (prevZoomLevel != zoomLevel && zoomLevels[zoomLevel]) {\r\n                const options = {\r\n                    columnUnit: columnUnit,\r\n                    columnOffset: columnOffset,\r\n                    minWidth: $_minWidth,\r\n                    ...zoomLevels[zoomLevel]\r\n                };\r\n\r\n                const scale = options.minWidth / $_width;\r\n                const node = mainContainer;\r\n                const mousepos = getRelativePos(node, event);\r\n                const before = node.scrollLeft + mousepos.x;\r\n                const after = before * scale;\r\n                const scrollLeft = after - mousepos.x + node.clientWidth / 2;\r\n\r\n                console.log('scrollLeft', scrollLeft);\r\n\r\n                columnUnit = options.columnUnit;\r\n                columnOffset = options.columnOffset;\r\n                $_minWidth = options.minWidth;\r\n\r\n                if(options.headers)\r\n                    headers = options.headers;\r\n\r\n                if(options.fitWidth)\r\n                    $_fitWidth = options.fitWidth;\r\n\r\n                api.gantt.raise.viewChanged();\r\n                zooming = true;\r\n                await tick();\r\n                node.scrollLeft = scrollLeft;\r\n                zooming = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function onDateSelected(event) {\r\n        $_from = event.detail.from.clone();\r\n        $_to = event.detail.to.clone();\r\n    }\r\n\r\n    function initRows(rowsData) {\r\n        const rows = rowFactory.createRows(rowsData);\r\n        rowStore.addAll(rows);\r\n    }\r\n\r\n    async function initTasks(taskData) {\r\n        await tick();\r\n\r\n        const tasks = [];\r\n        const opts = { rowPadding: $_rowPadding };\r\n        taskData.forEach(t => {\r\n            const task = taskFactory.createTask(t);\r\n            const row = $rowStore.entities[task.model.resourceId];\r\n            task.reflections = [];\r\n\r\n            if(reflectOnChildRows && row.allChildren) {\r\n                row.allChildren.forEach(r => {\r\n                    const reflectedTask = reflectTask(task, r, opts);\r\n                    task.reflections.push(reflectedTask.model.id);\r\n                    tasks.push(reflectedTask);\r\n                });\r\n            }\r\n\r\n            if(reflectOnParentRows && row.allParents.length > 0) {\r\n                row.allParents.forEach(r => {\r\n                    const reflectedTask = reflectTask(task, r, opts);\r\n                    task.reflections.push(reflectedTask.model.id);\r\n                    tasks.push(reflectedTask);\r\n                });\r\n            }\r\n\r\n            tasks.push(task);\r\n        });\r\n        taskStore.addAll(tasks);\r\n    }\r\n\r\n    function initTimeRanges(timeRangeData) {\r\n        const timeRanges = timeRangeData.map(timeRange => {\r\n            return timeRangeFactory.create(timeRange);\r\n        });\r\n        timeRangeStore.addAll(timeRanges);\r\n    }\r\n    \r\n    function onModuleInit(module) {\r\n        \r\n    }\r\n\r\n    async function tickWithoutCSSTransition() {\r\n        disableTransition = false;\r\n        await tick();\r\n        ganttElement.offsetHeight; // force a reflow\r\n        disableTransition = true;\r\n    }\r\n\r\n    export const api = new GanttApi();\r\n    const selectionManager = new SelectionManager();\r\n\r\n    export const taskFactory = new TaskFactory(columnService);\r\n    $: {\r\n        taskFactory.rowPadding = $_rowPadding;\r\n        taskFactory.rowEntities = $rowStore.entities;\r\n    }\r\n\r\n    export const rowFactory = new RowFactory();\r\n    $: rowFactory.rowHeight = rowHeight;\r\n\r\n    export const dndManager = new DragDropManager(rowStore);\r\n    export const timeRangeFactory = new TimeRangeFactory(columnService);\r\n\r\n    export const utils = new GanttUtils();\r\n    $: {\r\n        utils.from = $_from;\r\n        utils.to = $_to;\r\n        utils.width = $_width;\r\n        utils.magnetOffset = magnetOffset;\r\n        utils.magnetUnit = magnetUnit;\r\n    }\r\n\r\n    setContext('services', {\r\n        utils,\r\n        api,\r\n        dndManager,\r\n        selectionManager,\r\n        columnService\r\n    });\r\n\r\n    export function refreshTimeRanges() {\r\n        timeRangeStore._update(({ids, entities}) => {\r\n            ids.forEach(id => {\r\n                const timeRange = entities[id];\r\n                const newLeft = columnService.getPositionByDate(timeRange.model.from) | 0;\r\n                const newRight = columnService.getPositionByDate(timeRange.model.to) | 0;\r\n\r\n                timeRange.left = newLeft;\r\n                timeRange.width = newRight - newLeft;\r\n            });\r\n            return { ids, entities };\r\n        });\r\n    }\r\n\r\n    export function refreshTasks() {\r\n        $allTasks.forEach(task => {\r\n            const newLeft = columnService.getPositionByDate(task.model.from) | 0;\r\n            const newRight = columnService.getPositionByDate(task.model.to) | 0;\r\n\r\n            task.left = newLeft;\r\n            task.width = newRight - newLeft;\r\n        });\r\n\r\n        taskStore.refresh();\r\n    }\r\n\r\n    export function getRowContainer() {\r\n        return rowContainer;\r\n    }\r\n\r\n    export function selectTask(id) {\r\n        const task = $taskStore.entities[id];\r\n        if (task) {\r\n            selectionManager.selectSingle(task);\r\n        }\r\n    }\r\n\r\n    export function scrollToRow(id, scrollBehavior = 'auto') {\r\n        const { scrollTop, clientHeight } = mainContainer;\r\n        \r\n        const index = $allRows.findIndex(r => r.model.id == id);\r\n        if(index === -1) return;\r\n        const targetTop = index * rowHeight;\r\n\r\n        if(targetTop < scrollTop) {\r\n            mainContainer.scrollTo({\r\n                top: targetTop,\r\n                behavior: scrollBehavior\r\n            });\r\n        }\r\n\r\n        if(targetTop > scrollTop + clientHeight) {\r\n            mainContainer.scrollTo({\r\n                top: targetTop + rowHeight - clientHeight,\r\n                behavior: scrollBehavior\r\n            });\r\n        }\r\n    }\r\n\r\n\texport function scrollToTask(id, scrollBehavior = 'auto') {\r\n        const { scrollLeft, scrollTop, clientWidth, clientHeight } = mainContainer;\r\n        \r\n        const task = $taskStore.entities[id];\r\n        if(!task) return;\r\n        const targetLeft = task.left;\r\n        const rowIndex = $allRows.findIndex(r => r.model.id == task.model.resourceId);\r\n        const targetTop = rowIndex * rowHeight;\r\n        \r\n        const options = {\r\n            top: undefined,\r\n            left: undefined,\r\n            behavior: scrollBehavior\r\n        };\r\n\r\n        if(targetLeft < scrollLeft) {\r\n            options.left = targetLeft;\r\n        }\r\n\r\n        if(targetLeft > scrollLeft + clientWidth) {\r\n            options.left = targetLeft + task.width - clientWidth;\r\n        }\r\n\r\n        if(targetTop < scrollTop) {\r\n            options.top = targetTop;\r\n        }\r\n\r\n        if(targetTop > scrollTop + clientHeight) {\r\n            options.top = targetTop + rowHeight - clientHeight;\r\n        }\r\n        \r\n        mainContainer.scrollTo(options);\r\n    }\r\n\r\n    export function updateTask(model) {\r\n        const task = taskFactory.createTask(model);\r\n        taskStore.upsert(task);\r\n    }\r\n\r\n    let filteredRows = [];\r\n    $: filteredRows = $allRows.filter(row => !row.hidden);\r\n\r\n    let rightScrollbarVisible;\r\n    $: rightScrollbarVisible = rowContainerHeight > $visibleHeight;\r\n\r\n    let rowContainerHeight;\r\n    $: rowContainerHeight = filteredRows.length * rowHeight;\r\n\r\n    let startIndex;\r\n    $: startIndex = Math.floor(__scrollTop / rowHeight);\r\n\r\n    let endIndex;\r\n    $: endIndex = Math.min(startIndex + Math.ceil($visibleHeight / rowHeight), filteredRows.length - 1);\r\n\r\n    let paddingTop = 0;\r\n    $: paddingTop = startIndex * rowHeight;\r\n\r\n    let paddingBottom = 0;\r\n    $: paddingBottom = (filteredRows.length - endIndex - 1) * rowHeight;\r\n\r\n    let visibleRows = [];\r\n    $: visibleRows = filteredRows.slice(startIndex, endIndex + 1);\r\n\r\n    let visibleTasks;\r\n    $: {\r\n        const tasks = [];\r\n        visibleRows.forEach(row => {\r\n            if ($rowTaskCache[row.model.id]) {\r\n                $rowTaskCache[row.model.id].forEach(id => {\r\n                    tasks.push($taskStore.entities[id]);\r\n                });\r\n            }\r\n        });\r\n        visibleTasks = tasks;\r\n    }\r\n\r\n    let disableTransition = true;\r\n    $: if($dimensionsChanged) tickWithoutCSSTransition();\r\n</script>\r\n\r\n<div class=\"sg-gantt {classes}\" class:sg-disable-transition={!disableTransition} bind:this={ganttElement} on:click={onEvent} on:mouseover={onEvent}>\r\n    {#each ganttTableModules as module}\r\n    <svelte:component this={module} {rowContainerHeight} {paddingTop} {paddingBottom} tableWidth={tableWidth} {...$$restProps} on:init=\"{onModuleInit}\" {visibleRows} />\r\n\r\n    <Resizer x={tableWidth} on:resize=\"{onResize}\" container={ganttElement}></Resizer>\r\n    {/each}\r\n\r\n    <div class=\"sg-timeline sg-view\">\r\n        <div class=\"sg-header\" bind:this={mainHeaderContainer} bind:clientHeight=\"{$headerHeight}\" class:right-scrollbar-visible=\"{rightScrollbarVisible}\">\r\n            <div class=\"sg-header-scroller\" use:horizontalScrollListener>\r\n                <div class=\"header-container\" style=\"width:{$_width}px\">\r\n                    <ColumnHeader {headers} {columnUnit} {columnOffset} on:dateSelected=\"{onDateSelected}\" />\r\n                    {#each $allTimeRanges as timeRange (timeRange.id)}\r\n                    <TimeRangeHeader {...timeRange} />\r\n                    {/each}\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"sg-timeline-body\" bind:this={mainContainer} use:scrollable class:zooming=\"{zooming}\" on:wheel=\"{onwheel}\"\r\n         bind:clientHeight=\"{$visibleHeight}\" bind:clientWidth=\"{$visibleWidth}\">\r\n            <div class=\"content\" style=\"width:{$_width}px\">\r\n                <Columns columns={columns}/>\r\n                <div class=\"sg-rows\" bind:this={rowContainer} style=\"height:{rowContainerHeight}px;\">\r\n                    <div style=\"transform: translateY({paddingTop}px);\">\r\n                        {#each visibleRows as row (row.model.id)}\r\n                        <Row row={row} />\r\n                        {/each}\r\n                    </div>\r\n                </div>\r\n                <div class=\"sg-foreground\">\r\n                    {#each $allTimeRanges as timeRange (timeRange.id)}\r\n                    <TimeRange {...timeRange} />\r\n                    {/each}\r\n\r\n                    {#each visibleTasks as task (task.model.id)}\r\n                    <Task model={task.model} left={task.left}\r\n                     width={task.width} height={task.height} top={task.top} {...task} />\r\n                    {/each}\r\n                </div>\r\n                {#each ganttBodyModules as module}\r\n                <svelte:component this={module} {paddingTop} {paddingBottom} {visibleRows} {...$$restProps} on:init=\"{onModuleInit}\" />\r\n                {/each}\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<style>\r\n    .sg-disable-transition :global(.sg-task),\r\n    .sg-disable-transition :global(.sg-milestone) {\r\n        transition: transform 0s, background-color 0.2s, width 0s !important;\r\n    }\r\n\r\n    :global(.sg-view:not(:first-child)) {\r\n        margin-left: 5px;\r\n    }\r\n    \r\n    /* This class should take into account varying widths of the scroll bar */\r\n    .right-scrollbar-visible {\r\n        padding-right: 17px;\r\n    }\r\n\r\n    .sg-timeline {\r\n        flex: 1 1 0%;\r\n        display: flex;\r\n        flex-direction: column;\r\n        overflow-x: auto;\r\n    }\r\n\r\n    .sg-gantt {\r\n        display: flex;\r\n\r\n        width: 100%;\r\n        height: 100%;\r\n        position: relative;\r\n    }\r\n\r\n    .sg-foreground {\r\n        box-sizing: border-box;\r\n        overflow: hidden;\r\n        top: 0;\r\n        left: 0;\r\n        position: absolute;\r\n        width: 100%;\r\n        height: 100%;\r\n        z-index: 1;\r\n        pointer-events: none;\r\n    }\r\n\r\n    .sg-rows {\r\n        width: 100%;\r\n        box-sizing: border-box;\r\n        overflow: hidden;\r\n    }\r\n\r\n    .sg-timeline-body {\r\n        overflow: auto;\r\n        flex: 1 1 0;\r\n    }\r\n\r\n    .sg-header {\r\n        \r\n    }\r\n\r\n    .header-container {\r\n        position: relative;\r\n    }\r\n\r\n    .sg-header-scroller {\r\n        border-right: 1px solid #efefef;\r\n        overflow: hidden;\r\n    }\r\n\r\n    .content {\r\n        position: relative;\r\n    }\r\n\r\n    :global(*) {\r\n        box-sizing: border-box;\r\n    }\r\n</style>",
    "<script>\r\n    export let left;\r\n    export let width;\r\n</script>\r\n\r\n<div class=\"column\" style=\"left:{left}px;width:{width}px\"></div>\r\n<style>\r\n    .column {\r\n        position: absolute;\r\n        height: 100%;\r\n        box-sizing: border-box;\r\n    }\r\n</style>",
    "<script>\r\n    import { createEventDispatcher, getContext } from 'svelte';\r\n\r\n    const dispatch = createEventDispatcher();\r\n\r\n    import * as moment from 'moment';\r\n\r\n    const { from, to, width } = getContext('dimensions');\r\n    \r\n    export let header;\r\n    export let baseWidth;\r\n    export let baseDuration;\r\n\r\n    export let columnWidth;\r\n    $: {\r\n        const offset = header.offset || 1;\r\n        const duration = moment.duration(offset, header.unit).asMilliseconds();\r\n        const ratio = duration / baseDuration;\r\n        columnWidth = baseWidth * ratio;\r\n    }\r\n\r\n    export let columnCount;\r\n    $: {\r\n        columnCount = Math.ceil($width / columnWidth);\r\n        if(!isFinite(columnCount)){\r\n            console.error('columnCount is not finite');\r\n            columnCount = 0;\r\n        }\r\n    }\r\n\r\n    let _headers = [];\r\n    $: {\r\n        const headers = [];\r\n        let headerTime = $from.clone().startOf(header.unit);\r\n        const offset = header.offset || 1;\r\n\r\n        for(let i = 0; i < columnCount; i++){\r\n            headers.push({\r\n                width: Math.min(columnWidth, $width), \r\n                label: headerTime.format(header.format),\r\n                from: headerTime.clone(),\r\n                to: headerTime.clone().add(offset, header.unit),\r\n                unit: header.unit\r\n            });\r\n            headerTime.add(offset, header.unit);\r\n        }\r\n        _headers = headers;\r\n    }\r\n</script>\r\n\r\n<div class=\"column-header-row\">\r\n    {#each _headers as header}\r\n        <div class=\"column-header-cell\" style=\"width:{header.width}px\" on:click=\"{() => dispatch('dateSelected', { from: header.from, to: header.to, unit: header.unit })}\">\r\n            {header.label || 'N/A'}\r\n        </div>\r\n    {/each}\r\n</div>\r\n<style>\r\n    .column-header-row {\r\n        box-sizing: border-box;\r\n        white-space: nowrap;\r\n        overflow: hidden;\r\n\r\n        height: 32px;\r\n    }\r\n\r\n    .column-header-cell {\r\n        position: relative;\r\n        display: inline-block;\r\n        height: 100%;\r\n        box-sizing: border-box;\r\n        text-overflow: clip;\r\n        /* vertical-align: top; */\r\n        text-align: center;\r\n\r\n        display: inline-flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n        font-size: 1em;    \r\n        font-size: 14px;\r\n        font-weight: 300;\r\n        transition: background 0.2s;\r\n\r\n        cursor: pointer;     \r\n        user-select: none;\r\n    }\r\n\r\n    .column-header-cell:hover {\r\n        background: #f9f9f9;\r\n    }\r\n    \r\n</style>",
    "<script>\r\n    import { getContext, onMount } from 'svelte';\r\n    \r\n    import Column from './Column.svelte';\r\n    /**\r\n     * Container component for columns rendered as gantt body background\r\n     */\r\n    export let columns = [];\r\n\r\n    function lineAt(ctx, x) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(x, 0);\r\n        ctx.lineTo(x, 20);\r\n        ctx.stroke();\r\n    }\r\n\r\n    function createBackground(columns) {\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = columns.length * columns[0].width;\r\n        canvas.height = 20;\r\n\r\n        const ctx = canvas.getContext('2d');\r\n        ctx.shadowColor = \"rgba(128,128,128,0.5)\";\r\n        ctx.shadowOffsetX = 0;\r\n        ctx.shadowOffsetY = 0;\r\n        ctx.shadowBlur = 0.5;\r\n        ctx.lineWidth = 1;\r\n        ctx.lineCap = \"square\";\r\n        ctx.strokeStyle = '#efefef';\r\n        ctx.translate(0.5, 0.5);\r\n\r\n        columns.forEach(column => {\r\n            lineAt(ctx, column.left);\r\n        });\r\n\r\n        const dataURL = canvas.toDataURL();\r\n        return `url(\"${dataURL}\")`;\r\n    }\r\n\r\n    let backgroundImage;\r\n    $: {\r\n        backgroundImage = createBackground(columns.slice(0,4));\r\n    }\r\n</script>\r\n\r\n<div class=\"sg-columns\" style=\"background-image:{backgroundImage};\">\r\n\t<!-- {#each columns as column}\r\n\t<Column left={column.left} width={column.width} />\r\n\t{/each} -->\r\n</div>\r\n<style>\r\n    .sg-columns {\r\n        position: absolute;\r\n        height: 100%;\r\n        width: 100%;\r\n        overflow: hidden;\r\n\r\n        background-repeat: repeat;\r\n        background-position-x: -1px;\r\n    }\r\n</style>",
    "<script>\r\n    import { beforeUpdate, onMount, getContext } from 'svelte';\r\n\r\n    let milestoneElement;\r\n\r\n    import { Draggable } from '../core/drag';\r\n    import { rowStore, taskStore } from '../core/store';\r\n    const { rowPadding } = getContext('options');\r\n    const { selectionManager, api, rowContainer, dndManager, columnService} = getContext('services');\r\n\r\n    export let left;\r\n    export let top;\r\n    export let model;\r\n    export let height = 20;\r\n\r\n    const selection = selectionManager.selection;\r\n\r\n    let dragging = false;\r\n    let x = null;\r\n    let y = null;\r\n    $: {\r\n        if(!dragging){\r\n            x = left, y = top;\r\n        }\r\n    }\r\n\r\n    function drag(node) {\r\n        const ondrop = ({ x, y, currWidth, event, dragging }) => {\r\n            let rowChangeValid = true;\r\n            //row switching\r\n            if(dragging){\r\n                const sourceRow = $rowStore.entities[model.resourceId];\r\n                const targetRow = dndManager.getTarget('row', event);\r\n                if(targetRow){\r\n                    model.resourceId = targetRow.model.id;\r\n                    api.tasks.raise.switchRow(this, targetRow, sourceRow);\r\n                }\r\n                else{\r\n                    rowChangeValid = false;\r\n                }\r\n            }\r\n            \r\n            dragging = false;\r\n            const task = $taskStore.entities[model.id];\r\n            if(rowChangeValid) {\r\n                const newFrom = utils.roundTo(columnService.getDateByPosition(x)); \r\n                const newLeft = columnService.getPositionByDate(newFrom);\r\n\r\n                Object.assign(model, {\r\n                    from: newFrom\r\n                });\r\n                \r\n                $taskStore.update({\r\n                    ...task,\r\n                    left: newLeft,\r\n                    top: rowPadding + $rowStore.entities[model.resourceId].y,\r\n                    model\r\n                });\r\n            }\r\n            else {\r\n                // reset position\r\n                $taskStore.update({\r\n                    ...task\r\n                });\r\n            }\r\n        }\r\n\r\n        const draggable = new Draggable(node, {\r\n            onDown: ({x, y}) => {\r\n                //this.set({x, y});\r\n            }, \r\n            onDrag: (pos) => {\r\n                x = pos.x, y = pos.y, dragging = true;\r\n            },\r\n            dragAllowed: () => {\r\n                return row.model.enableDragging && model.enableDragging;\r\n            },\r\n            resizeAllowed: false,\r\n            onDrop: ondrop, \r\n            container: rowContainer, \r\n            getX: () => x,\r\n            getY: () => y\r\n        });\r\n\r\n        return {\r\n            destroy() { draggable.destroy(); }\r\n        }\r\n    }\r\n\r\n    onMount(() => {\r\n        x = left = columnService.getPositionByDate(model.from); \r\n        y = top = row.y + $rowPadding;; \r\n        height = row.height - 2 * $rowPadding;\r\n    });\r\n\r\n    export function select(event) {\r\n        if(event.ctrlKey){\r\n            selectionManager.toggleSelection(model.id);\r\n        }\r\n        else{\r\n            selectionManager.selectSingle(model.id);\r\n        }\r\n        \r\n        if(selected){\r\n            api.tasks.raise.select(model);\r\n        }\r\n    }\r\n\r\n    let selected = false;\r\n    $: selected = $selection.indexOf(model.id) !== -1;\r\n\r\n    let row;\r\n    $: row = $rowStore.entities[model.resourceId];\r\n</script>\r\n\r\n<div bind:this={milestoneElement}\r\n    class=\"sg-milestone {model.classes}\" \r\n    style=\"transform: translate({x}px, {y}px);height:{height}px;width:{height}px\"\r\n    use:drag \r\n    on:click=\"{select}\"\r\n    class:selected=\"{selected}\"\r\n    class:moving=\"{dragging}\">\r\n    <div class=\"inside\"></div>\r\n        <!-- <span class=\"debug\">x:{x|0} y:{y|0}, x:{left|0} y:{top|0}</span> -->\r\n</div>\r\n\r\n<style>\r\n    .sg-milestone {\r\n\t\tposition: absolute;     \r\n        top: 0;\r\n        bottom: 0;\r\n\r\n        white-space: nowrap;\r\n        /* overflow: hidden; */\r\n\r\n        height: 20px;\r\n        width: 20px;\r\n\r\n        min-width: 40px;\r\n        margin-left: -20px;\r\n        display: flex;\r\n        align-items: center;\r\n        flex-direction: column;\r\n\r\n        transition: background-color 0.2s, opacity 0.2s;\r\n    }\r\n\r\n    .sg-milestone .inside {\r\n        position: relative;\r\n    }\r\n\r\n    .sg-milestone .inside:before {\r\n        position: absolute;\r\n        top: 0;\r\n        left: 0;\r\n        content: ' ';\r\n        height: 28px;\r\n        width: 28px;\r\n        transform-origin: 0 0;\r\n        transform: rotate(45deg); \r\n        /* //after -45 */\r\n        background-color: #feac31;\r\n        border-color: #feac31;\r\n    }\r\n\r\n    .sg-milestone:not(.moving) {\r\n        transition: transform 0.2s, background-color 0.2s, width 0.2s;\r\n    }\r\n\r\n    .sg-milestone.moving{\r\n        z-index: 1;\r\n    }\r\n\r\n    .sg-milestone.selected {\r\n        outline: 2px solid rgba(3, 169, 244, 0.5);\r\n        outline-offset: 3px;\r\n        z-index: 1;\r\n    }\r\n</style>",
    "<script>\r\n    import { getContext } from 'svelte';\r\n    export let row;\r\n    let rowElement;\r\n\r\n    const { rowHeight } = getContext('options');\r\n    const { hoveredRow, selectedRow } = getContext('gantt');\r\n</script>\r\n\r\n<div class=\"sg-row {row.model.classes}\" data-row-id=\"{row.model.id}\" class:sg-hover={$hoveredRow == row.model.id} class:sg-selected={$selectedRow == row.model.id} bind:this={rowElement} style=\"height:{$rowHeight}px\">\r\n    {#if row.model.contentHtml}\r\n        {@html row.model.contentHtml}\r\n    {/if}\r\n</div>    \r\n<style>\r\n    .sg-row {\r\n        position: relative;\r\n        width: 100%;\r\n        box-sizing: border-box;\r\n    }\r\n</style>",
    "<script>\r\n    import { beforeUpdate, afterUpdate, getContext, onMount, onDestroy, tick } from \"svelte\";\r\n\r\n    import { setCursor } from \"src/utils/domUtils\";\r\n    import { taskStore, rowStore } from '../core/store';\r\n    import { Draggable } from \"../core/drag\";\r\n    import { reflectTask } from \"src/core/task\";\r\n\r\n    export let model;\r\n    export let height;\r\n    export let left;\r\n    export let top;\r\n    export let width;\r\n    export let reflected = false;\r\n\r\n    let animating = true;\r\n\r\n    let _dragging = false;\r\n    let _resizing = false;\r\n\r\n    let _position = {\r\n        x: left,\r\n        y: top,\r\n        width: width,\r\n    }\r\n\r\n    $: updatePosition(left, top, width);\r\n    function updatePosition(x, y, width) {\r\n        if(!_dragging && !_resizing) {\r\n            _position.x = x;\r\n            _position.y = y;//row.y + 6;\r\n            _position.width = width;\r\n            // should NOT animate on resize/update of columns\r\n        }\r\n    }\r\n\r\n    const { dimensionsChanged } = getContext('dimensions');\r\n    const { rowContainer } = getContext('gantt');\r\n    const { taskContent, resizeHandleWidth, rowPadding, onTaskButtonClick, reflectOnParentRows, reflectOnChildRows } = getContext('options');\r\n    const { dndManager, api, utils, selectionManager, columnService } = getContext('services');\r\n\r\n    function drag(node) {\r\n        const ondrop = (event) => {\r\n            let rowChangeValid = true;\r\n            //row switching\r\n            const sourceRow = $rowStore.entities[model.resourceId];\r\n            if (event.dragging) {\r\n                const targetRow = dndManager.getTarget(\"row\", event.mouseEvent);\r\n                if (targetRow) {\r\n                    model.resourceId = targetRow.model.id;\r\n                    api.tasks.raise.switchRow(this, targetRow, sourceRow);\r\n                } else {\r\n                    rowChangeValid = false;\r\n                }\r\n            }\r\n\r\n            _dragging = _resizing = false;\r\n\r\n            const task = $taskStore.entities[model.id];\r\n\r\n            if (rowChangeValid) {\r\n                const prevFrom = model.from;\r\n                const prevTo = model.to;\r\n                const newFrom = model.from = utils.roundTo(columnService.getDateByPosition(event.x));\r\n                const newTo = model.to = utils.roundTo(columnService.getDateByPosition(event.x + event.width));\r\n                const newLeft = columnService.getPositionByDate(newFrom) | 0;\r\n                const newRight = columnService.getPositionByDate(newTo) | 0;\r\n\r\n                const targetRow = $rowStore.entities[model.resourceId];\r\n                const left = newLeft;\r\n                const width = newRight - newLeft;\r\n                const top = $rowPadding + targetRow.y;\r\n                \r\n                updatePosition(left, top, width);\r\n\r\n                const newTask = {\r\n                    ...task,\r\n                    left: left,\r\n                    width: width,\r\n                    top: top,\r\n                    model\r\n                }\r\n\r\n                const changed = !prevFrom.isSame(newFrom) || !prevTo.isSame(newTo) || (sourceRow && sourceRow.model.id !== targetRow.model.id);\r\n                if(changed) {\r\n                    gantt.api.tasks.raise.change({ task: newTask, sourceRow, targetRow });\r\n                }\r\n\r\n                taskStore.update(newTask);\r\n\r\n                if(changed) {\r\n                    gantt.api.tasks.raise.changed({ task: newTask, sourceRow, targetRow });\r\n                }\r\n\r\n                // update shadow tasks\r\n                if(newTask.reflections) {\r\n                    taskStore.deleteAll(newTask.reflections);\r\n                }\r\n\r\n                const reflectedTasks = [];\r\n                if(reflectOnChildRows && targetRow.allChildren) {\r\n                    if(!newTask.reflections)\r\n                        newTask.reflections = [];\r\n\r\n                    const opts = { rowPadding: $rowPadding };\r\n                    targetRow.allChildren.forEach(r => {\r\n                        const reflectedTask = reflectTask(newTask, r, opts);\r\n                        newTask.reflections.push(reflectedTask.model.id);\r\n                        reflectedTasks.push(reflectedTask);\r\n                    });\r\n                }\r\n\r\n                if(reflectOnParentRows && targetRow.allParents.length > 0) {\r\n                    if(!newTask.reflections)\r\n                        newTask.reflections = [];\r\n\r\n                    const opts = { rowPadding: $rowPadding };\r\n                    targetRow.allParents.forEach(r => {\r\n                        const reflectedTask = reflectTask(newTask, r, opts);\r\n                        newTask.reflections.push(reflectedTask.model.id);\r\n                        reflectedTasks.push(reflectedTask);\r\n                    });\r\n                }\r\n\r\n                if(reflectedTasks.length > 0) {\r\n                    taskStore.upsertAll(reflectedTasks);\r\n                }\r\n\r\n                if(!(targetRow.allParents.length > 0) && !targetRow.allChildren) {\r\n                    newTask.reflections = null;\r\n                }\r\n            }\r\n            else {\r\n                // reset position\r\n                (_position.x = task.left), (_position.width = task.width), (_position.y = task.top);\r\n            }\r\n        };\r\n\r\n        const draggable = new Draggable(node, {\r\n            onDown: (event) => {\r\n                if (event.dragging) {\r\n                    setCursor(\"move\");\r\n                }\r\n                if (event.resizing) {\r\n                    setCursor(\"e-resize\");\r\n                }\r\n            },\r\n            onMouseUp: () => {\r\n                setCursor(\"default\");\r\n            },\r\n            onResize: (event) => {\r\n                (_position.x = event.x), (_position.width = event.width), (_resizing = true);\r\n            },\r\n            onDrag: (event) => {\r\n                (_position.x = event.x), (_position.y = event.y), (_dragging = true);\r\n            },\r\n            dragAllowed: () => {\r\n                return row.model.enableDragging && model.enableDragging;\r\n            },\r\n            resizeAllowed: () => {\r\n                return row.model.enableDragging && model.enableDragging;\r\n            },\r\n            onDrop: ondrop,\r\n            container: rowContainer,\r\n            resizeHandleWidth, \r\n            getX: () => _position.x,\r\n            getY: () => _position.y,\r\n            getWidth: () => _position.width\r\n        });\r\n        return {\r\n            destroy: () => draggable.destroy()\r\n        };\r\n    }\r\n\r\n    export function onclick(event) {\r\n        if (onTaskButtonClick) {\r\n            onTaskButtonClick(task);\r\n        }\r\n    }\r\n\r\n    let selection = selectionManager.selection;\r\n    let selected = false;\r\n    $: selected = $selection.indexOf(model.id) !== -1;\r\n\r\n    let row;\r\n    $: row = $rowStore.entities[model.resourceId];\r\n</script>\r\n\r\n<style>\r\n  .sg-label-bottom {\r\n    position: absolute;\r\n    top: calc(100% + 10px);\r\n    color: #888;\r\n  }\r\n\r\n  .debug {\r\n    position: absolute;\r\n    top: -10px;\r\n    right: 0;\r\n    font-size: 8px;\r\n    color: black;\r\n  }\r\n\r\n  .sg-task {\r\n    position: absolute;\r\n\r\n    white-space: nowrap;\r\n    /* overflow: hidden; */\r\n\r\n    transition: background-color 0.2s, opacity 0.2s;\r\n    pointer-events: all;\r\n  }\r\n\r\n  .sg-task-background {\r\n    position: absolute;\r\n    height: 100%;\r\n    top: 0;\r\n  }\r\n\r\n  .sg-task-content {\r\n    position: absolute;\r\n    height: 100%;\r\n    top: 0;\r\n\r\n    padding-left: 14px;\r\n    font-size: 14px;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: flex-start;\r\n  }\r\n\r\n  .sg-task:not(.moving) {\r\n    transition: transform 0.2s, background-color 0.2s, width 0.2s;\r\n  }\r\n\r\n  .sg-task.moving {\r\n    z-index: 1;\r\n  }\r\n\r\n  .sg-task:hover::before {\r\n    content: \"\";\r\n    width: 4px;\r\n    height: 50%;\r\n    top: 25%;\r\n    position: absolute;\r\n    cursor: ew-resize;\r\n    border-style: solid;\r\n    border-color: rgba(255, 255, 255, 0.5);\r\n\r\n    margin-left: 3px;\r\n    left: 0;\r\n    border-width: 0 1px;\r\n    z-index: 1;\r\n  }\r\n\r\n  .sg-task:hover::after {\r\n    content: \"\";\r\n    width: 4px;\r\n    height: 50%;\r\n    top: 25%;\r\n    position: absolute;\r\n    cursor: ew-resize;\r\n    border-style: solid;\r\n    border-color: rgba(255, 255, 255, 0.5);\r\n\r\n    margin-right: 3px;\r\n    right: 0;\r\n    border-width: 0 1px;\r\n    z-index: 1;\r\n  }\r\n\r\n  .sg-task.selected {\r\n    outline: 2px solid rgba(3, 169, 244, 0.5);\r\n    outline-offset: 3px;\r\n    z-index: 1;\r\n  }\r\n\r\n  .sg-task-reflected {\r\n      opacity: 0.5;\r\n  }\r\n</style>\r\n\r\n<div\r\n  data-task-id=\"{model.id}\"\r\n  use:drag\r\n  class=\"sg-task {model.classes}\"\r\n  style=\"width:{_position.width}px; height:{height}px; transform: translate({_position.x}px, {_position.y}px);\"\r\n  class:moving={_dragging || _resizing}\r\n  class:selected\r\n  class:animating\r\n  class:sg-task-reflected={reflected}>\r\n  {#if model.amountDone}\r\n  <div class=\"sg-task-background\" style=\"width:{model.amountDone}%\" />\r\n  {/if}\r\n  <div class=\"sg-task-content\">\r\n    {#if model.html}\r\n      {@html model.html}\r\n    {:else if taskContent}\r\n      {@html taskContent(model)}\r\n    {:else}{model.label}{/if}\r\n    <!-- <span class=\"debug\">x:{_position.x} y:{_position.y}, x:{left} y:{top}</span> -->\r\n    {#if model.showButton}\r\n      <span class=\"sg-task-button {model.buttonClasses}\" on:click={onclick}>\r\n        {@html model.buttonHtml}\r\n      </span>\r\n    {/if}\r\n  </div>\r\n\r\n  {#if model.labelBottom}\r\n    <label class=\"sg-label-bottom\">{model.labelBottom}</label>\r\n  {/if}\r\n</div>\r\n",
    "<script>\r\n    export let model;\r\n    export let left;\r\n    export let width;\r\n    export let resizing = false;\r\n\r\n    const _position = {\r\n        width,\r\n        x: left\r\n    }\r\n    $: {\r\n        _position.x = left, _position.width = width;\r\n    };\r\n</script>\r\n\r\n<div class=\"sg-time-range\" class:moving=\"{resizing}\" style=\"width:{_position.width}px;left:{_position.x}px\">\r\n    <div class=\"sg-time-range-label\">{model.label}</div>\r\n</div>\r\n<style>\r\n    .sg-time-range {\r\n        height: 100%;\r\n        position: absolute;\r\n        display: flex;\r\n        flex-direction: column;\r\n        align-items: center;\r\n\r\n        background-image: linear-gradient(-45deg, rgba(0, 0, 0, 0) 46%, #e03218 49%, #e03218 51%, rgba(0, 0, 0, 0) 55%);\r\n        background-size: 6px 6px !important;\r\n        color: red;\r\n        font-weight: 400;\r\n    }\r\n\r\n    .sg-time-range-label {\r\n        margin-top: 10px;\r\n        background: #fff;\r\n        white-space: nowrap;\r\n        padding: 4px;\r\n        font-weight: 400;\r\n        font-size: 10px;\r\n    }\r\n</style>",
    "<script>\r\n    import { beforeUpdate, getContext } from 'svelte';\r\n\r\n    import { Draggable } from '../core/drag';\r\n    import { timeRangeStore } from '../core/store';\r\n\r\n    const { rowContainer } = getContext('gantt');\r\n    const { utils, columnService } = getContext('services');\r\n    const { resizeHandleWidth } = getContext('options');\r\n    const {\r\n        from,\r\n        to,\r\n        width: ganttWidth,\r\n        visibleWidth\r\n    } = getContext('dimensions');\r\n\r\n    export let model;\r\n    export let width;\r\n    export let left;\r\n    \r\n    const _position = {\r\n        width,\r\n        x: left\r\n    }\r\n    $: {\r\n        _position.x = left, _position.width = width;\r\n    };\r\n\r\n    function drag(node) {\r\n        const ondrop = (event) => {\r\n            const newFrom = utils.roundTo(columnService.getDateByPosition(event.x)); \r\n            const newTo = utils.roundTo(columnService.getDateByPosition(event.x + event.width));\r\n            const newLeft = columnService.getPositionByDate(newFrom);\r\n            const newRight = columnService.getPositionByDate(newTo);\r\n            \r\n            Object.assign(model, {\r\n                from: newFrom,\r\n                to: newTo\r\n            });\r\n\r\n            update({\r\n                left: newLeft,\r\n                width: newRight - newLeft,\r\n                model,\r\n                resizing: false\r\n            });\r\n\r\n            window.removeEventListener('mousemove', onmousemove, false);\r\n        };\r\n\r\n        function update(state) {\r\n            timeRangeStore.update(state);\r\n            _position.x = state.left;\r\n            _position.width = state.width;\r\n        }\r\n\r\n        return new Draggable(node, {\r\n            onDown: (event) => {\r\n                update({\r\n                    left: event.x,\r\n                    width: event.width,\r\n                    model,\r\n                    resizing: true\r\n                });\r\n            }, \r\n            onResize: (event) => {\r\n                update({\r\n                    left: event.x,\r\n                    width: event.width,\r\n                    model,\r\n                    resizing: true\r\n                });\r\n            },\r\n            dragAllowed: false,\r\n            resizeAllowed: true,\r\n            onDrop: ondrop, \r\n            container: rowContainer, \r\n            resizeHandleWidth,\r\n            getX: () => _position.x,\r\n            getY: () => 0,\r\n            getWidth: () => _position.width\r\n        });\r\n    }\r\n</script>\r\n\r\n<div class=\"sg-time-range-control\" style=\"width:{_position.width}px;left:{_position.x}px\">\r\n    <div class=\"sg-time-range-handle-left\" use:drag></div>\r\n    <div class=\"sg-time-range-handle-right\" use:drag></div>\r\n</div>\r\n<style>\r\n    .sg-time-range-control {\r\n        position: absolute;\r\n    }\r\n\r\n    .sg-time-range-handle-left {\r\n        position: absolute;\r\n        left: 0;\r\n    }\r\n\r\n    .sg-time-range-handle-right {\r\n        position: absolute;\r\n        right: 0;\r\n    }\r\n\r\n    .sg-time-range-handle-left::before, .sg-time-range-handle-right::before {\r\n        position: absolute;\r\n        content: '';\r\n        bottom: 4px;\r\n        border-radius: 6px 6px 6px 0;\r\n        border: 2px solid #b0b0b7;\r\n        width: 9px;\r\n        height: 9px;\r\n        transform: translateX(-50%) rotate(-45deg);\r\n        background-color: #fff;\r\n\r\n        border-color: #e03218;\r\n        cursor: ew-resize;\r\n    }\r\n</style>",
    "<script>\r\n    import { onMount } from 'svelte';\r\n\r\n    export let startY;\r\n    export let endY;\r\n    export let endX;\r\n    export let startX;\r\n    export let minLen = 12;\r\n    export let arrowSize = 5;\r\n    export let stroke = 'red';\r\n    export let strokeWidth = 2;\r\n\r\n    onMount(() => {\r\n\r\n    });\r\n\r\n    let height;\r\n    $: height = endY - startY;\r\n\r\n    let width;\r\n    $: width = endX - startX;\r\n\r\n    let path;\r\n    $: {\r\n        if (startX == NaN || startX == undefined)\r\n            path = 'M0 0';\r\n\r\n        let result;\r\n        if (startX + minLen >= endX && startY != endY) {\r\n            result = `L ${startX + minLen} ${startY} \r\n                        L ${startX + minLen} ${startY + height / 2}\r\n                        L ${endX - minLen} ${startY + height / 2}\r\n                        L ${endX - minLen} ${endY} `\r\n        }\r\n        else {\r\n            result = `L ${startX + width / 2} ${startY} \r\n                        L ${startX + width / 2} ${endY}`\r\n        }\r\n\r\n        // -2 so the line doesn't stick out of the arrowhead\r\n        path = `M${startX} ${startY}` + result + `L ${endX - 2} ${endY}`\r\n    }\r\n\r\n    let arrowPath;\r\n    $: {\r\n        if (endX == NaN || endX == undefined)\r\n            arrowPath = 'M0 0';\r\n\r\n        arrowPath = `M${endX - arrowSize} ${endY - arrowSize} L${endX} ${endY} L${endX - arrowSize} ${endY + arrowSize} Z`\r\n    }\r\n</script>\r\n\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" shape-rendering=\"crispEdges\" class=\"arrow\" height=\"100%\" width=\"100%\">\r\n    <path d=\"{path}\" {stroke} stroke-width=\"{strokeWidth}\" fill=\"transparent\" class=\"select-area\" />\r\n    <path d=\"{arrowPath}\" fill=\"{stroke}\" />\r\n</svg>\r\n\r\n<style>\r\n    .arrow {\r\n        position: absolute;\r\n        left: 0px;\r\n        pointer-events: none;\r\n    }\r\n\r\n    .select-area {\r\n        pointer-events: visible;\r\n        position: absolute;\r\n    }\r\n</style>",
    "<script>\r\n    import Arrow from './Arrow.svelte';\r\n\r\n    import { taskStore } from '../../core/store';\r\n\r\n    export let id;\r\n    export let fromId;\r\n    export let toId;\r\n\r\n    let fromTask;\r\n    $: fromTask = $taskStore.entities[fromId];\r\n\r\n    let toTask;\r\n    $: toTask = $taskStore.entities[toId];\r\n</script>\r\n\r\n<div class=\"sg-dependency\" style=\"left:0;top:0\" data-dependency-id=\"{id}\">\r\n    <Arrow startX={fromTask.left + fromTask.width} startY={fromTask.top + fromTask.height / 2} endX={toTask.left}\r\n        endY={toTask.top + toTask.height / 2} />\r\n</div>\r\n\r\n<style>\r\n    .sg-dependency {\r\n        position: absolute;\r\n        width: 100%;\r\n        height: 100%;\r\n    }\r\n</style>",
    "<script context=\"module\">\r\n    const type = 'body';\r\n</script>\r\n\r\n<script>\r\n    import { getContext } from 'svelte';\r\n\r\n    import Dependency from './Dependency.svelte';\r\n    \r\n    import { taskStore } from '../../core/store';\r\n\r\n    const { visibleHeight } = getContext('dimensions');\r\n\r\n    export let paddingTop;\r\n    export let dependencies = [];\r\n\r\n    let visibleDependencies = [];\r\n    $: {\r\n        const result = [];\r\n        for (let i = 0; i < dependencies.length; i++) {\r\n            const dependency = dependencies[i];\r\n            const map = $taskStore.entities;\r\n\r\n            const fromTask = map[dependency.fromId];\r\n            const toTask = map[dependency.toId];\r\n            if(\r\n                fromTask && toTask \r\n                && Math.min(fromTask.top, toTask.top) <= paddingTop + $visibleHeight \r\n                && Math.max(fromTask.top, toTask.top) >= paddingTop\r\n            ) {\r\n                result.push(dependency);\r\n            }\r\n        }\r\n        visibleDependencies = result;\r\n    }\r\n</script>\r\n\r\n<div class=\"dependency-container\">\r\n    {#each visibleDependencies as dependency (dependency.id)}\r\n        <Dependency {...dependency}/>\r\n    {/each}\r\n</div>\r\n\r\n<style>\r\n    .dependency-container {\r\n        position: absolute;\r\n        width: 100%;\r\n        height: 100%;\r\n        \r\n        pointer-events: none;\r\n        top: 0;\r\n        float: left;\r\n        overflow: hidden;\r\n        z-index: 0;\r\n    }\r\n</style>",
    "<script context=\"module\">\r\n    export const type = 'table';\r\n</script>\r\n\r\n<script>\r\n    import { createEventDispatcher, onMount, getContext } from 'svelte';\r\n\r\n    const dispatch = createEventDispatcher();\r\n\r\n    import TableRow from './TableRow.svelte';\r\n    import { H_SCROLLBAR_WIDTH } from 'src/core/constants';\r\n    import { rowStore, taskStore } from \"../../core/store\";\r\n\r\n    export let tableWidth;\r\n    export let paddingTop;\r\n    export let paddingBottom;\r\n    export let rowContainerHeight;\r\n    export let visibleRows;\r\n    // list of columns used in the table\r\n    // title: label to display in the header\r\n    // property: property of row to display in the cell\r\n    // width: width of column\r\n    export let tableHeaders = [{ title: 'Name', property: 'label', width: 100 }];\r\n\r\n    const { from, to, width, visibleWidth, headerHeight } = getContext('dimensions');\r\n    const { rowPadding } = getContext('options');\r\n\r\n    onMount(() => {\r\n        dispatch('init', { module: this });\r\n    });\r\n\r\n    const { scrollables } = getContext('gantt');\r\n    let headerContainer;\r\n    function scrollListener(node) {\r\n        scrollables.push({ node, orientation: \"vertical\" });\r\n        \r\n        node.addEventListener(\"scroll\", event => {\r\n            headerContainer.scrollLeft = node.scrollLeft;\r\n        });\r\n\r\n        return {\r\n            destroy() {\r\n                node.removeEventListener(\"scroll\");\r\n            }\r\n        };\r\n    }\r\n    \r\n    let scrollWidth;\r\n    $: {\r\n        let sum = 0;\r\n        tableHeaders.forEach(header => {\r\n            sum += header.width;\r\n        });\r\n        scrollWidth = sum;\r\n    }\r\n\r\n    function onRowExpanded(event) {\r\n        const row = event.detail.row;\r\n        row.expanded = true;\r\n        if(row.children)\r\n            show(row.children);\r\n        updateYPositions();\r\n    }\r\n\r\n    function onRowCollapsed(event) {\r\n        const row = event.detail.row;\r\n        row.expanded = false;\r\n        if(row.children)\r\n            hide(row.children);\r\n        updateYPositions();\r\n    }\r\n\r\n    function updateYPositions() {\r\n        let y = 0;\r\n        $rowStore.ids.forEach(id => {\r\n            const row = $rowStore.entities[id];\r\n            if(!row.hidden) {\r\n                $rowStore.entities[id].y = y;\r\n                y+= 52; \r\n            }\r\n        });\r\n\r\n        $taskStore.ids.forEach(id => {\r\n            const task = $taskStore.entities[id];\r\n            const row = $rowStore.entities[task.model.resourceId];\r\n            $taskStore.entities[id].top = row.y + $rowPadding;\r\n        });\r\n    }\r\n\r\n    function hide(children) {\r\n        children.forEach(row => {\r\n            if(row.children)\r\n                hide(row.children);\r\n            row.hidden = true;\r\n        });\r\n    }\r\n\r\n    function show(children, hidden = false) {\r\n        children.forEach(row => {\r\n            if(row.children)\r\n                show(row.children, !row.expanded);\r\n            row.hidden = hidden;\r\n        });\r\n    }\r\n\r\n    // if gantt displays a bottom scrollbar and table does not, we need to pad out the table\r\n    let bottomScrollbarVisible;\r\n    $: {\r\n        bottomScrollbarVisible = $width > $visibleWidth && scrollWidth <= tableWidth;\r\n    } \r\n</script>\r\n\r\n<div class=\"sg-table sg-view\" style=\"width:{tableWidth}px;\">\r\n    <div class=\"sg-table-header\" style=\"height:{$headerHeight}px\" bind:this={headerContainer}>\r\n        {#each tableHeaders as header}\r\n            <div class=\"sg-table-header-cell sg-table-cell\" style=\"width:{header.width}px\">\r\n                {header.title}\r\n            </div>\r\n        {/each}\r\n    </div>\r\n\r\n    <div class=\"sg-table-body\" class:bottom-scrollbar-visible=\"{bottomScrollbarVisible}\">\r\n        <div class=\"sg-table-scroller\" use:scrollListener>\r\n            <div class=\"sg-table-rows\" style=\"padding-top:{paddingTop}px;padding-bottom:{paddingBottom}px;height:{rowContainerHeight}px;\"> \r\n                {#each visibleRows as row}\r\n                    <TableRow\r\n                        row={row}\r\n                        headers={tableHeaders}\r\n                        on:rowExpanded={onRowExpanded}\r\n                        on:rowCollapsed={onRowCollapsed}/>\r\n                {/each}\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<style>\r\n\r\n    /* This class should take into account varying widths of the scroll bar */\r\n    .bottom-scrollbar-visible {\r\n        padding-bottom: 17px;\r\n    }\r\n\r\n    .sg-table {\r\n        overflow-x: auto;\r\n        display: flex;\r\n        flex-direction: column;\r\n    }\r\n\r\n    .sg-table-scroller {\r\n        width: 100%;\r\n        border-bottom: 1px solid #efefef; \r\n        overflow-y: hidden;\r\n    }\r\n\r\n    .sg-table-header {\r\n        display: flex;\r\n        align-items: stretch;\r\n        /* width: 100%; */\r\n        overflow: hidden;\r\n    }\r\n\r\n    .sg-table-rows {\r\n        \r\n    }\r\n\r\n    .sg-table-body {\r\n        display: flex;\r\n        flex: 1 1 0;\r\n        width: 100%;\r\n        overflow-y: hidden;\r\n    }\r\n\r\n    .sg-table-header-cell {\r\n        font-size: 14px;\r\n        font-weight: 400;\r\n    }\r\n\r\n    :global(.sg-table-cell){\r\n        white-space: nowrap;\r\n        overflow: hidden;\r\n        \r\n        display: flex;\r\n        align-items: center;\r\n        flex-shrink: 0;\r\n\r\n        padding: 0 .5em;\r\n        height: 100%;\r\n    }\r\n    \r\n    :global(.sg-table-cell:last-child) {\r\n        flex-grow: 1;\r\n    }\r\n</style>",
    "<script>\r\n    import { createEventDispatcher, getContext } from \"svelte\";\r\n\r\n    import TableTreeCell from './TableTreeCell.svelte';\r\n\r\n    export let headers = null;\r\n    export let row = null;\r\n\r\n    const { rowHeight } = getContext('options');\r\n    const { hoveredRow, selectedRow } = getContext('gantt');\r\n\r\n    const dispatch = createEventDispatcher();\r\n\r\n    let treeIndentationStyle = '';\r\n    $: {\r\n        treeIndentationStyle = row.parent ? `padding-left: ${row.childLevel*3}em;`:'';\r\n    }\r\n\r\n</script>\r\n\r\n<div class=\"sg-table-row {row.model.class || ''}\" style=\"height:{$rowHeight}px\" data-row-id={row.model.id} class:sg-row-expanded=\"{row.expanded}\" class:sg-hover={$hoveredRow == row.model.id} class:sg-selected={$selectedRow == row.model.id}>\r\n    {#each headers as header}\r\n        <div class=\"sg-table-body-cell sg-table-cell\" style=\"width:{header.width}px\">\r\n            {#if header.type == 'tree'}\r\n                <TableTreeCell on:rowCollapsed on:rowExpanded {row}>\r\n                    {#if row.model.iconClass}\r\n                    <div class=\"sg-table-icon\">\r\n                        <i class=\"{row.model.iconClass}\"></i>\r\n                    </div>\r\n                    {/if}\r\n\r\n                    {#if row.model.headerHtml}\r\n                        {@html row.model.headerHtml}\r\n                    {:else if header.renderer}\r\n                        {@html header.renderer(row)}\r\n                    {:else}\r\n                        {row.model[header.property]}\r\n                    {/if}\r\n                </TableTreeCell>\r\n            {:else}\r\n                {#if row.model.iconClass}\r\n                <div class=\"sg-table-icon\">\r\n                    <i class=\"{row.model.iconClass}\"></i>\r\n                </div>\r\n                {/if}\r\n\r\n                {#if row.model.headerHtml}\r\n                    {@html row.model.headerHtml}\r\n                {:else if header.renderer}\r\n                    {@html header.renderer(row)}\r\n                {:else if header.type === 'resourceInfo'}\r\n                    <img class=\"sg-resource-image\" src=\"{row.model.imageSrc}\" alt=\"\"/>\r\n                    <div class=\"sg-resource-title\">\r\n                        {row.model[header.property]}\r\n                    </div>\r\n                {:else}\r\n                    {row.model[header.property]}\r\n                {/if}\r\n            {/if}\r\n        </div>\r\n    {/each}\r\n</div>\r\n<style>\r\n    .sg-table-row {\r\n        display: inline-flex;\r\n        min-width: 100%;\r\n        align-items: stretch;\r\n\r\n        position: relative;\r\n\r\n        font-weight: 400;\r\n        font-size: 14px;\r\n    }\r\n\r\n    .sg-table-cell {\r\n    }\r\n\r\n    .sg-resource-image {\r\n        width: 2.4em;\r\n        height: 2.4em;\r\n        border-radius: 50%;\r\n        margin-right: .6em;\r\n\r\n        background: #047c69;\r\n    }\r\n\r\n    .sg-resource-info {\r\n        flex: 1;\r\n        height: 100%;\r\n        display: flex;\r\n        flex-direction: row;\r\n        align-items: center;\r\n    }\r\n\r\n    .sg-table-icon {\r\n        margin-right: 0.5em;\r\n    }\r\n</style>",
    "<script>\r\n    import { createEventDispatcher, getContext } from \"svelte\";\r\n\r\n    export let row;\r\n    \r\n    const dispatch = createEventDispatcher();\r\n\r\n    function onExpandToggle() {\r\n        if(row.expanded) {\r\n            dispatch('rowCollapsed', { row });\r\n        } else {\r\n            dispatch('rowExpanded', { row });\r\n        }\r\n    }\r\n</script>\r\n\r\n<div class=\"sg-cell-inner\" style=\"padding-left: {row.childLevel*3}em\">\r\n    {#if row.children}\r\n        <div class=\"sg-tree-expander\" on:click=\"{onExpandToggle}\">\r\n            {#if row.expanded}\r\n            <i class=\"fas fa-angle-down\"></i>\r\n            {:else}\r\n            <i class=\"fas fa-angle-right\"></i>\r\n            {/if}\r\n        </div>\r\n    {/if}\r\n    <slot></slot>\r\n</div>\r\n\r\n<style>\r\n    .sg-tree-expander {\r\n        cursor: pointer;\r\n        min-width: 1.4em;\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n    }\r\n\r\n    .sg-cell-inner {\r\n        display: flex;\r\n    }\r\n</style>",
    "<script>\r\n    import { onMount } from 'svelte';\r\n\r\n    export let top;\r\n    export let left;\r\n    export let actions = [];\r\n    export let onactionend = null;\r\n\r\n    function position(point) {\r\n        top = point.y, left = point.x;\r\n    }\r\n\r\n    function execute(event, action) {\r\n        event.stopPropagation();\r\n        action.action();\r\n        if(onactionend) onactionend();\r\n    }\r\n\r\n    export function isTarget(event) {\r\n        return contextMenu === event.target;\r\n    }\r\n</script>\r\n\r\n<div class=\"sg-context-menu\" style=\"top:{top}px;left:{left}px\">    \r\n    {#each actions as action}\r\n        <div class=\"context-option\" on:click=\"{event => execute(event, action)}\">{action.label}</div>\r\n    {/each}\r\n</div>\r\n\r\n<style>\r\n    .sg-context-menu {\r\n        position: absolute;\r\n        background: white;\r\n        border: 1px solid #ccc;\r\n        padding: 0.25em 0;\r\n        font-size: 10px;\r\n        transition: opacity 0.4s ease 0s;\r\n        opacity: 1;\r\n        box-shadow: rgba(0, 0, 0, 0.32) 1px 1px 3px 0px;\r\n    }\r\n\r\n    .context-option:hover {\r\n        background: #eee;\r\n    }\r\n\r\n    .context-option {\r\n        cursor: default;\r\n        padding: 0.2em 1em;\r\n    }\r\n</style>",
    "<script>\r\n    import { createEventDispatcher, onMount } from 'svelte';\r\n\r\n    const dispatch = createEventDispatcher();\r\n\r\n    import { Draggable } from 'src/core/drag';\r\n    import { setCursor } from 'src/utils/domUtils';\r\n\r\n    export let x = 240;\r\n    export let container;\r\n\r\n    let dragging = false;\r\n    const dragOptions = {\r\n        onDrag: (event) => {\r\n            x = event.x, dragging = true;\r\n            dispatch('resize', { left: x });\r\n            setCursor('col-resize');\r\n        },\r\n        onDrop: (event) => {\r\n            x = event.x, dragging = false;\r\n            dispatch('resize', { left: x });\r\n            setCursor('default');\r\n        }, \r\n        dragAllowed: true,\r\n        resizeAllowed: false,\r\n        container: container, \r\n        getX: () => x,\r\n        getY: () => 0,\r\n        getWidth: () => 0\r\n    }\r\n\r\n    $: dragOptions.container = container;\r\n\r\n    function resizer(node) {\r\n        return new Draggable(node, dragOptions);\r\n    }\r\n</script>\r\n\r\n<div class=\"sg-resize\" style=\"left:{x}px\" use:resizer></div>\r\n<style>\r\n    .sg-resize {\r\n        z-index: 2;\r\n        background: #e9eaeb;\r\n        width: 5px;\r\n        cursor: col-resize;\r\n        position: absolute;\r\n        height: 100%;\r\n\r\n        transition: width 0.2s, transform 0.2s;\r\n    }\r\n\r\n    .sg-resize:hover {\r\n        transform: translateX(-2px);\r\n        width: 10px;\r\n    }\r\n</style>"
  ],
  "names": [],
  "mappings": "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"
}